/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! ./src/polyfills/processWrapper.js */ \"./src/polyfills/processWrapper.js\")[\"default\"];\n// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n\n\n//# sourceURL=webpack://LCC/./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./src/core/assembler.js":
/*!*******************************!*\
  !*** ./src/core/assembler.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"./src/polyfills/fsWrapper.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n/* harmony import */ var _utils_genStats_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/genStats.js */ \"./src/utils/genStats.js\");\n/* harmony import */ var _utils_name_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/name.js */ \"./src/utils/name.js\");\n/* provided dependency */ var process = __webpack_require__(/*! ./src/polyfills/processWrapper.js */ \"./src/polyfills/processWrapper.js\")[\"default\"];\n//#!/usr/bin/env node\n\n// assembler.js\n// LCC.js Assembler\n\n/*\r\n * The Assembler class performs a two-pass assembly process:\r\n * Pass 1: Parses the source lines, builds the symbol table, and handles labels.\r\n * Pass 2: Generates machine code based on the symbol table and source lines.\r\n*/\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\nvar isTestMode = typeof {}.it === 'function'; // crude check for Jest\n\nfunction fatalExit(message) {\n  var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  if (isTestMode) {\n    throw new Error(message);\n  } else {\n    process.exit(code);\n  }\n}\n\n// Set to false to match original LCC behavior of reporting only a single error at a time\nvar REPORT_MULTI_ERRORS = false;\nvar Assembler = /*#__PURE__*/function () {\n  function Assembler() {\n    _classCallCheck(this, Assembler);\n    /**\r\n     * Symbol table: symbol to address mapping\r\n     */\n    this.symbolTable = {};\n\n    /**\r\n     * Location counter\r\n     */\n    this.locCtr = 0;\n\n    /**\r\n     * Line number\r\n     */\n    this.lineNum = 0;\n\n    /**\r\n     * Array of source code lines\r\n     */\n    this.sourceLines = [];\n\n    /**\r\n     * Error flag\r\n     */\n    this.errorFlag = false;\n\n    /**\r\n     * Current pass (1 or 2)\r\n     */\n    this.pass = 1;\n\n    /**\r\n     * Set of labels to detect duplicates\r\n     */\n    this.labels = new Set();\n\n    /**\r\n     * Collect errors\r\n     */\n    this.errors = [];\n\n    /**\r\n     * Buffer to hold machine code words\r\n     */\n    this.outputBuffer = [];\n\n    /**\r\n     * Input file name\r\n     */\n    this.inputFileName = '';\n\n    /**\r\n     * Output file name\r\n     */\n    this.outputFileName = '';\n\n    /**\r\n     * Output file handle\r\n     */\n    this.outFile = null;\n\n    /**\r\n     * This will store information about each line, including the location counter (locCtr), machine code words, and the source code line.\r\n     */\n    this.listing = [];\n\n    /**\r\n     * Load point\r\n     */\n    this.loadPoint = 0;\n\n    /**\r\n     * Program size\r\n     */\n    this.programSize = 0;\n\n    /**\r\n     * Label specified in .start directive\r\n     */\n    this.startLabel = null;\n\n    /**\r\n     * Resolved address of the start label\r\n     */\n    this.startAddress = null;\n\n    /**\r\n     * Flag to indicate if the code is to be made into a .o object file\r\n     */\n    this.isObjectModule = false;\n\n    /**\r\n     * Set of global labels to be exported\r\n     */\n    this.globalLabels = new Set();\n\n    /**\r\n     * Set of external labels to be imported\r\n     */\n    this.externLabels = new Set();\n\n    /**\r\n     * Array to store external references\r\n     */\n    this.externalReferences = [];\n\n    /**\r\n     * Array to store adjustment entries\r\n     */\n    this.adjustmentEntries = [];\n  }\n\n  /**\r\n   * Adds the given address to the adjustmentEntries array if it is not already included.\r\n   *\r\n   * @param {number} address - The address to be added to the adjustmentEntries array.\r\n   */\n  return _createClass(Assembler, [{\n    key: \"handleAdjustmentEntry\",\n    value: function handleAdjustmentEntry(address) {\n      if (!this.adjustmentEntries.includes(address)) {\n        this.adjustmentEntries.push(address);\n      }\n    }\n  }, {\n    key: \"main\",\n    value: function main(args) {\n      args = args || process.argv.slice(2);\n\n      //// TODO: change logic here to only give usage message\n      ////       if no input files are provided\n      // Check if inputFileName is already set\n      if (!this.inputFileName) {\n        if (args.length !== 1) {\n          console.error('Usage: assembler.js <input filename>');\n          fatalExit('Usage: assembler.js <input filename>', 1);\n        }\n        this.inputFileName = args[0];\n      }\n\n      // Read the source code from the input file\n      try {\n        var sourceCode = fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].readFileSync(this.inputFileName, 'utf-8');\n        this.sourceLines = sourceCode.split('\\n');\n      } catch (err) {\n        console.error(\"Cannot open input file \".concat(this.inputFileName)); // , err: ${err}\n        fatalExit(\"Cannot open input file \".concat(this.inputFileName), 1); // , err: ${err}\n      }\n      var extension = path__WEBPACK_IMPORTED_MODULE_1__.extname(this.inputFileName).toLowerCase();\n\n      // If the file ends in \".bin\", parse it as raw binary instead of doing normal assembly\n      if (extension === '.bin') {\n        // Note: The original LCC does not print any message for assemnbling a .bin file as\n        // of 12/2024. I say this should be here to provide user feedback & good UX\n        console.log(\"Assembling \".concat(this.inputFileName));\n        this.parseBinFile();\n        // Construct output filename with .e extension\n        this.outputFileName = this.constructOutputFileName(this.inputFileName, '.e');\n        // Now write the output as a .e file\n        this.writeOutputFile();\n      } else if (extension === '.hex') {\n        console.log(\"Assembling \".concat(this.inputFileName));\n        this.parseHexFile();\n        this.outputFileName = this.constructOutputFileName(this.inputFileName, '.e');\n        this.writeOutputFile();\n      } else if (extension === '.a') {\n        // If a .a file, proceed with normal two-pass assembly...\n        // Construct the output file name by replacing extension with '.e'\n        this.outputFileName = this.constructOutputFileName(this.inputFileName, '.e');\n\n        // Perform Pass 1\n        console.log('Starting assembly pass 1');\n        this.pass = 1;\n        this.locCtr = 0;\n        this.loadPoint = 0; // TODO: fix this to not be hardcoded, because flags may dictate where in memory the program starts\n        this.lineNum = 0;\n        this.errorFlag = false;\n        this.symbolTable = {};\n        this.labels.clear();\n        this.errors = [];\n        this.performPass();\n        if (this.locCtr === 0) {\n          console.error('Empty file');\n          fatalExit('Empty file', 0); // No instructions or data found in source file\n        }\n        if (this.errorFlag) {\n          // console.error('Errors encountered during Pass 1.');\n          // this.errors.forEach(error => console.error(error));\n          fatalExit('Errors encountered during Pass 1.', 1);\n        }\n\n        // Rewind source lines for Pass 2\n        console.log('Starting assembly pass 2');\n        this.pass = 2;\n        this.locCtr = 0;\n        this.lineNum = 0;\n        this.performPass();\n\n        // After Pass 2\n        if (this.isObjectModule) {\n          // Change output extension to .o\n          this.outputFileName = this.constructOutputFileName(this.inputFileName, '.o');\n        }\n        if (this.errorFlag) {\n          // console.error('Errors encountered during Pass 2.');\n          // Close the output file only if it's open\n          if (this.outFile !== null) {\n            fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].closeSync(this.outFile);\n          }\n          fatalExit('Errors encountered during Pass 2.', 1);\n        }\n\n        // **Resolve the start label to an address**\n        if (this.startLabel !== null) {\n          if (this.symbolTable.hasOwnProperty(this.startLabel)) {\n            this.startAddress = this.symbolTable[this.startLabel];\n          } else {\n            // Note: as of 12/2024, LCC does not print any message for this case\n            //       and instead ignores undefined .start labels (but it shouldn't)\n            //       so this is a custom LCC.js behavior\n            this.error(\"Undefined label\"); // Undefined start label: ${this.startLabel}\n            fatalExit(\"Undefined label\", 1);\n          }\n        } else {\n          // If no .start directive, default start address is 0\n          this.startAddress = 0;\n        }\n\n        // **Write the output file after Pass 2**\n        this.writeOutputFile();\n\n        // After writing the output file, handle additional outputs\n        if (this.isObjectModule) {\n          // Get the userName using nameHandler\n          try {\n            this.userName = _utils_name_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].createNameFile(this.inputFileName);\n          } catch (error) {\n            console.error('Error handling name file:', error.message);\n            fatalExit('Error handling name file: ' + error.message, 1);\n          }\n          console.log(\"Output file \".concat(this.outputFileName, \" needs linking\"));\n\n          // Generate .lst and .bst files\n          var lstFileName = this.constructOutputFileName(this.inputFileName, '.lst');\n          var bstFileName = this.constructOutputFileName(this.inputFileName, '.bst');\n\n          // Generate content for .lst file\n          var lstContent = (0,_utils_genStats_js__WEBPACK_IMPORTED_MODULE_2__.generateBSTLSTContent)({\n            isBST: false,\n            assembler: this,\n            includeSourceCode: true,\n            userName: this.userName,\n            inputFileName: this.inputFileName,\n            includeComments: false // note: this flag is only for .bin files\n          });\n\n          // Generate content for .bst file\n          var bstContent = (0,_utils_genStats_js__WEBPACK_IMPORTED_MODULE_2__.generateBSTLSTContent)({\n            isBST: true,\n            assembler: this,\n            includeSourceCode: true,\n            userName: this.userName,\n            inputFileName: this.inputFileName,\n            includeComments: false // note: this flag is only for .bin files\n          });\n\n          // Write the .lst file\n          fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeFileSync(lstFileName, lstContent, 'utf-8');\n\n          // Write the .bst file\n          fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeFileSync(bstFileName, bstContent, 'utf-8');\n          console.log(\"lst file = \".concat(lstFileName));\n          console.log(\"bst file = \".concat(bstFileName));\n        }\n      } else {\n        // Note: Treating only .a files as valid assembly files is\n        //       a unique LCC.js behavior as of 12/2024 (the official\n        //       LCC behavior is to treat all non .bin, .hex, .o, and \n        //       .e files as assembly files)\n        if (extension === '.ap') {\n          console.error('Error: .ap files are not supported by assembler.js - Did you mean to use assemblerPlus.js?');\n          fatalExit('Error: .ap files are not supported by assembler.js - Did you mean to use assemblerPlus.js?', 1);\n        }\n        console.error('Unsupported file type');\n        fatalExit('Unsupported file type', 1);\n      }\n    }\n  }, {\n    key: \"writeOutputFile\",\n    value: function writeOutputFile() {\n      var secondIntroHeader = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      // Open the output file for writing\n      try {\n        this.outFile = fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].openSync(this.outputFileName, 'w');\n      } catch (err) {\n        console.error(\"Cannot open output file \".concat(this.outputFileName));\n        fatalExit(\"Cannot open output file \".concat(this.outputFileName), 1);\n      }\n\n      // Write the initial header 'o' to the output file\n      fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(this.outFile, 'o');\n\n      // Custom LCC.js behavior as of 12/2024:\n      // Write the second intro header if it is provided\n      // This enables extensions that need use special header entries\n      if (secondIntroHeader !== '') {\n        fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(this.outFile, secondIntroHeader);\n      }\n\n      // Collect all header entries\n      var headerEntries = [];\n\n      // Add 'S' entry if present\n      if (this.startLabel !== null && this.startAddress !== null) {\n        headerEntries.push({\n          type: 'S',\n          address: this.startAddress\n        });\n      }\n\n      // Collect 'G' entries\n      var _iterator = _createForOfIteratorHelper(this.globalLabels),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var label = _step.value;\n          var address = this.symbolTable[label];\n          headerEntries.push({\n            type: 'G',\n            address: address,\n            label: label\n          });\n        }\n\n        // Collect external references ('E', 'e', 'V')\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var _iterator2 = _createForOfIteratorHelper(this.externalReferences),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var ref = _step2.value;\n          headerEntries.push({\n            type: ref.type,\n            address: ref.address,\n            label: ref.label\n          });\n        }\n\n        // Collect 'A' entries\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var _iterator3 = _createForOfIteratorHelper(this.adjustmentEntries),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _address = _step3.value;\n          headerEntries.push({\n            type: 'A',\n            address: _address\n          });\n        }\n\n        // Now sort the header entries by address\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      headerEntries.sort(function (a, b) {\n        return a.address - b.address;\n      });\n\n      // Write the header entries\n      for (var _i = 0, _headerEntries = headerEntries; _i < _headerEntries.length; _i++) {\n        var entry = _headerEntries[_i];\n        switch (entry.type) {\n          case 'S':\n            {\n              var buffer = Buffer.alloc(3);\n              buffer.write('S', 0, 'ascii');\n              buffer.writeUInt16LE(entry.address, 1);\n              fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(this.outFile, buffer);\n              break;\n            }\n          case 'G':\n            {\n              var _buffer = Buffer.alloc(3 + entry.label.length + 1);\n              _buffer.write('G', 0, 'ascii');\n              _buffer.writeUInt16LE(entry.address, 1);\n              _buffer.write(entry.label, 3, 'ascii');\n              _buffer.writeUInt8(0, 3 + entry.label.length);\n              fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(this.outFile, _buffer);\n              break;\n            }\n          case 'E':\n          case 'e':\n          case 'V':\n            {\n              var _buffer2 = Buffer.alloc(3 + entry.label.length + 1);\n              _buffer2.write(entry.type, 0, 'ascii');\n              _buffer2.writeUInt16LE(entry.address, 1);\n              _buffer2.write(entry.label, 3, 'ascii');\n              _buffer2.writeUInt8(0, 3 + entry.label.length);\n              fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(this.outFile, _buffer2);\n              break;\n            }\n          case 'A':\n            {\n              var _buffer3 = Buffer.alloc(3);\n              _buffer3.write('A', 0, 'ascii');\n              _buffer3.writeUInt16LE(entry.address, 1);\n              fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(this.outFile, _buffer3);\n              break;\n            }\n          default:\n            // Should not reach here\n            this.error(\"invalid header entry error\");\n            break;\n        }\n      }\n\n      // Write the code start marker 'C'\n      fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(this.outFile, 'C');\n\n      // Write machine code words\n      var codeBuffer = Buffer.alloc(this.outputBuffer.length * 2);\n      for (var i = 0; i < this.outputBuffer.length; i++) {\n        codeBuffer.writeUInt16LE(this.outputBuffer[i], i * 2);\n      }\n      fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(this.outFile, codeBuffer);\n\n      // Close the output file\n      fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].closeSync(this.outFile);\n    }\n  }, {\n    key: \"constructOutputFileName\",\n    value: function constructOutputFileName(inputFileName, extension) {\n      var parsedPath = path__WEBPACK_IMPORTED_MODULE_1__.parse(inputFileName);\n      // Remove extension and add the specified extension\n      return path__WEBPACK_IMPORTED_MODULE_1__.format(_objectSpread(_objectSpread({}, parsedPath), {}, {\n        base: undefined,\n        ext: extension\n      }));\n    }\n\n    // validates that a label either starts at the beginning of a line\n    // or is terminated with a colon, or both\n  }, {\n    key: \"isValidLabelDef\",\n    value: function isValidLabelDef(tokens, originalLine) {\n      return tokens[0].endsWith(':') || !this.isWhitespace(originalLine[0]);\n    }\n\n    // validates that a label starts with a letter, _, $, or @, and is \n    // (optionally) followed by letters, digits, _, $, or @\n  }, {\n    key: \"isValidLabel\",\n    value: function isValidLabel(label) {\n      // Example pattern: starts with letter, _, $, @; followed by letters, digits, _, $, @\n      return /^[A-Za-z_$@][A-Za-z0-9_$@]*$/.test(label);\n    }\n\n    /*\r\n    * performPass currently handles multiple responsibilities:\r\n    * - Reading lines from the source file.\r\n    * - Tokenizing each line.\r\n    * - Handling labels, directives, and instructions.\r\n    * - Updating the location counter.\r\n    */\n  }, {\n    key: \"performPass\",\n    value: function performPass() {\n      // At the beginning of Pass 1\n      if (this.pass === 1) {\n        this.loadPoint = this.locCtr;\n      }\n      if (this.pass === 2) {\n        this.outputBuffer = [];\n      }\n      var _iterator4 = _createForOfIteratorHelper(this.sourceLines),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var line = _step4.value;\n          this.lineNum++;\n          var originalLine = line;\n          this.currentLine = originalLine; // Store current line for error reporting\n\n          // Create listing entry\n          var listingEntry = {\n            lineNum: this.lineNum,\n            locCtr: this.locCtr,\n            sourceLine: originalLine,\n            codeWords: [],\n            label: null,\n            mnemonic: null,\n            operands: [],\n            comment: ''\n          };\n          this.currentListingEntry = listingEntry;\n\n          // Extract the comment substring (everything after ';'), if any\n          var comment = '';\n          var semicolonIndex = line.indexOf(';');\n          if (semicolonIndex !== -1) {\n            // everything after ';'\n            comment = line.substring(semicolonIndex + 1).trim();\n          }\n          // Store the comment in the listing entry\n          listingEntry.comment = comment;\n\n          // Remove comments and trim whitespace\n          line = line.split(';')[0].trim();\n          if (line === '') {\n            // Empty line after removing comments\n            if (this.pass === 2) {\n              this.listing.push(listingEntry);\n            }\n            continue;\n          }\n\n          // Tokenize the line\n          var tokens = this.tokenizeLine(line);\n          if (tokens.length === 0) {\n            if (this.pass === 2) {\n              this.listing.push(listingEntry);\n            }\n            continue;\n          }\n          var label = null;\n          var mnemonic = null;\n          var operands = [];\n\n          // console.log(\"Tokens: \", tokens);\n\n          // Check if line starts with a label\n          if (tokens.length > 0 && this.isValidLabelDef(tokens, originalLine)) {\n            // Remove the trailing colon from the label if the colon exists\n            label = tokens.shift();\n            if (label.endsWith(':')) {\n              label = label.slice(0, -1);\n            }\n            if (!this.isValidLabel(label)) {\n              this.error(\"Bad label\"); // `Invalid label format: ${label}`\n            }\n            if (this.pass === 1) {\n              if (this.labels.has(label)) {\n                this.error(\"Duplicate label\"); // `Duplicate label: ${label}`\n              } else {\n                this.symbolTable[label] = this.locCtr;\n                this.labels.add(label);\n              }\n            }\n          }\n          if (tokens.length > 0) {\n            mnemonic = tokens.shift().toLowerCase();\n          } else {\n            if (this.pass === 2) {\n              this.listing.push(listingEntry);\n            }\n            continue; // No mnemonic, skip line\n          }\n          operands = tokens;\n\n          // Update listingEntry\n          listingEntry.label = label;\n          listingEntry.mnemonic = mnemonic;\n          listingEntry.operands = operands;\n\n          // Handle directives and instructions\n          if (mnemonic.startsWith('.')) {\n            // Directive\n            this.handleDirective(mnemonic, operands);\n          } else {\n            // Instruction\n            this.handleInstruction(mnemonic, operands);\n          }\n          if (this.locCtr > 65536) {\n            this.error('Program too big');\n            return;\n          }\n\n          // At the end of processing the line\n          if (this.pass === 2) {\n            this.listing.push(listingEntry);\n          }\n        }\n\n        // At the end of Pass 2\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      if (this.pass === 2) {\n        this.programSize = this.locCtr - this.loadPoint;\n\n        //// possible bug/strange lcc behavior:\n        //// remove a single empty line from the listing\n        //// if it is the last line\n        // console.log(\"last line of file is: '\", this.listing[this.listing.length - 1], \"'\");\n        if (this.listing[this.listing.length - 1].sourceLine.trim() === '') {\n          this.listing.pop();\n        }\n      }\n    }\n  }, {\n    key: \"parseHexFile\",\n    value: function parseHexFile() {\n      this.outputBuffer = [];\n      this.locCtr = 0;\n      this.loadPoint = 0;\n      for (var lineNum = 0; lineNum < this.sourceLines.length; lineNum++) {\n        this.lineNum++;\n        var line = this.sourceLines[lineNum];\n        this.currentLine = line; // For error messages\n\n        var listingEntry = {\n          lineNum: this.lineNum,\n          locCtr: this.locCtr,\n          sourceLine: line,\n          macWord: '',\n          comment: ''\n        };\n\n        // Extract the comment substring (everything after ';'), if any\n        var comment = '';\n        var semicolonIndex = line.indexOf(';');\n        if (semicolonIndex !== -1) {\n          // everything after ';'\n          comment = line.substring(semicolonIndex + 1).trim();\n        }\n        // Store the comment in the listing entry\n        listingEntry.comment = comment;\n\n        // Remove everything after semicolon\n        if (line.indexOf(';') !== -1) {\n          line = line.substring(0, line.indexOf(';'));\n        }\n        // Trim and remove all internal spaces\n        line = line.trim().replace(/\\s+/g, '');\n        if (line.length === 0) {\n          continue; // empty or comment-only line\n        }\n\n        // Now we should have a 16-bit hexadecimal string\n        // For example: \"4B1F\"\n        if (!/^[0-9A-Fa-f]+$/.test(line)) {\n          console.error(\"Error: line \".concat(lineNum + 1, \" in .hex file is not purely hexadecimal: \\\"\").concat(line, \"\\\"\"));\n          fatalExit(\"Error: line \".concat(lineNum + 1, \" in .hex file is not purely hexadecimal: \\\"\").concat(line, \"\\\"\"), 1);\n        }\n        if (line.length !== 4) {\n          console.error(\"Error: line \".concat(lineNum + 1, \" in .hex file does not have exactly 4 nibbles: \\\"\").concat(line, \"\\\"\"));\n          fatalExit(\"Error: line \".concat(lineNum + 1, \" in .hex file does not have exactly 4 nibbles: \\\"\").concat(line, \"\\\"\"), 1);\n        }\n\n        // Convert the binary string to a number\n        var wordValue = parseInt(line, 16);\n\n        // Push the parsed word into outputBuffer\n        this.outputBuffer.push(wordValue & 0xFFFF);\n        this.locCtr++;\n\n        // Store the machine word in the listing entry\n        listingEntry.macWord = wordValue;\n\n        // Store the listing entry\n        this.listing.push(listingEntry);\n      }\n\n      // Note: Reporting an empty hex file is custom LCC.js behavior in 12/2024\n      //       (this does not match current official LCC behavior)\n      if (this.locCtr === 0) {\n        console.error('Empty file');\n        fatalExit('Empty file', 0); // No instructions or data found in source file\n      }\n\n      // If you want a \"startAddress = 0\" by default, do that here\n      this.startAddress = 0; // or your choice\n      this.startLabel = null; // No .start directive in raw hex files\n    }\n  }, {\n    key: \"parseBinFile\",\n    value: function parseBinFile() {\n      this.outputBuffer = []; // Prepare output buffer\n      this.locCtr = 0;\n      this.loadPoint = 0; // TODO: fix this to not be hardcoded, because flags may dictate where in memory the program starts\n      for (var lineNum = 0; lineNum < this.sourceLines.length; lineNum++) {\n        this.lineNum++;\n        var line = this.sourceLines[lineNum];\n        this.currentLine = line; // For error messages\n\n        var listingEntry = {\n          lineNum: this.lineNum,\n          locCtr: this.locCtr,\n          sourceLine: line,\n          macWord: '',\n          comment: ''\n        };\n\n        // Extract the comment substring (everything after ';'), if any\n        var comment = '';\n        var semicolonIndex = line.indexOf(';');\n        if (semicolonIndex !== -1) {\n          // everything after ';'\n          comment = line.substring(semicolonIndex + 1).trim();\n        }\n        // Store the comment in the listing entry\n        listingEntry.comment = comment;\n\n        // Remove everything after semicolon\n        if (line.indexOf(';') !== -1) {\n          line = line.substring(0, line.indexOf(';'));\n        }\n        // Trim and remove all internal spaces\n        line = line.trim().replace(/\\s+/g, '');\n        if (line.length === 0) {\n          continue; // empty or comment-only line\n        }\n\n        // Now we should have a 16-bit binary string\n        // For example: \"0010000000000101\"\n        if (!/^[01]+$/.test(line)) {\n          console.error(\"Error: line \".concat(lineNum + 1, \" in .bin file is not purely binary: \\\"\").concat(line, \"\\\"\"));\n          fatalExit(\"Error: line \".concat(lineNum + 1, \" in .bin file is not purely binary: \\\"\").concat(line, \"\\\"\"), 1);\n        }\n        if (line.length !== 16) {\n          console.error(\"Error: line \".concat(lineNum + 1, \" in .bin file does not have exactly 16 bits: \\\"\").concat(line, \"\\\"\"));\n          fatalExit(\"Error: line \".concat(lineNum + 1, \" in .bin file does not have exactly 16 bits: \\\"\").concat(line, \"\\\"\"), 1);\n        }\n\n        // Convert the binary string to a number\n        var wordValue = parseInt(line, 2);\n\n        // Push the parsed word into outputBuffer\n        this.outputBuffer.push(wordValue & 0xFFFF);\n        this.locCtr++;\n\n        // Store the machine word in the listing entry\n        listingEntry.macWord = wordValue;\n\n        // Store the listing entry\n        this.listing.push(listingEntry);\n      }\n\n      // Note: The reporting of an empty bin file is custom LCC.js behavior in 12/2024\n      //       (it does not currently match official LCC behavior)\n      if (this.locCtr === 0) {\n        console.error('Empty file');\n        fatalExit('Empty file', 0); // No instructions or data found in source file\n      }\n\n      // If you want a \"startAddress = 0\" by default, do that here\n      this.startAddress = 0; // or your choice\n      this.startLabel = null; // No .start directive in raw bin files\n    }\n  }, {\n    key: \"tokenizeLine\",\n    value: function tokenizeLine(line) {\n      var tokens = [];\n      var currentToken = '';\n      var inString = false;\n      var stringDelimiter = '';\n      var escape = false; // Flag to indicate escape character\n\n      for (var i = 0; i < line.length; i++) {\n        var _char = line[i];\n        if (!inString) {\n          if (_char === '\"' || _char === \"'\") {\n            inString = true;\n            stringDelimiter = _char;\n            currentToken += _char;\n          } else if (this.isWhitespace(_char)) {\n            if (currentToken !== '') {\n              tokens.push(currentToken);\n              currentToken = '';\n            }\n          } else if (_char === ',' && !inString) {\n            if (currentToken !== '') {\n              tokens.push(currentToken);\n              currentToken = '';\n            }\n          } else if (_char === ':') {\n            if (currentToken !== '') {\n              currentToken += _char;\n              tokens.push(currentToken);\n              currentToken = '';\n            }\n            // Ignore colon\n          } else {\n            currentToken += _char;\n          }\n        } else {\n          currentToken += _char;\n          if (escape) {\n            escape = false; // Reset escape flag\n            continue;\n          }\n          if (_char === '\\\\') {\n            escape = true; // Next character is escaped\n          } else if (_char === stringDelimiter) {\n            inString = false;\n            tokens.push(currentToken);\n            currentToken = '';\n          }\n        }\n      }\n      if (currentToken !== '') {\n        tokens.push(currentToken);\n      }\n      return tokens;\n    }\n  }, {\n    key: \"isWhitespace\",\n    value: function isWhitespace(_char2) {\n      return /\\s/.test(_char2);\n    }\n  }, {\n    key: \"isStringLiteral\",\n    value: function isStringLiteral(str) {\n      return /^\"(.*)\"$/.test(str) || /^'(.*)'$/.test(str);\n    }\n  }, {\n    key: \"parseString\",\n    value: function parseString(str) {\n      var result = '';\n      for (var i = 0; i < str.length; i++) {\n        if (str[i] === '\\\\') {\n          i++; // Move to the next character to check the escape sequence\n          if (i >= str.length) {\n            this.error(\"Missing terminating quote\");\n            fatalExit(\"Missing terminating quote\", 1);\n          }\n          switch (str[i]) {\n            case 'n':\n              result += '\\n';\n              break;\n            case 't':\n              result += '\\t';\n              break;\n            case '\\\\':\n              result += '\\\\';\n              break;\n            case '\"':\n              result += '\"';\n              break;\n            case 'r':\n              result += '\\r';\n              break;\n            // Add more escape sequences as needed\n            default:\n              this.error(\"Unknown escape sequence: \\\\\".concat(str[i]));\n              return null;\n          }\n        } else {\n          result += str[i];\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"handleDirective\",\n    value: function handleDirective(mnemonic, operands) {\n      mnemonic = mnemonic.toLowerCase();\n      switch (mnemonic) {\n        case '.start':\n          if (operands[0] === null || operands[0] === undefined) {\n            this.error(\"Missing operand\");\n            fatalExit(\"Missing operand\", 1);\n          }\n          if (!this.isValidLabel(operands[0])) {\n            this.error(\"Bad operand--not a valid label\");\n            fatalExit(\"Bad operand--not a valid label\", 1);\n          }\n          this.startLabel = operands[0];\n          // Note: startAddress will be resolved after Pass 2 when all symbols are known\n          break;\n        case '.org':\n          this.error(\"This directive hasn't yet been implemented\");\n          fatalExit(\"This directive hasn't yet been implemented\", 1);\n          break;\n        case '.globl':\n        case '.global':\n          if (operands[0] === null || operands[0] === undefined) {\n            this.error(\"Missing operand\");\n            fatalExit(\"Missing operand\", 1);\n          }\n          if (!this.isValidLabel(operands[0])) {\n            this.error(\"Bad operand--not a valid label\");\n            fatalExit(\"Bad operand--not a valid label\", 1);\n          }\n          this.isObjectModule = true; // Set flag to produce .o file\n          var globalLabel = operands[0];\n          if (this.pass === 1) {\n            // Record the address of the global label\n            if (!this.symbolTable.hasOwnProperty(globalLabel)) {\n              this.symbolTable[globalLabel] = this.locCtr;\n            }\n            this.globalLabels.add(globalLabel);\n          }\n          break;\n        case '.extern':\n          if (operands[0] === null || operands[0] === undefined) {\n            this.error(\"Missing operand\");\n            fatalExit(\"Missing operand\", 1);\n          }\n          if (!this.isValidLabel(operands[0])) {\n            this.error(\"Bad operand--not a valid label\");\n            fatalExit(\"Bad operand--not a valid label\", 1);\n          }\n          this.isObjectModule = true; // Set flag to produce .o file\n          var externLabel = operands[0];\n          this.externLabels.add(externLabel);\n          break;\n        case '.blkw':\n        case '.space':\n        case '.zero':\n          if (operands[0] === null || operands[0] === undefined) {\n            this.error(\"Missing operand\");\n            fatalExit(\"Missing operand\", 1);\n          }\n          var num = parseInt(operands[0], 10);\n          if (isNaN(num)) {\n            this.error(\"Bad number\");\n            fatalExit(\"Bad number\", 1);\n          }\n\n          // Note: in the original LCC (as of 12/2024), the .zero directive arguments\n          // are not checked for negativity, so this currently is a custom LCC.js behavior\n          if (num < 1 || num > 65536 - this.locCtr) {\n            this.error(\"Bad number\");\n            fatalExit(\"Bad number\", 1);\n          }\n          if (this.pass === 2) {\n            for (var i = 0; i < num; i++) {\n              this.writeMachineWord(0);\n            }\n          }\n          this.locCtr += num;\n          break;\n        case '.fill':\n        case '.word':\n          if (operands[0] === null || operands[0] === undefined) {\n            this.error(\"Missing operand\");\n            fatalExit(\"Missing operand\", 1);\n          }\n          if (this.isOperator(operands[0]) && (operands[1] === null || operands[1] === undefined)) {\n            this.error(\"Missing operand\");\n            fatalExit(\"Missing operand\", 1);\n          }\n\n          // if (operands.length !== 1 && operands.length !== 3) {\n          //// TODO: inspect to make sure that .word can handle .word x, .word x+1, and .word x + 1\n          //// TODO: inspect to make sure that .word can handle .word x+ 1 and .word x +1\n          //// TODO: inspect to make sure that .word behaves as expected with .word x + 1 + 1\n          //// TODO: inspect to make sure that .word behaves as expected with .word <NOTHING>\n          //// TODO: inspect to make sure that .word behaves as expected with .word + or .word -\n          // this.error(`Invalid operand count for ${mnemonic}`);\n          // return;\n          // }\n\n          if (this.pass === 2) {\n            var label = operands[0];\n\n            // if not a number castable literal, then operands[0] is a label\n            if (!this.isNumLiteral(operands[0]) && operands[1] && operands[2]) {\n              // if operands[2] is not a literal value, then it isn't a valid offset\n              if (!this.isNumLiteral(operands[2])) {\n                this.error(\"Bad number\"); // : ${operands[2]}\n                fatalExit('Bad number', 1);\n              }\n              label = operands[0] + operands[1] + operands[2];\n            }\n            if (operands[1] && this.isOperator(operands[1]) && (operands[2] === null || operands[2] === undefined)) {\n              this.error('Missing number');\n              fatalExit('Missing number', 1);\n            }\n            var value = this.evaluateOperand(label, 'V'); // Pass 'V' as usageType\n            if (value === null) {\n              this.error(\"Bad number\"); // : ${value}\n              fatalExit('Bad number', 1);\n            }\n            ;\n\n            // see if operand is label +/- offset\n            var parsed = this.parseLabelWithOffset(label);\n            if (parsed && this.symbolTable.hasOwnProperty(parsed.label)) {\n              // It's a local label with offset, so record an A-entry\n              this.handleAdjustmentEntry(this.locCtr);\n            }\n            if (parsed && (parsed.offset > 65535 || parsed.offset < -32768)) {\n              this.error(\"Bad number\"); // 'Data does not fit in 16 bits' // : ${parsed.offset}\n              fatalExit('Bad number', 1); // 'Data does not fit in 16 bits'\n            }\n            this.writeMachineWord(value & 0xFFFF);\n          }\n          this.locCtr += 1;\n          break;\n        case '.stringz':\n        case '.asciz':\n        case '.string':\n          if (operands[0] === null || operands[0] === undefined) {\n            this.error(\"Missing operand\");\n            fatalExit(\"Missing operand\", 1);\n          }\n          var strOperand = operands[0];\n          if (strOperand && strOperand.length > 0) {\n            if (strOperand[0] !== '\"') {\n              this.error(\"String constant missing leading quote\");\n              fatalExit(\"String constant missing leading quote\", 1);\n            }\n          }\n          if (!this.isStringLiteral(strOperand)) {\n            this.error(\"Missing terminating quote\");\n            fatalExit(\"Missing terminating quote\", 1);\n          }\n          // Extract the string without quotes\n          var strContent = strOperand.slice(1, -1);\n          strContent = this.parseString(strContent);\n          if (this.pass === 1) {\n            // Update location counter: length of string + 1 for null terminator\n            this.locCtr += strContent.length + 1;\n          } else if (this.pass === 2) {\n            // Write each character's ASCII code to output\n            for (var _i2 = 0; _i2 < strContent.length; _i2++) {\n              var asciiValue = strContent.charCodeAt(_i2);\n              this.writeMachineWord(asciiValue);\n              this.locCtr += 1; // Increment locCtr after writing each word\n            }\n            // Write null terminator\n            this.writeMachineWord(0);\n            this.locCtr += 1; // Increment locCtr for null terminator\n          }\n          break;\n        default:\n          this.error(\"Invalid operation\"); // Invalid directive: ${mnemonic}\n          fatalExit(\"Invalid operation\", 1);\n          break;\n      }\n    }\n  }, {\n    key: \"handleInstruction\",\n    value: function handleInstruction(mnemonic, operands) {\n      if (this.pass === 1) {\n        this.locCtr += 1;\n        return;\n      }\n      var machineWord = null;\n      mnemonic = mnemonic.toLowerCase();\n      switch (mnemonic) {\n        case 'br':\n        case 'bral':\n        case 'brz':\n        case 'bre':\n        case 'brnz':\n        case 'brne':\n        case 'brn':\n        case 'brp':\n        case 'brlt':\n        case 'brgt':\n        case 'brc':\n          machineWord = this.assembleBR(mnemonic, operands);\n          break;\n        case 'add':\n          machineWord = this.assembleADD(operands);\n          break;\n        case 'sub':\n          machineWord = this.assembleSUB(operands);\n          break;\n        case 'cmp':\n          machineWord = this.assembleCMP(operands);\n          break;\n        case 'mov':\n        case 'mvi':\n        case 'mvr':\n          machineWord = this.assembleMOV(mnemonic, operands);\n          break;\n        case 'push':\n          machineWord = this.assemblePUSH(operands);\n          break;\n        case 'pop':\n          machineWord = this.assemblePOP(operands);\n          break;\n        case 'srl':\n          machineWord = this.assembleSRL(operands);\n          break;\n        case 'sra':\n          machineWord = this.assembleSRA(operands);\n          break;\n        case 'sll':\n          machineWord = this.assembleSLL(operands);\n          break;\n        case 'rol':\n          machineWord = this.assembleROL(operands);\n          break;\n        case 'ror':\n          machineWord = this.assembleROR(operands);\n          break;\n        case 'mul':\n          machineWord = this.assembleMUL(operands);\n          break;\n        case 'div':\n          machineWord = this.assembleDIV(operands);\n          break;\n        case 'rem':\n          machineWord = this.assembleREM(operands);\n          break;\n        case 'or':\n          machineWord = this.assembleOR(operands);\n          break;\n        case 'xor':\n          machineWord = this.assembleXOR(operands);\n          break;\n        // mvr case is handled in the mov function\n        case 'sext':\n          machineWord = this.assembleSEXT(operands);\n          break;\n        case 'ld':\n          machineWord = this.assembleLD(operands);\n          break;\n        case 'st':\n          machineWord = this.assembleST(operands);\n          break;\n        case 'call':\n        case 'jsr':\n        case 'bl':\n          machineWord = this.assembleBL(operands);\n          break;\n        case 'jsrr':\n        case 'blr':\n          machineWord = this.assembleBLR(operands);\n          break;\n        case 'and':\n          machineWord = this.assembleAND(operands);\n          break;\n        case 'ldr':\n          machineWord = this.assembleLDR(operands);\n          break;\n        case 'str':\n          machineWord = this.assembleSTR(operands);\n          break;\n        case 'jmp':\n          machineWord = this.assembleJMP(operands);\n          break;\n        case 'ret':\n          machineWord = this.assembleRET(operands);\n          break;\n        case 'not':\n          machineWord = this.assembleNOT(operands);\n          break;\n        case 'lea':\n          machineWord = this.assembleLea(operands);\n          break;\n        case 'cea':\n          machineWord = this.assembleCEA(operands);\n          break;\n        case 'halt':\n          machineWord = 0xF000;\n          break;\n        case 'nl':\n          machineWord = 0xF001;\n          break;\n        case 'dout':\n          machineWord = this.assembleTrap(operands, 0x0002);\n          break;\n        case 'udout':\n          machineWord = this.assembleTrap(operands, 0x0003);\n          break;\n        case 'hout':\n          machineWord = this.assembleTrap(operands, 0x0004);\n          break;\n        case 'aout':\n          machineWord = this.assembleTrap(operands, 0x0005);\n          break;\n        case 'sout':\n          machineWord = this.assembleTrap(operands, 0x0006); // Trap vector for sout is 6\n          break;\n        case 'din':\n          machineWord = this.assembleTrap(operands, 0x0007); // Trap vector for din is 7\n          break;\n        case 'hin':\n          machineWord = this.assembleTrap(operands, 0x0008); // Trap vector for hin is 8\n          break;\n        case 'ain':\n          machineWord = this.assembleTrap(operands, 0x0009); // Trap vector for ain is 9\n          break;\n        case 'sin':\n          machineWord = this.assembleTrap(operands, 0x000A); // Trap vector for sin is 10\n          break;\n        case 'm':\n          machineWord = this.assembleTrap(operands, 0x000B); // Trap vector for m is 11\n          break;\n        case 'r':\n          machineWord = this.assembleTrap(operands, 0x000C); // Trap vector for r is 12\n          break;\n        case 's':\n          machineWord = this.assembleTrap(operands, 0x000D); // Trap vector for s is 13\n          break;\n        case 'bp':\n          machineWord = this.assembleTrap(operands, 0x000E); // Trap vector for bp is 14\n          break;\n        default:\n          this.error(\"Invalid operation\"); // this.error(`Invalid mnemonic or directive: ${mnemonic}`);\n          return;\n      }\n      if (machineWord !== null) {\n        this.writeMachineWord(machineWord);\n        this.locCtr += 1;\n      }\n    }\n  }, {\n    key: \"writeMachineWord\",\n    value: function writeMachineWord(word) {\n      if (this.pass === 2) {\n        this.outputBuffer.push(word & 0xFFFF); // Ensure 16-bit word\n        if (this.currentListingEntry) {\n          this.currentListingEntry.codeWords.push(word & 0xFFFF);\n        }\n      }\n    }\n  }, {\n    key: \"assembleCMP\",\n    value: function assembleCMP(operands) {\n      var sr1 = this.getRegister(operands[0]);\n      if (sr1 === null) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      ;\n      var sr2orImm5 = operands[1];\n      if (sr2orImm5 === null) return null;\n      var macword = 0x8000;\n      if (!this.isRegister(sr2orImm5)) {\n        // compare with immediate\n        var imm5 = this.evaluateImmediate(sr2orImm5, -16, 15, \"imm5\"); //// TODO: test bounds, see if input is naive or not\n        macword = macword | sr1 << 6 | imm5 & 0x1F | 0x0020;\n      } else {\n        // compare with register\n        var sr2 = this.getRegister(sr2orImm5);\n        if (sr2 === null) return null;\n        macword = macword | sr1 << 6 | sr2 & 0x3;\n      }\n      return macword;\n    }\n  }, {\n    key: \"assembleBR\",\n    value: function assembleBR(mnemonic, operands) {\n      var codes = {\n        'brz': 0,\n        'bre': 0,\n        'brnz': 1,\n        'brne': 1,\n        'brn': 2,\n        'brp': 3,\n        'brlt': 4,\n        'brgt': 5,\n        'brc': 6,\n        'brb': 6,\n        'br': 7,\n        'bral': 7\n      };\n      var macword = codes[mnemonic.toLowerCase()] << 9 & 0xffff;\n      var label = operands[0];\n      if (label === null || label === undefined) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      if (!this.isNumLiteral(operands[0]) && operands[1] && operands[2]) {\n        // if operands[2] is not a literal value, then it isn't a valid offset\n        if (!this.isNumLiteral(operands[2])) {\n          this.error('Bad number');\n          fatalExit('Bad number', 1);\n        }\n        label = operands[0] + operands[1] + operands[2];\n      }\n      if (operands[1] && this.isOperator(operands[1]) && (operands[2] === null || operands[2] === undefined)) {\n        this.error('Missing number');\n        fatalExit('Missing number', 1);\n      }\n      var address = this.evaluateOperand(label, 'e');\n      if (address === null) {\n        this.error('Bad label'); // TODO: verify this is correct via cross testing w/ LCC\n        fatalExit('Bad label', 1);\n      }\n      ;\n      var pcoffset9 = address - this.locCtr - 1;\n      if (pcoffset9 < -256 || pcoffset9 > 255) {\n        this.error('pcoffset9 out of range'); // for branch instruction\n        return null;\n      }\n      macword |= pcoffset9 & 0x01FF;\n      return macword;\n    }\n  }, {\n    key: \"assembleADD\",\n    value: function assembleADD(operands) {\n      var dr = this.getRegister(operands[0]);\n      var sr1 = this.getRegister(operands[1]);\n      if (dr === null || sr1 === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var sr2orImm5 = operands[2];\n      if (sr2orImm5 === null || sr2orImm5 === undefined) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      var macword = 0x1000 | dr << 9 | sr1 << 6;\n      if (this.isRegister(sr2orImm5)) {\n        var sr2 = this.getRegister(sr2orImm5);\n        macword |= sr2;\n      } else {\n        var imm5 = this.evaluateImmediate(sr2orImm5, -16, 15, \"imm5\");\n        if (imm5 === null) {\n          this.error('Bad number');\n          fatalExit('Bad number', 1);\n        }\n        ;\n        macword |= 0x0020 | imm5 & 0x1F;\n      }\n      return macword;\n    }\n  }, {\n    key: \"assembleCEA\",\n    value: function assembleCEA(operands) {\n      var dr = operands[0];\n      var imm5op = operands[1];\n      return this.assembleADD([dr, 'fp', imm5op]);\n    }\n  }, {\n    key: \"assembleSUB\",\n    value: function assembleSUB(operands) {\n      var dr = this.getRegister(operands[0]);\n      var sr1 = this.getRegister(operands[1]);\n      if (dr === null || sr1 === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      var sr2orImm5 = operands[2];\n      var macword = 0xB000 | dr << 9 | sr1 << 6;\n      if (this.isRegister(sr2orImm5)) {\n        var sr2 = this.getRegister(sr2orImm5);\n        macword |= sr2;\n      } else {\n        var imm5 = this.evaluateImmediate(sr2orImm5, -16, 15, 'imm5');\n        if (imm5 === null) {\n          this.error('Bad number');\n          fatalExit('Bad number', 1);\n        }\n        ;\n        macword |= 0x0020 | imm5 & 0x1F;\n      }\n      return macword;\n    }\n  }, {\n    key: \"assemblePUSH\",\n    value: function assemblePUSH(operands) {\n      var sr = this.getRegister(operands[0]);\n      if (sr === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var macword = 0xA000 | sr << 9;\n      return macword;\n    }\n  }, {\n    key: \"assemblePOP\",\n    value: function assemblePOP(operands) {\n      var dr = this.getRegister(operands[0]);\n      if (dr === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var macword = 0xA000 | dr << 9 | 0x0001;\n      return macword;\n    }\n  }, {\n    key: \"assembleDIV\",\n    value: function assembleDIV(operands) {\n      var dr = this.getRegister(operands[0]);\n      var sr1 = this.getRegister(operands[1]);\n      if (dr === null || sr1 === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var macword = 0xa008 | dr << 9 | sr1 << 6;\n      return macword;\n    }\n  }, {\n    key: \"assembleROL\",\n    value: function assembleROL(operands) {\n      var sr = this.getRegister(operands[0]);\n      if (sr === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var ct = null;\n      if (operands[1]) ct = this.evaluateImmediateNaive(operands[1]);\n      if (ct === null) ct = 1;\n      var macword = 0xA000 | sr << 9 | ct << 5 | 0x0005;\n      return macword;\n    }\n  }, {\n    key: \"assembleMUL\",\n    value: function assembleMUL(operands) {\n      var dr = this.getRegister(operands[0]);\n      var sr1 = this.getRegister(operands[1]);\n      if (dr === null || sr1 === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var macword = 0xA000 | dr << 9 | sr1 << 6 | 0x0007;\n      return macword;\n    }\n  }, {\n    key: \"assembleREM\",\n    value: function assembleREM(operands) {\n      var dr = this.getRegister(operands[0]);\n      var sr1 = this.getRegister(operands[1]);\n      if (dr === null || sr1 === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      var macword = 0xA000 | dr << 9 | sr1 << 6 | 0x0009;\n      return macword;\n    }\n  }, {\n    key: \"assembleOR\",\n    value: function assembleOR(operands) {\n      var dr = this.getRegister(operands[0]);\n      var sr1 = this.getRegister(operands[1]);\n      if (dr === null || sr1 === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      var macword = 0xA000 | dr << 9 | sr1 << 6 | 0x000A;\n      return macword;\n    }\n  }, {\n    key: \"assembleXOR\",\n    value: function assembleXOR(operands) {\n      var dr = this.getRegister(operands[0]);\n      var sr1 = this.getRegister(operands[1]);\n      if (dr === null || sr1 === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      var macword = 0xA000 | dr << 9 | sr1 << 6 | 0x000B;\n      return macword;\n    }\n  }, {\n    key: \"assembleSEXT\",\n    value: function assembleSEXT(operands) {\n      var dr = this.getRegister(operands[0]);\n      var sr1 = this.getRegister(operands[1]);\n      if (dr === null || sr1 === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var macword = 0xA000 | dr << 9 | sr1 << 6 | 0x000D;\n      return macword;\n    }\n  }, {\n    key: \"assembleROR\",\n    value: function assembleROR(operands) {\n      var sr = this.getRegister(operands[0]);\n      if (sr === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var ct = null;\n      if (operands[1]) ct = this.evaluateImmediateNaive(operands[1]);\n      if (ct === null) ct = 1;\n      var macword = 0xA000 | sr << 9 | ct << 5 | 0x0006;\n      return macword;\n    }\n  }, {\n    key: \"assembleSRL\",\n    value: function assembleSRL(operands) {\n      var sr = this.getRegister(operands[0]);\n      if (sr === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var ct = null;\n      if (operands[1]) ct = this.evaluateImmediateNaive(operands[1]);\n      if (ct === null) ct = 1;\n      var macword = 0xA000 | sr << 9 | ct << 5 | 0x0002;\n      return macword;\n    }\n  }, {\n    key: \"assembleSRA\",\n    value: function assembleSRA(operands) {\n      var sr = this.getRegister(operands[0]);\n      if (sr === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var ct = null;\n      if (operands[1]) ct = this.evaluateImmediate(operands[1], 0, 15); //// TODO: test bounds, see if input is naive or not\n      if (ct === null) ct = 1;\n      var macword = 0xA000 | sr << 9 | ct << 5 | 0x0003;\n      return macword;\n    }\n  }, {\n    key: \"assembleSLL\",\n    value: function assembleSLL(operands) {\n      var sr = this.getRegister(operands[0]);\n      if (sr === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var ct = null;\n      if (operands[1]) ct = this.evaluateImmediateNaive(operands[1]);\n      if (ct === null) ct = 1;\n      var macword = 0xA000 | sr << 9 | ct << 5 | 0x0004;\n      return macword;\n    }\n  }, {\n    key: \"assembleAND\",\n    value: function assembleAND(operands) {\n      var dr = this.getRegister(operands[0]);\n      var sr1 = this.getRegister(operands[1]);\n      if (dr === null || sr1 === null) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      ;\n      var sr2orImm5 = operands[2];\n      var macword = 0x5000 | dr << 9 | sr1 << 6;\n      if (this.isRegister(sr2orImm5)) {\n        var sr2 = this.getRegister(sr2orImm5);\n        macword |= sr2;\n      } else {\n        var imm5 = this.evaluateImmediate(sr2orImm5, -16, 15, 'imm5'); //// TODO: test bounds, see if input is naive or not\n        if (imm5 === null || imm5 === undefined) {\n          this.error('Bad number');\n          fatalExit('Bad number', 1);\n        }\n        ;\n        macword |= 0x0020 | imm5 & 0x1F;\n      }\n      return macword;\n    }\n  }, {\n    key: \"assembleLD\",\n    value: function assembleLD(operands) {\n      var dr = this.getRegister(operands[0]);\n      if (dr === null) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      ;\n      var label = operands[1];\n      if (label === null || label === undefined) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      if (!this.isNumLiteral(operands[1]) && operands[2] && operands[3]) {\n        // if operands[2] is not a literal value, then it isn't a valid offset\n        if (!this.isNumLiteral(operands[3])) {\n          this.error('Bad number');\n          fatalExit('Bad number', 1);\n        }\n        label = operands[1] + operands[2] + operands[3];\n      }\n      if (operands[2] && this.isOperator(operands[2]) && (operands[3] === null || operands[3] === undefined)) {\n        this.error('Missing number');\n        fatalExit('Missing number', 1);\n      }\n      var address = this.evaluateOperand(label, 'e'); // Pass 'e' as usageType\n      if (address === null) {\n        this.error('Bad label');\n        fatalExit('Bad label', 1);\n      }\n      ;\n      var isExternal = this.externLabels.has(label);\n      var pcoffset9;\n      if (isExternal) {\n        pcoffset9 = 0; // Placeholder offset\n        // Do NOT add an 'A' entry here\n      } else {\n        pcoffset9 = address - this.locCtr - 1;\n        if (pcoffset9 < -256 || pcoffset9 > 255) {\n          this.error('pcoffset9 out of range for ld');\n          return null;\n        }\n      }\n      var macword = 0x2000 | dr << 9 | pcoffset9 & 0x1FF;\n      return macword;\n    }\n  }, {\n    key: \"assembleST\",\n    value: function assembleST(operands) {\n      var sr = this.getRegister(operands[0]);\n      if (sr === null) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      ;\n      var label = operands[1];\n      if (label === null || label === undefined) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      if (!this.isNumLiteral(operands[1]) && operands[2] && operands[3]) {\n        // if operands[2] is not a literal value, then it isn't a valid offset\n        if (!this.isNumLiteral(operands[3])) {\n          this.error('Bad number');\n          fatalExit('Bad number', 1);\n        }\n        label = operands[1] + operands[2] + operands[3];\n      }\n      if (operands[2] && this.isOperator(operands[2]) && (operands[3] === null || operands[3] === undefined)) {\n        this.error('Missing number');\n        fatalExit('Missing number', 1);\n      }\n      var address = this.evaluateOperand(label, 'e'); // Pass 'e' as usageType\n      if (address === null) {\n        this.error('Bad label');\n        fatalExit('Bad label', 1);\n      }\n      ;\n      var pcoffset9 = address - this.locCtr - 1;\n      if (pcoffset9 < -256 || pcoffset9 > 255) {\n        this.error('pcoffset9 out of range for st');\n        return null;\n      }\n      var macword = 0x3000 | sr << 9 | pcoffset9 & 0x1FF;\n      return macword;\n    }\n  }, {\n    key: \"assembleLea\",\n    value: function assembleLea(operands) {\n      var dr = this.getRegister(operands[0]);\n      if (dr === null) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      ;\n      var label = operands[1];\n      if (label === null || label === undefined) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      if (!this.isNumLiteral(operands[1]) && operands[2] && operands[3]) {\n        // if operands[2] is not a literal value, then it isn't a valid offset\n        if (!this.isNumLiteral(operands[3])) {\n          this.error('Bad number');\n          fatalExit('Bad number', 1);\n        }\n        label = operands[1] + operands[2] + operands[3];\n      }\n      if (operands[2] && this.isOperator(operands[2]) && (operands[3] === null || operands[3] === undefined)) {\n        this.error('Missing number');\n        fatalExit('Missing number', 1);\n      }\n      var address = this.evaluateOperand(label, 'e');\n      if (address === null) {\n        this.error('Bad label');\n        fatalExit('Bad label', 1);\n      }\n      ;\n      var pcoffset9 = address - this.locCtr - 1;\n      if (pcoffset9 < -256 || pcoffset9 > 255) {\n        this.error('pcoffset9 out of range');\n        fatalExit('pcoffset9 out of range', 1);\n      }\n      var macword = 0xE000 | dr << 9 | pcoffset9 & 0x1FF;\n      return macword;\n    }\n  }, {\n    key: \"assembleBL\",\n    value: function assembleBL(operands) {\n      var label = operands[0];\n      if (!this.isValidLabel(label)) {\n        this.error(\"Bad label\"); // : ${label}\n        fatalExit(\"Bad label\", 1); // : ${label}\n      }\n      var address = this.evaluateOperand(label, 'E'); // Pass 'E' as usageType\n      if (address === null) {\n        this.error('Bad label');\n        fatalExit('Bad label', 1);\n      }\n      var isExternal = this.externLabels.has(label);\n      var pcoffset11;\n      if (isExternal) {\n        pcoffset11 = 0; // Placeholder offset\n        // Do NOT add an 'A' entry here\n      } else {\n        pcoffset11 = address - this.locCtr - 1;\n        if (pcoffset11 < -1024 || pcoffset11 > 1023) {\n          this.error('pcoffset11 out of range'); // TODO: test this in integration tests\n          return null;\n        }\n      }\n      var macword = 0x4800 | pcoffset11 & 0x07FF;\n      return macword;\n    }\n  }, {\n    key: \"assembleBLR\",\n    value: function assembleBLR(operands) {\n      var baser = this.getRegister(operands[0]);\n      if (baser === null) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      ;\n      var offset6 = 0;\n      if (operands[1]) {\n        offset6 = this.evaluateImmediate(operands[1], -32, 31, \"offset6\"); //// TODO: test bounds, see if input is naive or not\n      }\n      var macword = 0x4000 | baser << 6 | offset6 & 0x3F;\n      return macword;\n    }\n  }, {\n    key: \"assembleLDR\",\n    value: function assembleLDR(operands) {\n      var dr = this.getRegister(operands[0]);\n      var baser = this.getRegister(operands[1]);\n      if (dr === null || baser === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var offset6 = this.evaluateImmediate(operands[2], -32, 31, 'offset6'); //// TODO: test bounds, see if input is naive or not\n      if (offset6 === null) return null;\n      var macword = 0x6000 | dr << 9 | baser << 6 | offset6 & 0x3F;\n      return macword;\n    }\n  }, {\n    key: \"assembleSTR\",\n    value: function assembleSTR(operands) {\n      var sr = this.getRegister(operands[0]);\n      var baser = this.getRegister(operands[1]);\n      if (sr === null || baser === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var offset6 = this.evaluateImmediate(operands[2], -32, 31, 'offset6'); //// TODO: test bounds, see if input is naive or not\n      if (offset6 === null) return null;\n      var macword = 0x7000 | sr << 9 | baser << 6 | offset6 & 0x3F;\n      return macword;\n    }\n  }, {\n    key: \"assembleJMP\",\n    value: function assembleJMP(operands) {\n      var baser = this.getRegister(operands[0]);\n      if (baser === null) {\n        // Note: as of 12/2024, the official LCC behavior here is to segfault\n        // so, this is currently \"custom\" LCC.js behavior\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var offset6 = 0;\n      if (operands[1]) {\n        offset6 = this.evaluateImmediate(operands[1], -32, 31, \"offset6\"); //// TODO: test bounds, see if input is naive or not\n      }\n      var macword = 0xC000 | baser << 6 | offset6 & 0x3F;\n      return macword;\n    }\n  }, {\n    key: \"assembleRET\",\n    value: function assembleRET(operands) {\n      //// TODO: make sure that ret+3 is valid\n      //// TODO: make sure that ret+ 3 is valid\n      //// TODO; make sure that ret +3 is valid\n      //// TODO: make sure that ret + 3 is valid\n      var baser = 7; // LR register\n      var offset6 = 0;\n      if (operands[0]) {\n        offset6 = this.evaluateImmediate(operands[0], -32, 31, \"offset6\"); //// TODO: test bounds, see if input is naive or not\n      }\n      var macword = 0xC000 | baser << 6 | offset6 & 0x3F;\n      return macword;\n    }\n  }, {\n    key: \"assembleNOT\",\n    value: function assembleNOT(operands) {\n      var dr = this.getRegister(operands[0]);\n      var sr1 = this.getRegister(operands[1]);\n      if (dr === null || sr1 === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var macword = 0x9000 | dr << 9 | sr1 << 6;\n      return macword;\n    }\n  }, {\n    key: \"assembleMOV\",\n    value: function assembleMOV(mnemonic, operands) {\n      var dr = this.getRegister(operands[0]);\n      if (dr === null) {\n        this.error('Missing register');\n        fatalExit(\"Missing register\", 1);\n      }\n      ;\n      if (mnemonic === 'mov') {\n        // Determine if operands[1] is a register or immediate\n        if (this.isRegister(operands[1])) {\n          // Translate to 'mvr dr, sr'\n          var sr = this.getRegister(operands[1]);\n          // mvr: opcode 0xA000, eopcode 12\n          var macword = 0xA000 | dr << 9 | sr << 6 | 0x000C;\n          return macword;\n        } else {\n          //// TODO: test bounds, see if input is naive or not\n          // Translate to 'mvi dr, imm9'\n          var imm9 = this.evaluateImmediateNaive(operands[1]); // this.evaluateImmediate(operands[1], -256, 255);\n          if (imm9 === null) {\n            this.error('Missing number');\n            fatalExit(\"Missing number\", 1);\n          }\n          ;\n          // mvi: opcode 0xD000\n          var _macword = 0xD000 | dr << 9 | imm9 & 0x1FF;\n          return _macword;\n        }\n      } else if (mnemonic === 'mvi') {\n        //// TODO: test bounds, see if input is naive or not\n        // mvi dr, imm9\n        var _imm = this.evaluateImmediate(operands[1], -256, 255, \"mvi immediate\"); // this.evaluateImmediate(operands[1], -256, 255);\n        if (_imm === null) {\n          this.error('Missing number');\n          fatalExit(\"Missing number\", 1);\n        }\n        ;\n        var _macword2 = 0xD000 | dr << 9 | _imm & 0x1FF;\n        return _macword2;\n      } else if (mnemonic === 'mvr') {\n        // mvr dr, sr1\n        var sr1 = this.getRegister(operands[1]);\n        if (sr1 === null) {\n          this.error('Missing register');\n          fatalExit(\"Missing register\", 1);\n        }\n        ;\n        // Ensure eopcode 12 is set\n        var _macword3 = 0xA000 | dr << 9 | sr1 << 6 | 0x000C;\n        return _macword3;\n      } else {\n        this.error(\"Invalid mnemonic: \".concat(mnemonic));\n        return null;\n      }\n    }\n  }, {\n    key: \"assembleTrap\",\n    value: function assembleTrap(operands, trapVector) {\n      var sr = 0; // Default to r0\n      if (operands[0]) {\n        sr = this.getRegister(operands[0]);\n        if (sr === null) {\n          this.error('Bad register');\n          fatalExit(\"Bad register\", 1);\n        }\n        ;\n      }\n      var macword = 0xF000 | sr << 9 | trapVector & 0xFF;\n      return macword;\n    }\n  }, {\n    key: \"getRegister\",\n    value: function getRegister(regStr) {\n      if (regStr === null || regStr === undefined) {\n        return null;\n      }\n      if (!this.isRegister(regStr)) {\n        this.error('Bad register'); // this.error(`Invalid register: ${regStr}`);\n        fatalExit(\"Bad register\", 1);\n      }\n      if (regStr === \"fp\") {\n        regStr = \"r5\";\n      } else if (regStr === \"sp\") {\n        regStr = \"r6\";\n      } else if (regStr === \"lr\") {\n        regStr = \"r7\";\n      }\n      return parseInt(regStr.substr(1), 10);\n    }\n  }, {\n    key: \"isCharLiteral\",\n    value: function isCharLiteral(str) {\n      var match = /^'(?:\\\\.|[^\\\\])'$/.test(str);\n      return match;\n    }\n  }, {\n    key: \"parseCharLiteral\",\n    value: function parseCharLiteral(str) {\n      // Remove the single quotes\n      var charContent = str.slice(1, -1);\n      if (charContent.length === 1) {\n        // Simple character\n        return charContent.charCodeAt(0);\n      } else if (charContent.startsWith('\\\\')) {\n        // Escape sequence\n        switch (charContent) {\n          case '\\\\n':\n            return '\\n'.charCodeAt(0);\n          case '\\\\t':\n            return '\\t'.charCodeAt(0);\n          case '\\\\r':\n            return '\\r'.charCodeAt(0);\n          case '\\\\\\\\':\n            return '\\\\'.charCodeAt(0);\n          case \"\\\\'\":\n            return \"'\".charCodeAt(0);\n          case '\\\\\"':\n            return '\"'.charCodeAt(0);\n          default:\n            this.error(\"Invalid escape sequence: \".concat(charContent));\n            return null;\n        }\n      } else {\n        this.error(\"Invalid character literal: '\".concat(charContent, \"'\"));\n        return null;\n      }\n    }\n  }, {\n    key: \"isRegister\",\n    value: function isRegister(regStr) {\n      return /^(r[0-7]|fp|sp|lr)$/i.test(regStr);\n    }\n  }, {\n    key: \"isOperator\",\n    value: function isOperator(op) {\n      return op === '+' || op === '-';\n    }\n  }, {\n    key: \"parseLabelWithOffset\",\n    value: function parseLabelWithOffset(operand) {\n      // This regex matches:\n      //   1) A label: starting with letter, '_', '$', '@', followed by letters, digits, '_', '$', '@'\n      //   2) An optional offset: a plus or minus sign, optional spaces, then digits\n      //\n      // Examples matched:\n      //   \"myVar\"          -> label = \"myVar\", offset = null\n      //   \"myVar+2\"        -> label = \"myVar\", offset = 2\n      //   \"myVar - 3\"      -> label = \"myVar\", offset = -3\n      //   \"x+10\"           -> label = \"x\", offset = 10\n      //   \"label- 5\"       -> label = \"label\", offset = -5\n      var labelOffsetPattern = /^([A-Za-z_$@][A-Za-z0-9_$@]*)\\s*([+\\-]\\s*\\d+)?$/;\n      var match = operand.match(labelOffsetPattern);\n      if (!match) {\n        return null; // Not a label with optional offset\n      }\n      var label = match[1];\n      var offsetStr = match[2]; // something like \"+2\" or \"- 3\"\n\n      var offset = 0;\n      if (offsetStr) {\n        // Remove spaces and parse the number\n        offsetStr = offsetStr.replace(/\\s+/g, '');\n        offset = parseInt(offsetStr, 10); // parse \"+2\" or \"-3\"\n        if (isNaN(offset)) {\n          // Should never happen if regex matched, but just in case:\n          return null;\n        }\n      }\n      return {\n        label: label,\n        offset: offset\n      };\n    }\n  }, {\n    key: \"parseNumber\",\n    value: function parseNumber(valueStr) {\n      var value;\n      if (valueStr === null || valueStr === undefined) {\n        return null;\n      }\n\n      // Handle character literals\n      if (this.isCharLiteral(valueStr)) {\n        value = this.parseCharLiteral(valueStr);\n        if (value === null) {\n          return NaN; // Signal an error\n        }\n      } else if (valueStr.startsWith('0x') || valueStr.startsWith('0X')) {\n        value = parseInt(valueStr, 16);\n        // note: the LCC doesn't currently support negative hex numbers\n        // } else if (valueStr.startsWith('-0x') || valueStr.startsWith('-0X')) {\n        //   value = -parseInt(valueStr.substr(3), 16);\n      } else {\n        value = parseInt(valueStr, 10);\n      }\n      return value;\n    }\n\n    // TODO: investigate here for detection of undefined labels\n  }, {\n    key: \"handleExternalReference\",\n    value: function handleExternalReference(label, usageType) {\n      // Check if we've already created an entry for this label and usage type\n      if (!this.externalReferences.some(function (ref) {\n        return ref.label === label && ref.type === usageType;\n      })) {\n        this.externalReferences.push({\n          label: label,\n          type: usageType,\n          address: this.locCtr // Store the current location counter\n        });\n      }\n    }\n\n    // TODO: implement operand type checking {valid: [\"num\", \"char\", \"label\"]}\n    /**\r\n     * Evaluates an operand and returns its corresponding value.\r\n     * The operand can be a pure number, a label with an optional offset, or a plain label.\r\n     * Additionally, the operand can be a location marker indicated with the '*' character.\r\n     * \r\n     * @param {string} operand - The operand to evaluate.\r\n     * @param {string} usageType - The context in which the operand is used (e.g., for external references).\r\n     * @returns {number|null} - The evaluated value of the operand, or null if the operand is undefined.\r\n     */\n  }, {\n    key: \"evaluateOperand\",\n    value: function evaluateOperand(operand, usageType) {\n      // First, try to parse as a pure number\n      var value = this.parseNumber(operand);\n      if (!isNaN(value)) {\n        return value;\n      }\n\n      // If not a pure number, check if it's a label with optional offset\n      var parsed = this.parseLabelWithOffset(operand);\n      if (parsed !== null) {\n        // It's a label and possibly an offset\n        var label = parsed.label,\n          offset = parsed.offset;\n        if (this.symbolTable.hasOwnProperty(label)) {\n          // Local label known\n          return this.symbolTable[label] + offset;\n        } else if (this.externLabels.has(label)) {\n          // External label: create external reference if needed and return placeholder (0 + offset)\n          this.handleExternalReference(label, usageType);\n          return 0 + offset;\n        } else {\n          this.error(\"Undefined label\"); // this.error(`Undefined label: ${label}`);\n          return null;\n        }\n      } else {\n        // If we get here, it's neither a pure number nor a label-with-offset.\n        // Maybe it's just a plain label that we haven't seen? Check that scenario:\n        if (this.symbolTable.hasOwnProperty(operand)) {\n          return this.symbolTable[operand];\n        } else if (this.externLabels.has(operand)) {\n          // External symbol, return 0 placeholder\n          this.handleExternalReference(operand, usageType);\n          return 0;\n        } else {\n          // check for * (current location counter)\n          if (operand[0] === '*') {\n            if (operand[1] === '+' || operand[1] === '-') {\n              var _offset = this.parseNumber(operand.slice(1));\n              if (isNaN(_offset)) {\n                this.error(\"Bad number\");\n                return null;\n              }\n              return this.locCtr + _offset;\n            } else {\n              return this.locCtr;\n            }\n          } else {\n            // inspect to see if it was an invalid number\n            // inspect to see if it was an invalid label\n            if (operand[0] === '0' && operand[1] === 'x' && !this.isValidHexNumber(operand)) {\n              this.error(\"Bad number\");\n              fatalExit(\"Bad number\", 1);\n            } else if (!this.isValidLabel(operand)) {\n              this.error(\"Bad label\");\n              fatalExit(\"Bad label\", 1);\n            } else {\n              this.error(\"Unspecified label error for: \".concat(operand)); // this.error(`Undefined label: ${operand}`);\n              fatalExit(\"Unspecified label error for: \".concat(operand), 1);\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"isValidHexNumber\",\n    value: function isValidHexNumber(str) {\n      return /^0x[0-9A-Fa-f]+$/.test(str);\n    }\n\n    // returns true if operand is either a char (which has an ascii value) \n    // or a number (i.e. neither a string nor a label)\n  }, {\n    key: \"isNumLiteral\",\n    value: function isNumLiteral(operand) {\n      return this.isCharLiteral(operand) || !isNaN(operand) || this.isValidHexNumber(operand);\n    }\n  }, {\n    key: \"evaluateImmediate\",\n    value: function evaluateImmediate(valueStr, min, max) {\n      var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n      var value = this.parseNumber(valueStr);\n      if (isNaN(value)) {\n        this.error(\"Bad number\");\n        fatalExit(\"Bad number\", 1);\n      }\n      if (value < min || value > max) {\n        // this.error(`Immediate value out of range: ${valueStr}`);\n        this.error(\"\".concat(type, \" out of range\"));\n        return null;\n      }\n      return value;\n    }\n\n    // function which simply returns the value if it is a number.\n    // capped at 16 bits. Some instructions do not check for out of bounds numbers.\n  }, {\n    key: \"evaluateImmediateNaive\",\n    value: function evaluateImmediateNaive(valueStr) {\n      if (valueStr === null || valueStr === undefined) {\n        return null;\n      }\n      var value = this.parseNumber(valueStr);\n      if (isNaN(value)) {\n        this.error(\"Bad number\"); // `Not a valid number: ${valueStr}`\n        fatalExit(\"Bad number\", 1);\n      }\n      return value & 0xFFFF;\n    }\n  }, {\n    key: \"error\",\n    value: function error(message) {\n      var errorMsg = \"Error on line \".concat(this.lineNum, \" of \").concat(this.inputFileName, \":\\n    \").concat(this.currentLine, \"\\n\").concat(message);\n      console.error(errorMsg);\n      this.errors.push(errorMsg);\n      this.errorFlag = true;\n\n      // If we're not reporting multiple errors, exit immediately\n      // Note: This matches the behavior in the original LCC of reporting only 1 error at a time\n      if (!REPORT_MULTI_ERRORS) {\n        fatalExit(message, 1);\n      }\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Assembler);\n\n// Instantiate and run the assembler if this script is run directly\nconsole.log(process.argv[1]);\nif (\"file:///C:/Users/lettu/projects/lccjs/src/core/assembler.js\" === \"file://\".concat(process.argv[1])) {\n  var assembler = new Assembler();\n  assembler.main();\n}\n\n//# sourceURL=webpack://LCC/./src/core/assembler.js?");

/***/ }),

/***/ "./src/core/interpreter.js":
/*!*********************************!*\
  !*** ./src/core/interpreter.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"./src/polyfills/fsWrapper.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n/* harmony import */ var _utils_genStats_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/genStats.js */ \"./src/utils/genStats.js\");\n/* harmony import */ var _utils_name_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/name.js */ \"./src/utils/name.js\");\n/* provided dependency */ var process = __webpack_require__(/*! ./src/polyfills/processWrapper.js */ \"./src/polyfills/processWrapper.js\")[\"default\"];\n//#!/usr/bin/env node\n\n// interpreter.js\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\nvar newline = process.platform === 'win32' ? '\\r\\n' : '\\n';\nvar MAX_MEMORY = 65536; // 2^16\n\nvar isTestMode = typeof {}.it === 'function'; // crude check for Jest\n\nfunction fatalExit(message) {\n  var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  if (isTestMode) {\n    throw new Error(message);\n  } else {\n    process.exit(code);\n  }\n}\nvar Interpreter = /*#__PURE__*/function () {\n  function Interpreter() {\n    _classCallCheck(this, Interpreter);\n    this.mem = new Uint16Array(65536); // Memory (16-bit unsigned integers)\n    this.r = new Uint16Array(8); // Registers r0 to r7 (16-bit signed integers)\n    this.pc = 0; // Program Counter\n    this.ir = 0; // Instruction Register\n    this.n = 0; // Negative flag\n    this.z = 0; // Zero flag\n    this.c = 0; // Carry flag\n    this.v = 0; // Overflow flag\n    this.running = true;\n    this.output = ''; // Output string\n    this.inputBuffer = ''; // Input buffer for SIN (if needed)\n    this.options = {}; // Options from lcc.js\n    this.instructionsExecuted = 0; // For program statistics\n    this.maxStackSize = 0; // For program statistics\n    this.loadPoint = 0; // Default load point is 0\n    this.spInitial = 0; // For tracking stack size\n    this.memMax = 0; // Keep track of the highest memory address used\n    this.inputFileName = ''; // Name of the input file\n    this.generateStats = false; // Whether to generate .lst and .bst files\n    this.headerLines = [];\n    this.instructionsCap = 500000; // Limit the number of instructions to prevent infinite loops\n  }\n  return _createClass(Interpreter, [{\n    key: \"main\",\n    value: function main(args) {\n      args = args || process.argv.slice(2);\n      if (args.length < 1) {\n        console.error('Usage: node interpreter.js <input filename> [options]');\n        // process.exit(1);\n        fatalExit('Usage: node interpreter.js <input filename> [options]', 1);\n      }\n\n      // Parse arguments\n      var i = 0;\n      while (i < args.length) {\n        var arg = args[i];\n        if (arg.startsWith('-')) {\n          // Option\n          if (arg === '-nostats') {\n            this.generateStats = false;\n          } else if (arg.startsWith('-L')) {\n            // Load point option\n            var loadPointStr = arg.substring(2);\n            if (loadPointStr === '') {\n              // Load point value is in the next argument\n              i++;\n              if (i >= args.length) {\n                console.error('Error: -L option requires a value');\n                // process.exit(1);\n                fatalExit('Error: -L option requires a value', 1);\n              }\n              loadPointStr = args[i];\n            }\n            // Parse load point value (hexadecimal)\n            this.loadPoint = parseInt(loadPointStr, 16);\n            if (isNaN(this.loadPoint)) {\n              console.error(\"Invalid load point value: \".concat(loadPointStr));\n              // process.exit(1);\n              fatalExit(\"Invalid load point value: \".concat(loadPointStr), 1);\n            }\n          } else {\n            console.error(\"Bad command line switch: \".concat(arg)); // `Unknown option: ${arg}`\n            // process.exit(1);\n            fatalExit(\"Bad command line switch: \".concat(arg), 1);\n          }\n        } else {\n          // Assume it's the input file name\n          if (!this.inputFileName) {\n            this.inputFileName = arg;\n            var extension = path__WEBPACK_IMPORTED_MODULE_1__.extname(this.inputFileName).toLowerCase();\n            // Note: This is custom behavior in interpreter.js (not the official LCC)\n            //       to check specifically for .e files, since the LCC interpreter is\n            //       accessed by default when running .e files, or when assembling and\n            //       running .a files all at once.\n            if (extension !== '.e') {\n              console.error('Unsupported file type for interpreter.js (expected .e)');\n              fatalExit('Unsupported file type for interpreter.js (expected .e)', 1);\n            }\n          } else {\n            console.error(\"Unexpected argument: \".concat(arg));\n            // process.exit(1);\n            fatalExit(\"Unexpected argument: \".concat(arg), 1);\n          }\n        }\n        i++;\n      }\n      if (!this.inputFileName) {\n        console.error('No input file specified.');\n        // process.exit(1);\n        fatalExit('No input file specified.', 1);\n      }\n\n      // Get the userName using nameHandler\n      try {\n        //// console.log(`inputFileName = ${this.inputFileName}`);\n        this.userName = _utils_name_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].createNameFile(this.inputFileName);\n        //// console.log(\"userName = \" + this.userName);\n      } catch (error) {\n        console.error('Error handling name file:', error.message);\n        // process.exit(1);\n        fatalExit('Error handling name file: ' + error.message, 1);\n      }\n\n      // this prints out when called by interpreter.js\n      console.log(\"Starting interpretation of \".concat(this.inputFileName));\n\n      // Open and read the executable file\n      var buffer;\n      try {\n        buffer = fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].readFileSync(this.inputFileName);\n      } catch (err) {\n        console.error(\"Cannot open input file \".concat(this.inputFileName)); // , err: ${err}\n        // process.exit(1);\n        fatalExit(\"Cannot open input file \".concat(this.inputFileName), 1); // , err: ${err}\n      }\n\n      // Check file signature\n      if (buffer[0] !== 'o'.charCodeAt(0)) {\n        // `${this.inputFileName} is not a valid LCC executable file: missing 'o' signature`\n        console.error(\"\".concat(this.inputFileName, \" is not in lcc format\"));\n        // process.exit(1);\n        fatalExit(\"\".concat(this.inputFileName, \" is not in lcc format\"), 1);\n      }\n\n      // Load the executable into memory\n      this.loadExecutableBuffer(buffer);\n\n      // Capture the initial memory state\n      this.initialMem = this.mem.slice(); // Makes a copy of the memory array\n\n      // Prepare .lst and .bst file names\n      var lstFileName = this.inputFileName.replace(/\\.e$/, '.lst');\n      var bstFileName = this.inputFileName.replace(/\\.e$/, '.bst');\n      console.log(\"lst file = \".concat(lstFileName));\n      console.log(\"bst file = \".concat(bstFileName));\n      console.log('====================================================== Output');\n\n      // Run the interpreter\n      try {\n        this.run();\n        if (this.generateStats) {\n          console.log(); // Ensure cursor moves to the next line\n        }\n      } catch (error) {\n        console.error(\"Runtime Error: \".concat(error.message));\n        // process.exit(1);\n        fatalExit(\"Runtime Error: \".concat(error.message), 1);\n      }\n\n      // Generate .lst and .bst files if required\n      if (this.generateStats) {\n        var lstContent = (0,_utils_genStats_js__WEBPACK_IMPORTED_MODULE_2__.generateBSTLSTContent)({\n          isBST: false,\n          interpreter: this,\n          assembler: null,\n          userName: this.userName,\n          inputFileName: this.inputFileName\n        });\n        var bstContent = (0,_utils_genStats_js__WEBPACK_IMPORTED_MODULE_2__.generateBSTLSTContent)({\n          isBST: true,\n          interpreter: this,\n          assembler: null,\n          userName: this.userName,\n          inputFileName: this.inputFileName\n        });\n\n        // Write the .lst and .bst files\n        fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeFileSync(lstFileName, lstContent);\n        fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeFileSync(bstFileName, bstContent);\n      }\n    }\n  }, {\n    key: \"constructBSTLSTFileName\",\n    value: function constructBSTLSTFileName(inputFileName, isBST) {\n      var parsedPath = path__WEBPACK_IMPORTED_MODULE_1__.parse(inputFileName);\n      // Remove extension and add '.bst'\n      return path__WEBPACK_IMPORTED_MODULE_1__.format(_objectSpread(_objectSpread({}, parsedPath), {}, {\n        base: undefined,\n        ext: isBST ? '.bst' : '.lst'\n      }));\n    }\n\n    // for use in lcc.js\n    // makes sure that the file is a valid executable file by checking \n    // for the \"o\" file signature and \"C\" header termination character\n  }, {\n    key: \"loadExecutableFile\",\n    value: function loadExecutableFile(fileName) {\n      var buffer;\n      try {\n        buffer = fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].readFileSync(fileName);\n      } catch (err) {\n        console.error(\"Cannot open input file \".concat(fileName));\n        // process.exit(1);\n        fatalExit(\"Cannot open input file \".concat(fileName), 1);\n      }\n\n      // Check file signature: look for \"o\" followed by \"C\" anywhere in the buffer\n      var foundO = false;\n      var foundC = false;\n      for (var offset = 0; offset < buffer.length; offset++) {\n        var _char = String.fromCharCode(buffer[offset]);\n\n        // Look for the starting \"o\"\n        if (!foundO && _char === 'o') {\n          foundO = true;\n        }\n        // Once \"o\" is found, look for the \"C\" as the end of the header\n        else if (foundO && _char === 'C') {\n          foundC = true;\n          break;\n        }\n      }\n\n      // If either \"o\" or \"C\" was not found in the expected order, throw an error\n      if (!foundO || !foundC) {\n        console.error(\"\".concat(fileName, \" is not a valid LCC executable file\"));\n        // process.exit(1);\n        fatalExit(\"\".concat(fileName, \" is not a valid LCC executable file\"), 1);\n      }\n\n      // this prints out when called by lcc.js\n      console.log(\"Starting interpretation of \".concat(fileName));\n\n      // Load the executable into memory\n      this.loadExecutableBuffer(buffer);\n      this.initialMem = this.mem.slice(); // Makes a copy of the memory array\n    }\n\n    // extracts header entries and loads machine code into memory\n  }, {\n    key: \"loadExecutableBuffer\",\n    value: function loadExecutableBuffer(buffer) {\n      var offset = 0;\n\n      // Read file signature\n      if (buffer[offset++] !== 'o'.charCodeAt(0)) {\n        this.error('Invalid file signature: missing \"o\"');\n        return;\n      }\n\n      // Do not store the 'o' signature in headerLines\n\n      var startAddress = 0; // Default start address\n\n      // Read header entries until 'C' is encountered\n      while (offset < buffer.length) {\n        var entryChar = String.fromCharCode(buffer[offset++]);\n        if (entryChar === 'C') {\n          // Start of code\n          // Do not store 'C' in headerLines\n          break;\n        } else if (entryChar === 'S') {\n          // Start address entry: read two bytes as little endian\n          if (offset + 1 >= buffer.length) {\n            this.error('Incomplete start address in header');\n            return;\n          }\n          startAddress = buffer.readUInt16LE(offset);\n          offset += 2;\n          this.headerLines.push(\"S \".concat(startAddress.toString(16).padStart(4, '0')));\n        } else if (entryChar === 'G') {\n          // Skip 'G' entry: Read address and label\n          if (offset + 1 >= buffer.length) {\n            this.error('Incomplete G entry in header');\n            return;\n          }\n          var address = buffer.readUInt16LE(offset);\n          offset += 2;\n          var label = '';\n          while (offset < buffer.length) {\n            var charCode = buffer[offset++];\n            if (charCode === 0) break;\n            label += String.fromCharCode(charCode);\n          }\n          this.headerLines.push(\"G \".concat(address.toString(16).padStart(4, '0'), \" \").concat(label));\n        } else if (entryChar === 'A') {\n          // Skip 'A' entry: Read address\n          if (offset + 1 >= buffer.length) {\n            this.error('Incomplete A entry in header');\n            return;\n          }\n          var _address = buffer.readUInt16LE(offset);\n          offset += 2;\n          this.headerLines.push(\"A \".concat(_address.toString(16).padStart(4, '0')));\n        } else {\n          // Skip unknown entries or handle as needed\n          this.error(\"Unknown header entry: '\".concat(entryChar, \"'\"));\n          return;\n        }\n      }\n\n      // Read machine code into memory starting at this.loadPoint\n      var memIndex = this.loadPoint; // Start loading at loadPoint\n      while (offset + 1 < buffer.length) {\n        var instruction = buffer.readUInt16LE(offset);\n        offset += 2;\n        this.mem[memIndex++] = instruction;\n      }\n      this.memMax = memIndex - 1; // Last memory address used\n\n      // Set PC to loadPoint + startAddress\n      this.pc = this.loadPoint + startAddress & 0xFFFF;\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      this.spInitial = this.r[6]; // Assuming r6 is the stack pointer\n\n      while (this.running) {\n        this.step();\n      }\n    }\n  }, {\n    key: \"step\",\n    value: function step() {\n      // Fetch instruction\n      this.ir = this.mem[this.pc++];\n      // Decode instruction\n      this.opcode = this.ir >> 12 & 0xF; // Opcode (bits 15-12)\n      this.code = this.dr = this.sr = this.ir >> 9 & 0x7; // dr/sr (bits 11-9)\n      this.sr1 = this.baser = this.ir >> 6 & 0x7; // sr1/baser (bits 8-6)\n      this.sr2 = this.ir & 0x7; // sr2 (bits 2-0)\n      this.bit5 = this.ir >> 5 & 0x1; // bit 5\n      this.bit11 = this.ir >> 11 & 0x1; // bit 11\n      this.imm5 = this.signExtend(this.ir & 0x1F, 5); // imm5 (bits 4-0)\n      this.pcoffset9 = this.signExtend(this.ir & 0x1FF, 9); // pcoffset9 (bits 8-0)\n      this.imm9 = this.pcoffset9;\n      this.pcoffset11 = this.signExtend(this.ir & 0x7FF, 11); // pcoffset11 (bits 10-0)\n      this.offset6 = this.signExtend(this.ir & 0x3F, 6); // offset6 (bits 5-0)\n      this.eopcode = this.ir & 0x1F; // eopcode (bits 4-0)\n      this.trapvec = this.ir & 0xFF; // trap vector (bits 7-0)\n\n      // Execute instruction\n      switch (this.opcode) {\n        case 0:\n          // BR\n          this.executeBR();\n          break;\n        case 1:\n          // ADD\n          this.executeADD();\n          break;\n        case 2:\n          // LD\n          this.executeLD();\n          break;\n        case 3:\n          // ST\n          this.executeST();\n          break;\n        case 4:\n          // BL or BLR\n          this.executeBLorBLR();\n          break;\n        case 5:\n          // AND\n          this.executeAND();\n          break;\n        case 6:\n          // LDR\n          this.executeLDR();\n          break;\n        case 7:\n          // STR\n          this.executeSTR();\n          break;\n        case 8:\n          // CMP\n          this.executeCMP();\n          break;\n        case 9:\n          // NOT\n          this.executeNOT();\n          break;\n        case 10:\n          // PUSH, POP, SRL, SRA, SLL, ROL, ROR, MUL, DIV, REM, OR, XOR, MVR, SEXT\n          this.executeCase10();\n          break;\n        case 11:\n          // SUB\n          this.executeSUB();\n          break;\n        case 12:\n          // JMP/RET\n          this.executeJMP();\n          break;\n        case 13:\n          // MVI\n          this.executeMVI();\n          break;\n        case 14:\n          // LEA\n          this.executeLEA();\n          break;\n        case 15:\n          // TRAP\n          this.executeTRAP();\n          break;\n        default:\n          this.error(\"Unknown opcode: \".concat(this.opcode));\n          this.running = false;\n      }\n      this.instructionsExecuted++;\n\n      // Check if the instruction limit has been reached\n      // Note: This is a safety feature to prevent infinite loops\n      // 2nd Note: This matches exactly the # of instructions \n      // permitted to run by from the lcc before entering the debugger\n      if (this.instructionsExecuted >= this.instructionsCap) {\n        console.error(\"Possible infinite loop\");\n        this.running = false;\n        // return; // Exit the step method early\n        fatalExit(\"Possible infinite loop\", 1);\n        //// TODO: after implementing symbolic debugger, this should not exit the program\n        ////       and should instead initiate symbolic debugger execution\n        //// TODO: implement a custom LCC.js behavior to set flags to toggle (1) potential\n        ////       infinite loop detection, and (2) automatic initiation of symbolic debugger\n      }\n\n      // Track max stack size\n      var sp = this.r[6];\n      var stackSize = sp === 0 ? 0 : MAX_MEMORY - sp;\n      if (stackSize > this.maxStackSize) {\n        this.maxStackSize = stackSize;\n      }\n    }\n\n    // cmp    1000  000  sr1 000 sr2   nzcv sr1 - sr2 (set flags) \n    // cmp    1000  000  sr1 1  imm5   nzcv sr1 - imm5 (set flags) \n  }, {\n    key: \"executeCMP\",\n    value: function executeCMP() {\n      if (this.bit5 === 0) {\n        // Register mode\n        var x = this.toSigned16(this.r[this.sr1]);\n        var y = this.toSigned16(this.r[this.sr2]);\n        var negY = -y;\n        var sum = x + negY;\n        var result = sum & 0xFFFF;\n        this.setNZ(result);\n        this.setCV(sum, x, negY);\n      } else {\n        // Immediate mode\n        var _x = this.toSigned16(this.r[this.sr1]);\n        var _y = this.toSigned16(this.imm5);\n        var _negY = -_y;\n        var _sum = _x + _negY;\n        var _result = _sum & 0xFFFF;\n        this.setNZ(_result);\n        this.setCV(_sum, _x, _negY);\n      }\n    }\n  }, {\n    key: \"executeBR\",\n    value: function executeBR() {\n      var conditionMet = false;\n      switch (this.code) {\n        case 0:\n          // brz/bre\n          conditionMet = this.z === 1;\n          break;\n        case 1:\n          // brnz/brne\n          conditionMet = this.z === 0;\n          break;\n        case 2:\n          // brn\n          conditionMet = this.n === 1;\n          break;\n        case 3:\n          // brp\n          conditionMet = this.n === this.z;\n          break;\n        case 4:\n          // brlt\n          conditionMet = this.n !== this.v;\n          break;\n        case 5:\n          // brgt\n          conditionMet = this.n === this.v && this.z === 0;\n          break;\n        case 6:\n          // brc/brb\n          conditionMet = this.c === 1;\n          break;\n        case 7:\n          // br/bral\n          conditionMet = true;\n          break;\n      }\n      if (conditionMet) {\n        this.pc = this.pc + this.pcoffset9 & 0xFFFF;\n      }\n    }\n  }, {\n    key: \"executeCase10\",\n    value: function executeCase10() {\n      // ct is a 4-bit shift count field (if omitted at the assembly level, it defaults to 1). \n      var ct = this.ir >> 5 & 0xF;\n      switch (this.eopcode) {\n        case 0:\n          // PUSH // mem[--sp] = sr \n          // decrement stack pointer and store value\n          this.r[6] = this.r[6] - 1 & 0xFFFF;\n          // save source register to memory at address pointed at by stack pointer\n          this.mem[this.r[6]] = this.r[this.sr];\n          break;\n        case 1:\n          // POP // dr = mem[sp++];\n          // load value from memory at address pointed at by stack pointer to destination\n          this.r[this.dr] = this.mem[this.r[6]];\n          // increment stack pointer (to deallocate stack memory)\n          this.r[6] = this.r[6] + 1 & 0xFFFF;\n          break;\n        /*\r\n        The shift instructions move the contents of the source register either left or right, depending on the specific instruction. The first operand in a shift assembly language instruction specifies the register to be shifted, while the second operand indicates the shift count, which is the number of positions to shift. The shift count must be a value between 0 and 15, and if it is not provided, it defaults to 1.\r\n          The SRL (shift right logical) instruction shifts bits to the right, inserting a 0 on the left to ensure the sign bit becomes 0, regardless of its previous state. The SRA (shift right arithmetic) instruction also shifts bits to the right but preserves the sign bit by copying it into the leftmost position. The SLL (shift left logical) instruction shifts bits to the left, inserting a 0 on the right. For all shift instructions, the c flag is set to the last bit shifted out of the register, and the n and z flags are updated to reflect the state of the register after the shift. For instance, the instruction srl r1, 1 shifts the contents of r1 one position to the right, inserting a 0 on the left.\r\n        */\n        case 2:\n          // SRL\n          this.c = this.r[this.sr] >> ct - 1 & 1; // Store the last bit shifted out\n          this.r[this.sr] = this.r[this.sr] >>> ct; // Unsigned right shift (injects 0's from the left)\n          this.setNZ(this.r[this.sr]); // Update flags\n          break;\n        case 3:\n          // SRA\n          this.c = this.r[this.sr] >> ct - 1 & 1; // Store the last bit shifted out\n          var signBit = this.r[this.sr] & 0x8000 ? 0xFFFF << 16 - ct : 0; // Extend sign bit\n          this.r[this.sr] = this.r[this.sr] >> ct | signBit; // Shift right with sign extension\n          this.setNZ(this.r[this.sr]); // Update flags\n          break;\n        case 4:\n          // SLL\n          this.c = this.r[this.sr] >> 16 - ct & 1; // Store the last bit shifted out\n          this.r[this.sr] = this.r[this.sr] << ct & 0xFFFF; // Logical shift left (mask to 16 bits)\n          this.setNZ(this.r[this.sr]); // Update flags\n          break;\n        case 5:\n          // ROL\n          this.c = this.r[this.sr] >> 16 - ct & 1;\n          this.r[this.sr] = this.r[this.sr] << ct | this.r[this.sr] >> 16 - ct;\n          this.setNZ(this.r[this.sr]);\n          break;\n        case 6:\n          // ROR\n          this.c = this.r[this.sr] >> ct - 1 & 1;\n          this.r[this.sr] = this.r[this.sr] >> ct | this.r[this.sr] << 16 - ct;\n          this.setNZ(this.r[this.sr]);\n          break;\n        case 7:\n          // MUL\n          this.r[this.dr] = this.r[this.dr] * this.r[this.sr1] & 0xFFFF;\n          this.setNZ(this.r[this.dr]);\n          break;\n        case 8:\n          // DIV\n          if (this.r[this.sr1] === 0) {\n            this.error('Floating point exception');\n            fatalExit('Floating point exception', 1);\n          }\n          this.r[this.dr] = this.r[this.dr] / this.r[this.sr1] & 0xFFFF;\n          this.setNZ(this.r[this.dr]);\n          break;\n        case 9:\n          // REM\n          if (this.r[this.sr1] === 0) {\n            this.error('Floating point exception');\n            fatalExit('Floating point exception', 1);\n          }\n          this.r[this.dr] = this.r[this.dr] % this.r[this.sr1] & 0xFFFF;\n          this.setNZ(this.r[this.dr]);\n          break;\n        case 10:\n          // OR\n          this.r[this.dr] = this.r[this.dr] | this.r[this.sr1];\n          this.setNZ(this.r[this.dr]);\n          break;\n        case 11:\n          // XOR\n          this.r[this.dr] = this.r[this.dr] ^ this.r[this.sr1];\n          this.setNZ(this.r[this.dr]);\n          break;\n        case 12:\n          // MVR\n          this.r[this.dr] = this.r[this.sr1];\n          break;\n        case 13:\n          // SEXT\n          this.r[this.dr] = this.signExtend(this.r[this.dr], this.r[this.sr1]);\n          this.setNZ(this.r[this.dr]);\n          break;\n        default:\n          //// TODO: compare implementation with the official LCC interpreter\n          this.error(\"Unknown extended opcode: \".concat(this.eopcode));\n          this.running = false;\n          fatalExit(\"Unknown extended opcode: \".concat(this.eopcode), 1);\n      }\n    }\n  }, {\n    key: \"executeADD\",\n    value: function executeADD() {\n      if (this.bit5 === 0) {\n        // Register mode\n        var result = this.r[this.sr1] + this.r[this.sr2] & 0xFFFF;\n        this.setNZ(result);\n        this.setCV(result, this.r[this.sr1], this.r[this.sr2]);\n        this.r[this.dr] = result;\n      } else {\n        // Immediate mode\n        var _result2 = this.r[this.sr1] + this.imm5 & 0xFFFF;\n        this.setNZ(_result2);\n        this.setCV(_result2, this.r[this.sr1], this.imm5);\n        this.r[this.dr] = _result2;\n      }\n    }\n  }, {\n    key: \"executeSUB\",\n    value: function executeSUB() {\n      if (this.bit5 === 0) {\n        // Register mode\n        var x = this.toSigned16(this.r[this.sr1]);\n        var y = this.toSigned16(this.r[this.sr2]);\n        var negY = -y;\n        var sum = x + negY;\n        var result = sum & 0xFFFF;\n        this.setNZ(result);\n        this.setCV(sum, x, negY);\n        this.r[this.dr] = result;\n      } else {\n        // Immediate mode\n        var _x2 = this.toSigned16(this.r[this.sr1]);\n        var _y2 = this.toSigned16(this.imm5);\n        var _negY2 = -_y2;\n        var _sum2 = _x2 + _negY2;\n        var _result3 = _sum2 & 0xFFFF;\n        this.setNZ(_result3);\n        this.setCV(_sum2, _x2, _negY2);\n        this.r[this.dr] = _result3;\n      }\n    }\n  }, {\n    key: \"executeAND\",\n    value: function executeAND() {\n      if (this.bit5 !== 0) {\n        this.r[this.dr] = this.r[this.sr1] & this.imm5;\n      } else {\n        this.r[this.dr] = this.r[this.sr1] & this.r[this.sr2];\n      }\n      this.setNZ(this.r[this.dr]);\n    }\n  }, {\n    key: \"executeNOT\",\n    value: function executeNOT() {\n      this.r[this.dr] = ~this.r[this.sr1] & 0xFFFF;\n      this.setNZ(this.r[this.dr]);\n    }\n  }, {\n    key: \"executeLD\",\n    value: function executeLD() {\n      var address = this.pc + this.pcoffset9 & 0xFFFF;\n      this.r[this.dr] = this.mem[address];\n      this.setNZ(this.r[this.dr]);\n    }\n  }, {\n    key: \"executeST\",\n    value: function executeST() {\n      var address = this.pc + this.pcoffset9 & 0xFFFF;\n      this.mem[address] = this.r[this.sr];\n      if (address > this.memMax) this.memMax = address;\n    }\n  }, {\n    key: \"executeMVI\",\n    value: function executeMVI() {\n      this.r[this.dr] = this.imm9;\n      this.setNZ(this.r[this.dr]);\n    }\n  }, {\n    key: \"executeLEA\",\n    value: function executeLEA() {\n      this.r[this.dr] = this.pc + this.pcoffset9 & 0xFFFF;\n    }\n\n    ////\n  }, {\n    key: \"executeLDR\",\n    value: function executeLDR() {\n      var address = this.r[this.baser] + this.offset6 & 0xFFFF;\n      this.r[this.dr] = this.mem[address];\n      this.setNZ(this.r[this.dr]);\n    }\n\n    ////\n  }, {\n    key: \"executeSTR\",\n    value: function executeSTR() {\n      var address = this.r[this.baser] + this.offset6 & 0xFFFF;\n      this.mem[address] = this.r[this.sr];\n    }\n\n    ////\n  }, {\n    key: \"executeJMP\",\n    value: function executeJMP() {\n      this.pc = this.r[this.baser] + this.offset6 & 0xFFFF;\n    }\n  }, {\n    key: \"executeBLorBLR\",\n    value: function executeBLorBLR() {\n      if (this.bit11 !== 0) {\n        // BL (Branch and Link)\n        this.r[7] = this.pc;\n        this.pc = this.pc + this.pcoffset11 & 0xFFFF;\n      } else {\n        // BLR (Branch and Link Register)\n        this.r[7] = this.pc;\n        this.pc = this.r[this.baser] + this.offset6 & 0xFFFF;\n      }\n    }\n  }, {\n    key: \"executeSOUT\",\n    value: function executeSOUT() {\n      var address = this.r[this.sr];\n      var charCode = this.mem[address];\n      while (charCode !== 0) {\n        var _char2 = String.fromCharCode(charCode);\n        this.writeOutput(_char2);\n        address = address + 1 & 0xFFFF;\n        charCode = this.mem[address];\n      }\n    }\n  }, {\n    key: \"readLineFromStdin\",\n    value: function readLineFromStdin() {\n      if (this.inputBuffer && this.inputBuffer.length > 0) {\n        // Use the inputBuffer to simulate user input\n        this.inputBuffer = this.inputBuffer.replace(/\\r\\n/g, '\\n');\n        // TODO: check to make sure this behaves as expected on both Linux and Windows\n        var newlineIndex = this.inputBuffer.indexOf('\\n');\n        var inputLine = '';\n        if (newlineIndex !== -1) {\n          inputLine = this.inputBuffer.slice(0, newlineIndex);\n          this.inputBuffer = this.inputBuffer.slice(newlineIndex + 1);\n        } else {\n          inputLine = this.inputBuffer;\n          this.inputBuffer = '';\n        }\n        // Echo the simulated input back to output and stdout\n        ///// this.writeOutput(inputLine + '\\n');\n        this.writeOutput(inputLine);\n        return {\n          inputLine: inputLine,\n          isSimulated: true\n        };\n      } else {\n        // Original code for reading from stdin\n        var input = '';\n        var buffer = Buffer.alloc(1);\n        var fd = process.stdin.fd;\n        while (true) {\n          try {\n            var bytesRead = fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].readSync(fd, buffer, 0, 1, null);\n            if (bytesRead === 0) {\n              // EOF\n              break;\n            }\n            var _char3 = buffer.toString('utf8');\n\n            // If it's a UNIX newline, we're done.\n            if (_char3 === '\\n') {\n              break;\n            }\n\n            // If it's '\\r', check whether the next char is '\\n'.\n            if (_char3 === '\\r') {\n              var nextBytes = fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].readSync(fd, buffer, 0, 1, null);\n              if (nextBytes > 0) {\n                var nextChar = buffer.toString('utf8', 0, nextBytes);\n                // If nextChar is not '\\n', we treat this '\\r' as a line terminator\n                // and the nextChar is actually the start of the next line.\n                if (nextChar !== '\\n') {\n                  input += nextChar; // Or handle it differently if you prefer\n                }\n              }\n              break;\n            }\n            input += _char3;\n          } catch (err) {\n            if (err.code === 'EAGAIN') {\n              // Resource temporarily unavailable, wait a bit and retry\n              continue;\n            } else {\n              throw err;\n            }\n          }\n        }\n        input = input.replace(/\\r$/, '');\n        return {\n          inputLine: input,\n          isSimulated: false\n        };\n      }\n    }\n  }, {\n    key: \"readCharFromStdin\",\n    value: function readCharFromStdin() {\n      if (this.inputBuffer && this.inputBuffer.length > 0) {\n        var ainChar = this.inputBuffer.charAt(0);\n        this.inputBuffer = this.inputBuffer.slice(1);\n        // Echo the simulated input back to output and stdout\n        this.writeOutput(ainChar + newline);\n        return {\n          \"char\": ainChar,\n          isSimulated: true\n        };\n      } else {\n        // Read one character from stdin\n        var ainBuffer = Buffer.alloc(1);\n        var fd = process.stdin.fd;\n        var ainBytesRead = 0;\n\n        // Keep trying to read until we get a character\n        while (ainBytesRead === 0) {\n          try {\n            ainBytesRead = fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].readSync(fd, ainBuffer, 0, 1, null);\n          } catch (err) {\n            if (err.code === 'EAGAIN') {\n              continue;\n            } else {\n              throw err;\n            }\n          }\n        }\n\n        // If we got here, we successfully read a character\n        var _ainChar = ainBuffer.toString('utf8');\n        return {\n          \"char\": _ainChar,\n          isSimulated: false\n        };\n      }\n    }\n  }, {\n    key: \"executeSIN\",\n    value: function executeSIN() {\n      var address = this.r[this.sr];\n      var _this$readLineFromStd = this.readLineFromStdin(),\n        input = _this$readLineFromStd.inputLine,\n        isSimulated = _this$readLineFromStd.isSimulated;\n      for (var i = 0; i < input.length; i++) {\n        this.mem[address] = input.charCodeAt(i);\n        address = address + 1 & 0xFFFF;\n      }\n      // Null-terminate the string\n      this.mem[address] = 0;\n\n      // add newline here if input is simulated\n      if (isSimulated) {\n        this.writeOutput(newline);\n      } else\n        //// else, add input to the output buffer w/ newline delimeter\n        {\n          this.output += input + newline;\n        }\n    }\n  }, {\n    key: \"executeM\",\n    value: function executeM() {\n      for (var addr = 0; addr <= this.memMax; addr++) {\n        var content = this.mem[addr];\n        var line = \"\".concat(addr.toString(16).padStart(4, '0'), \": \").concat(content.toString(16).padStart(4, '0'));\n        this.writeOutput(line + newline);\n      }\n    }\n  }, {\n    key: \"executeR\",\n    value: function executeR() {\n      var pcStr = this.pc.toString(16).padStart(4, '0');\n      var irValue = this.mem[this.pc & 0xFFFF];\n      var irStr = irValue.toString(16).padStart(4, '0');\n      var nzcvStr = \"\".concat(this.n).concat(this.z).concat(this.c).concat(this.v).padStart(4, '0');\n      var output = \"pc = \".concat(pcStr, \"  ir = \").concat(irStr, \"  NZCV = \").concat(nzcvStr).concat(newline);\n      // First line: r0 to r3\n      for (var i = 0; i <= 3; i++) {\n        var regStr = this.r[i].toString(16).padStart(4, '0');\n        output += \"r\".concat(i, \" = \").concat(regStr, \"  \");\n      }\n      output += newline;\n      // Second line: r4, fp, sp, lr\n      var r4Str = this.r[4].toString(16).padStart(4, '0');\n      var fpStr = this.r[5].toString(16).padStart(4, '0');\n      var spStr = this.r[6].toString(16).padStart(4, '0');\n      var lrStr = this.r[7].toString(16).padStart(4, '0');\n      output += \"r4 = \".concat(r4Str, \"  fp = \").concat(fpStr, \"  sp = \").concat(spStr, \"  lr = \").concat(lrStr, \"  \").concat(newline);\n      this.writeOutput(output);\n    }\n  }, {\n    key: \"executeS\",\n    value: function executeS() {\n      var sp = this.r[6];\n      var fp = this.r[5];\n      if (sp === this.spInitial) {\n        this.writeOutput(\"Stack empty\".concat(newline));\n        return;\n      } else {\n        this.writeOutput(\"Stack:\".concat(newline));\n        for (var addr = sp; addr < MAX_MEMORY; addr++) {\n          var value = this.mem[addr];\n          var addrStr = addr.toString(16).padStart(4, '0');\n          var valueStr = value.toString(16).padStart(4, '0');\n          var line = \"\".concat(addrStr, \": \").concat(valueStr);\n          if (addr === fp) {\n            line += ' <--- fp';\n          }\n          this.writeOutput(line + newline);\n        }\n      }\n    }\n  }, {\n    key: \"writeOutput\",\n    value: function writeOutput(message) {\n      process.stdout.write(message);\n      this.output += message;\n    }\n  }, {\n    key: \"executeTRAP\",\n    value: function executeTRAP() {\n      switch (this.trapvec) {\n        case 0:\n          // HALT\n          this.running = false;\n          break;\n        case 1:\n          // NL\n          this.writeOutput(newline);\n          break;\n        case 2:\n          // DOUT\n          var value = this.r[this.sr];\n          // Convert unsigned 16-bit to signed 16-bit\n          if (value & 0x8000) {\n            value -= 0x10000;\n          }\n          var doutStr = \"\".concat(value);\n          this.writeOutput(doutStr);\n          break;\n        case 3:\n          // UDOUT\n          // print as unsigned decimal\n          var udoutStr = \"\".concat(this.r[this.sr] & 0xFFFF);\n          this.writeOutput(udoutStr);\n          break;\n        case 4:\n          // HOUT\n          // print as hexadecimal\n          var houtStr = this.r[this.sr].toString(16).toLowerCase();\n          this.writeOutput(houtStr);\n          break;\n        case 5:\n          // AOUT\n          // print as ASCII character\n          var aoutChar = String.fromCharCode(this.r[this.sr] & 0xFF);\n          this.writeOutput(aoutChar);\n          break;\n        case 6:\n          // SOUT\n          // print string at address\n          this.executeSOUT();\n          break;\n        case 7:\n          // DIN\n          while (true) {\n            var _this$readLineFromStd2 = this.readLineFromStdin(),\n              dinInput = _this$readLineFromStd2.inputLine,\n              _isSimulated = _this$readLineFromStd2.isSimulated;\n            if (dinInput.trim() === '') {\n              continue;\n            }\n            var dinValue = parseInt(dinInput, 10);\n            if (isNaN(dinValue)) {\n              var errorMsg = \"Invalid dec constant. Re-enter:\".concat(newline);\n              this.writeOutput(errorMsg);\n              continue;\n            } else {\n              this.r[this.dr] = dinValue & 0xFFFF;\n              // No need to echo input here; already handled in readLineFromStdin()\n              //// unless input is simulated\n              if (_isSimulated) {\n                this.writeOutput(newline);\n              } else {\n                // add input to the output buffer w/ newline delimeter\n                this.output += dinInput + newline;\n              }\n              break;\n            }\n          }\n          break;\n        case 8:\n          // HIN\n          while (true) {\n            var _this$readLineFromStd3 = this.readLineFromStdin(),\n              hinInput = _this$readLineFromStd3.inputLine,\n              _isSimulated2 = _this$readLineFromStd3.isSimulated;\n            if (hinInput.trim() === '') {\n              continue;\n            }\n            var hinValue = parseInt(hinInput, 16);\n            if (isNaN(hinValue)) {\n              var _errorMsg = \"Invalid hex constant. Re-enter:\".concat(newline);\n              this.writeOutput(_errorMsg);\n              continue;\n            } else {\n              this.r[this.dr] = hinValue & 0xFFFF;\n              // No need to echo input here; already handled in readLineFromStdin()\n              //// unless input is simulated\n              if (_isSimulated2) {\n                this.writeOutput(newline);\n              } else {\n                this.output += hinInput + newline;\n              }\n              break;\n            }\n          }\n          break;\n        case 9:\n          // AIN\n          var _this$readCharFromStd = this.readCharFromStdin(),\n            ainChar = _this$readCharFromStd[\"char\"],\n            isSimulated = _this$readCharFromStd.isSimulated;\n          this.r[this.dr] = ainChar.charCodeAt(0);\n          // No need to echo input here; already handled in readCharFromStdin()\n          break;\n        case 10:\n          // SIN\n          // read a line of input from the user\n          this.executeSIN();\n          break;\n        case 11:\n          // m\n          this.executeM();\n          break;\n        case 12:\n          // r\n          this.executeR();\n          break;\n        case 13:\n          // s\n          this.executeS();\n          break;\n        case 14:\n          // bp\n          this.error('Breakpoint trap not yet implemented');\n          break;\n        default:\n          // `Unknown TRAP vector: ${this.trapvec}`\n          console.error(\"Error on line 0 of \".concat(this.inputFileName));\n          console.error();\n          this.error(\"Trap vector out of range\"); // : ${this.trapvec}\n          this.running = false;\n      }\n    }\n  }, {\n    key: \"toSigned16\",\n    value: function toSigned16(value) {\n      value &= 0xFFFF; // Ensure 16-bit value\n      if (value & 0x8000) {\n        return value - 0x10000; // Convert to negative value\n      } else {\n        return value;\n      }\n    }\n  }, {\n    key: \"setNZ\",\n    value: function setNZ(value) {\n      value = this.toSigned16(value);\n      if (value < 0) {\n        this.n = 1;\n        this.z = 0;\n      } else if (value === 0) {\n        this.n = 0;\n        this.z = 1;\n      } else {\n        this.n = 0;\n        this.z = 0;\n      }\n    }\n  }, {\n    key: \"setCV\",\n    value: function setCV(sum, x, y) {\n      // Convert values to signed 16-bit integers\n      sum = this.toSigned16(sum);\n      x = this.toSigned16(x);\n      y = this.toSigned16(y);\n\n      // Initialize flags\n      this.c = 0;\n      this.v = 0;\n\n      // Carry flag logic\n      if (x >= 0 && y >= 0) {\n        this.c = 0;\n      } else if (x < 0 && y < 0) {\n        this.c = 1;\n      } else if (sum >= 0) {\n        this.c = 1;\n      } else {\n        this.c = 0;\n      }\n\n      // Overflow flag logic\n      if (x < 0 && y >= 0 || x >= 0 && y < 0) {\n        this.v = 0;\n      } else if (sum < 0 && x >= 0 || sum >= 0 && x < 0) {\n        this.v = 1;\n      } else {\n        this.v = 0;\n      }\n    }\n  }, {\n    key: \"signExtend\",\n    value: function signExtend(value, bitWidth) {\n      var signBit = 1 << bitWidth - 1;\n      var mask = (1 << bitWidth) - 1;\n      value = value & mask; // Mask the value to the specified bit width\n      if (value & signBit) {\n        // Negative number, extend the sign bits\n        value |= ~mask;\n      }\n      return value;\n    }\n  }, {\n    key: \"error\",\n    value: function error(message) {\n      // console.error(`Interpreter Error: ${message}`);\n      console.error(\"\".concat(message));\n      this.running = false;\n    }\n  }]);\n}(); // Instantiate and run the interpreter if this script is run directly\nif (\"file:///C:/Users/lettu/projects/lccjs/src/core/interpreter.js\" === \"file://\".concat(process.argv[1])) {\n  var interpreter = new Interpreter();\n  interpreter.generateStats = true; // Set to generate .lst and .bst files\n  interpreter.main();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Interpreter);\n\n//# sourceURL=webpack://LCC/./src/core/interpreter.js?");

/***/ }),

/***/ "./src/core/lcc.js":
/*!*************************!*\
  !*** ./src/core/lcc.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"./src/polyfills/fsWrapper.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n/* harmony import */ var _assembler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./assembler.js */ \"./src/core/assembler.js\");\n/* harmony import */ var _interpreter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpreter.js */ \"./src/core/interpreter.js\");\n/* harmony import */ var _linker_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./linker.js */ \"./src/core/linker.js\");\n/* harmony import */ var _utils_name_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/name.js */ \"./src/utils/name.js\");\n/* harmony import */ var _utils_genStats_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/genStats.js */ \"./src/utils/genStats.js\");\n/* provided dependency */ var process = __webpack_require__(/*! ./src/polyfills/processWrapper.js */ \"./src/polyfills/processWrapper.js\")[\"default\"];\n//#!/usr/bin/env node\n\n// lcc.js\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n\n\n\nvar newline = process.platform === 'win32' ? '\\r\\n' : '\\n';\nvar isTestMode = typeof {}.it === 'function'; // crude check for Jest\n\nfunction fatalExit(message) {\n  var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  if (isTestMode) {\n    throw new Error(message);\n  } else {\n    process.exit(code);\n  }\n}\nvar LCC = /*#__PURE__*/function () {\n  function LCC() {\n    _classCallCheck(this, LCC);\n    this.inputFileName = '';\n    this.outputFileName = '';\n    this.options = {};\n    this.args = [];\n    this.assembler = null;\n    this.interpreter = null;\n    this.inputBuffer = '';\n    this.generateStats = true;\n  }\n  return _createClass(LCC, [{\n    key: \"main\",\n    value: function main(args) {\n      args = args || process.argv.slice(2);\n      if (args.length === 0) {\n        this.printHelp();\n        fatalExit('No input file specified. Printing help message.', 0);\n      }\n      this.parseArguments(args);\n      if (this.args.length === 0) {\n        console.error('No input file specified.');\n        fatalExit('No input file specified.', 1);\n      }\n\n      // If multiple inputs were supplied, the \"main input file\" is the first one\n      this.inputFileName = this.args[0];\n      try {\n        this.userName = _utils_name_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].createNameFile(this.inputFileName);\n      } catch (error) {\n        console.error('Error handling name file:', error.message);\n        fatalExit('Error handling name file: ' + error.message, 1);\n      }\n\n      // TODO: (extra feature) check similarly to see if multiple .a files were \n      // supplied for multi-file assembly.\n      // Note: The original LCC does not check to confirm that all supplied files of .o extension\n      // const allAreObjectFiles = this.args.every(file => path.extname(file).toLowerCase() === '.o');\n\n      // Simply check to see whether the first argument is a .o file\n      var firstArgIsObjectFile = path__WEBPACK_IMPORTED_MODULE_1__.extname(this.args[0]).toLowerCase() === '.o';\n      if (firstArgIsObjectFile) {\n        // We have a linking scenario: one or more files (assumed to be .o files)\n        this.linkObjectFiles(this.args);\n      } else {\n        // The default code path: assemble or execute depending on extension\n        this.handleSingleFile(this.inputFileName);\n      }\n    }\n\n    /**\r\n     * Link multiple .o files into a single executable\r\n     */\n  }, {\n    key: \"linkObjectFiles\",\n    value: function linkObjectFiles(objectFiles) {\n      // If user provided `-o <outfile>` on the command line, we'll have it in this.outputFileName\n      // Otherwise default to `link.e` just like original LCC\n      var outputFile = this.outputFileName || 'link.e';\n\n      // Create the Linker\n      var linker = new _linker_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]();\n\n      // Perform actual linking\n      linker.link(objectFiles, outputFile);\n      // The Linker class will print \"Creating executable file link.e\" or whatever name is specified\n    }\n\n    /**\r\n     * If the input file is not .o, handle it as .hex, .bin, .e, or .a\r\n     */\n  }, {\n    key: \"handleSingleFile\",\n    value: function handleSingleFile(infile) {\n      var ext = path__WEBPACK_IMPORTED_MODULE_1__.extname(infile).toLowerCase();\n      switch (ext) {\n        case '.hex':\n        case '.bin':\n          this.assembleFile();\n          this.executeFile(false, true);\n          break;\n        case '.e':\n          this.outputFileName = infile;\n          this.executeFile(false);\n          break;\n        case '.o':\n          // to match feature parity with original LCC, we attempt to link the single .o file\n          this.assembleFile();\n          break;\n        default:\n          // Likely an assembly source (e.g. .a or anything else)\n          this.assembleFile();\n          if (!this.assembler.isObjectModule) {\n            this.executeFile(true);\n          }\n          break;\n      }\n    }\n  }, {\n    key: \"constructOutputFileName\",\n    value: function constructOutputFileName(inputFileName) {\n      var parsedPath = path__WEBPACK_IMPORTED_MODULE_1__.parse(inputFileName);\n      // Remove extension and add '.e'\n      return path__WEBPACK_IMPORTED_MODULE_1__.format(_objectSpread(_objectSpread({}, parsedPath), {}, {\n        base: undefined,\n        ext: '.e'\n      }));\n    }\n  }, {\n    key: \"printHelp\",\n    value: function printHelp() {\n      console.log('Usage: lcc.js <infile>');\n      console.log('Optional args: -d -m -r -t -f -x -l<hex loadpt> -o <outfile> -h');\n      console.log('   -d:   debug, -m mem display at end, -r: reg display at end');\n      console.log('   -f:   full line display, -x: 4 digit hout, -h: help');\n      console.log('What lcc.js does depends on the extension in the input file name:');\n      console.log('   .hex: execute and output .lst, .bst files');\n      console.log('   .bin: execute and output .lst, .bst files');\n      console.log('   .e:   execute and output .lst, .bst files');\n      console.log('   .o:   link files and output executable file');\n      console.log('   .a or other: assemble and output .e or .o, .lst, .bst files');\n      console.log('         if a .e file is created, it will also be executed');\n      console.log('File types:');\n      console.log('   .hex: machine code in ascii hex');\n      console.log('   .bin: machine code in ascii binary');\n      console.log('   .e:   executable');\n      console.log('   .o    linkable object module');\n      console.log('   .lst: time-stamped listing in hex and output from run');\n      console.log('   .bst: time-stamped listing in binary and output from run');\n      console.log('   .a or other: assembler code');\n      console.log(\"lcc.js Ver 0.1\".concat(newline));\n    }\n  }, {\n    key: \"parseArguments\",\n    value: function parseArguments(args) {\n      var i = 0;\n      while (i < args.length) {\n        var arg = args[i];\n        if (arg.startsWith('-')) {\n          // Option\n          switch (arg) {\n            case '-d':\n              this.options.debug = true;\n              break;\n            case '-m':\n              this.options.memDisplay = true;\n              break;\n            case '-r':\n              this.options.regDisplay = true;\n              break;\n            case '-f':\n              this.options.fullLineDisplay = true;\n              break;\n            case '-x':\n              this.options.hexOutput = true;\n              break;\n            case '-t':\n              this.options.trace = true;\n              break;\n            case '-nostats':\n              this.options.noStats = true;\n              break;\n            case '-h':\n              this.printHelp();\n              fatalExit('Printing help message after -h flag used.', 0);\n            default:\n              if (arg.startsWith('-l')) {\n                // Load point\n                this.options.loadPoint = parseInt(arg.substr(2), 16);\n              } else if (arg === '-o') {\n                // Output file name\n                i++;\n                if (i < args.length) {\n                  this.outputFileName = args[i];\n                } else {\n                  // individual linking output should occur, but the final\n                  // link.e file should not be created in this scenario\n                  console.error('Missing output file name'); // No output file specified after -o\n                  fatalExit('Missing output file name after -o flag', 1);\n                }\n              } else {\n                console.error(\"Unknown option: \".concat(arg));\n                fatalExit(\"Unknown option: \".concat(arg), 1);\n              }\n              break;\n          }\n        } else {\n          // Non-option argument\n          this.args.push(arg);\n        }\n        i++;\n      }\n    }\n  }, {\n    key: \"assembleFile\",\n    value: function assembleFile() {\n      var assembler = new _assembler_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n\n      // Set input and output file names\n      assembler.inputFileName = this.inputFileName;\n      assembler.outputFileName = this.outputFileName || this.constructOutputFileName(this.inputFileName);\n\n      // Update this.outputFileName to match assembler's output\n      this.outputFileName = assembler.outputFileName;\n\n      // Store the assembler instance\n      this.assembler = assembler;\n      try {\n        // Run the assembler's main function\n        assembler.main([this.inputFileName]);\n      } catch (error) {\n        console.error(\"Error assembling \".concat(this.inputFileName, \": \").concat(error.message));\n        fatalExit(\"Error assembling \".concat(this.inputFileName, \": \").concat(error.message), 1);\n      }\n    }\n\n    // Executes the output file\n    // includeSourceCode: boolean, includeComments: boolean\n    // includeSourceCode: whether to include source code in the .lst and .bst files (true when assembling and interpretting .a files)\n    // includeComments: whether to include comments in the .lst and .bst files (this option is set to true just for .bin files currently)\n  }, {\n    key: \"executeFile\",\n    value: function executeFile(includeSourceCode, includeComments) {\n      var interpreter = new _interpreter_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\n\n      // Set options in the interpreter\n      interpreter.options = this.options;\n\n      // Pass inputBuffer to interpreter\n      if (this.inputBuffer) {\n        interpreter.inputBuffer = this.inputBuffer;\n      }\n\n      // Store the interpreter instance\n      this.interpreter = interpreter;\n\n      // Load the executable file\n      interpreter.loadExecutableFile(this.outputFileName);\n      var lstFileName;\n      var bstFileName;\n      if (this.generateStats) {\n        // After execution, generate .lst and .bst files\n        lstFileName = this.outputFileName.replace(/\\.e$/, '.lst');\n        bstFileName = this.outputFileName.replace(/\\.e$/, '.bst');\n        console.log(\"lst file = \".concat(lstFileName));\n        console.log(\"bst file = \".concat(bstFileName));\n        console.log('====================================================== Output');\n      }\n\n      // Run the interpreter\n      try {\n        interpreter.run();\n        if (this.generateStats) {\n          console.log(); // Ensure cursor moves to the next line\n        }\n      } catch (error) {\n        console.error(\"Error running \".concat(this.outputFileName, \": \").concat(error.message));\n        fatalExit(\"Error running \".concat(this.outputFileName, \": \").concat(error.message), 1);\n      }\n      if (this.generateStats) {\n        // Generate .lst and .bst files using genStats.js\n        var lstContent = (0,_utils_genStats_js__WEBPACK_IMPORTED_MODULE_6__.generateBSTLSTContent)({\n          isBST: false,\n          interpreter: interpreter,\n          assembler: includeSourceCode || includeComments ? this.assembler : null,\n          userName: this.userName,\n          inputFileName: this.inputFileName,\n          includeComments: includeComments\n        });\n        var bstContent = (0,_utils_genStats_js__WEBPACK_IMPORTED_MODULE_6__.generateBSTLSTContent)({\n          isBST: true,\n          interpreter: interpreter,\n          assembler: includeSourceCode || includeComments ? this.assembler : null,\n          userName: this.userName,\n          inputFileName: this.inputFileName,\n          includeComments: includeComments\n        });\n\n        // Write the .lst and .bst files\n        fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeFileSync(lstFileName, lstContent);\n        fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeFileSync(bstFileName, bstContent);\n      } else {\n        // console.clear();\n      }\n    }\n  }]);\n}(); // Convert import.meta.url to a file path\nvar metaURL = \"file:///C:/Users/lettu/projects/lccjs/src/core/lcc.js\";\nvar scriptPath = path__WEBPACK_IMPORTED_MODULE_1__.resolve(\"file:///C:/Users/lettu/projects/lccjs/src/core/lcc.js\".replace(\"file:///\", \"\"));\nif (scriptPath === process.argv[1]) {\n  var lcc = new LCC();\n  lcc.main();\n} else if (typeof window !== \"undefined\") {\n  // ✅ Ensure LCC is globally accessible\n  window.LCC = LCC;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LCC);\n\n//# sourceURL=webpack://LCC/./src/core/lcc.js?");

/***/ }),

/***/ "./src/core/linker.js":
/*!****************************!*\
  !*** ./src/core/linker.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"./src/polyfills/fsWrapper.js\");\n/* provided dependency */ var process = __webpack_require__(/*! ./src/polyfills/processWrapper.js */ \"./src/polyfills/processWrapper.js\")[\"default\"];\n//#!/usr/bin/env node\n// linker.js\n// LCC.js Linker\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar isTestMode = typeof {}.it === 'function'; // crude check for Jest\n\nfunction fatalExit(message) {\n  var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  if (isTestMode) {\n    throw new Error(message);\n  } else {\n    process.exit(code);\n  }\n}\nvar Linker = /*#__PURE__*/function () {\n  function Linker() {\n    _classCallCheck(this, Linker);\n    this.mca = []; // Machine Code Array\n    this.mcaIndex = 0;\n    this.GTable = {}; // Global symbols: label -> address\n    this.ETable = []; // External references with 11-bit addresses\n    this.eTable = []; // External references with 9-bit addresses\n    this.VTable = []; // External references with full addresses\n    this.ATable = []; // Local references\n    this.start = null;\n    this.gotStart = false;\n    this.errorFlag = false;\n    this.objectModules = []; // List of object modules to process\n    this.inputFiles = []; // List of input files\n    this.outputFileName = null; // Output file name\n  }\n  return _createClass(Linker, [{\n    key: \"main\",\n    value: function main(args) {\n      args = args || process.argv.slice(2);\n      if (args.length < 1) {\n        console.error('Usage: node linker.js [-o outputfile.e] <object module 1> <object module 2> ...');\n        fatalExit('Usage: node linker.js [-o outputfile.e] <object module 1> <object module 2> ...', 1);\n      }\n      var i = 0;\n      while (i < args.length) {\n        if (args[i] === '-o') {\n          if (i + 1 >= args.length) {\n            console.error('Missing output file name after -o');\n            fatalExit('Missing output file name after -o', 1);\n          }\n          this.outputFileName = args[i + 1];\n          i += 2;\n        } else {\n          this.inputFiles.push(args[i]);\n          i++;\n        }\n      }\n      if (this.inputFiles.length === 0) {\n        console.error('Error: No input object modules specified');\n        fatalExit('Error: No input object modules specified', 1);\n      }\n      this.link(this.inputFiles, this.outputFileName);\n    }\n\n    // Method to read object modules from files\n  }, {\n    key: \"readObjectModule\",\n    value: function readObjectModule(filename) {\n      var buffer = fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].readFileSync(filename);\n      var offset = 0;\n      if (buffer[offset++] !== 'o'.charCodeAt(0)) {\n        this.error(\"\".concat(filename, \" not a linkable file\"));\n        return;\n      }\n      var module = {\n        headers: [],\n        code: []\n      };\n\n      // Process headers\n      while (offset < buffer.length) {\n        var entryType = String.fromCharCode(buffer[offset++]);\n        if (entryType === 'C') {\n          // End of header, start of code\n          break;\n        }\n        switch (entryType) {\n          case 'S':\n            {\n              if (offset + 1 >= buffer.length) {\n                this.error('Invalid S entry');\n                return;\n              }\n              var address = buffer.readUInt16LE(offset);\n              offset += 2;\n              module.headers.push({\n                type: 'S',\n                address: address\n              });\n              break;\n            }\n          case 'G':\n          case 'E':\n          case 'e':\n          case 'V':\n            {\n              if (offset + 1 >= buffer.length) {\n                // Incomplete entry\n                this.error(\"Invalid \".concat(entryType, \" entry\"));\n                return;\n              }\n              var _address = buffer.readUInt16LE(offset);\n              offset += 2;\n              var label = '';\n              while (offset < buffer.length) {\n                var charCode = buffer[offset++];\n                if (charCode === 0) break; // Null terminator\n                label += String.fromCharCode(charCode);\n              }\n              module.headers.push({\n                type: entryType,\n                address: _address,\n                label: label\n              });\n              break;\n            }\n          case 'A':\n            {\n              if (offset + 1 >= buffer.length) {\n                this.error('Invalid A entry');\n                return;\n              }\n              var _address2 = buffer.readUInt16LE(offset);\n              offset += 2;\n              module.headers.push({\n                type: 'A',\n                address: _address2\n              });\n              break;\n            }\n          default:\n            this.error(\"Unknown header entry \".concat(entryType, \" in file \").concat(filename));\n            return;\n        }\n      }\n\n      // Read code\n      while (offset + 1 < buffer.length) {\n        var word = buffer.readUInt16LE(offset);\n        offset += 2;\n        module.code.push(word);\n      }\n\n      // Store the module for processing\n      this.objectModules.push(module);\n    }\n  }, {\n    key: \"link\",\n    value: function link(filenames, outputFileName) {\n      this.inputFiles = filenames; // Save input files\n      this.outputFileName = outputFileName || 'link.e'; // Save output filename\n\n      // Read all object modules\n      var _iterator = _createForOfIteratorHelper(filenames),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var filename = _step.value;\n          this.readObjectModule(filename);\n          if (this.errorFlag) {\n            // If invalid file or read error encountered, stop immediately\n            return null;\n          }\n          console.log(\"Linking \".concat(filename));\n        }\n\n        // Process each module\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var _iterator2 = _createForOfIteratorHelper(this.objectModules),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var module = _step2.value;\n          this.processModule(module);\n          if (this.errorFlag) {\n            return null;\n          }\n        }\n\n        // Adjust external references\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      this.adjustExternalReferences();\n      if (this.errorFlag) return;\n\n      // Adjust local references\n      this.adjustLocalReferences();\n      if (this.errorFlag) return;\n\n      // Create executable\n      console.log(\"Creating executable file \".concat(this.outputFileName));\n      this.createExecutable();\n    }\n  }, {\n    key: \"processModule\",\n    value: function processModule(module) {\n      // Process headers\n      var headers = module.headers;\n      var code = module.code;\n      var _iterator3 = _createForOfIteratorHelper(headers),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var header = _step3.value;\n          switch (header.type) {\n            case 'S':\n              if (this.gotStart) {\n                this.error('Multiple entry points');\n                return;\n              }\n              this.start = header.address + this.mcaIndex;\n              this.gotStart = true;\n              break;\n            case 'G':\n              if (this.GTable.hasOwnProperty(header.label)) {\n                this.error(\"Multiple definitions of global symbol \".concat(header.label));\n                return;\n              }\n              this.GTable[header.label] = header.address + this.mcaIndex;\n              break;\n            case 'E':\n              this.ETable.push({\n                address: header.address + this.mcaIndex,\n                label: header.label\n              });\n              break;\n            case 'e':\n              this.eTable.push({\n                address: header.address + this.mcaIndex,\n                label: header.label\n              });\n              break;\n            case 'V':\n              this.VTable.push({\n                address: header.address + this.mcaIndex,\n                label: header.label\n              });\n              break;\n            case 'A':\n              this.ATable.push({\n                address: header.address + this.mcaIndex,\n                moduleStart: this.mcaIndex\n              });\n              break;\n            default:\n              this.error(\"Invalid header entry: \".concat(header.type));\n              return;\n          }\n        }\n\n        // Append code to mca\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      var _iterator4 = _createForOfIteratorHelper(code),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var word = _step4.value;\n          this.mca[this.mcaIndex++] = word;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"adjustExternalReferences\",\n    value: function adjustExternalReferences() {\n      // Adjust ETable (11-bit addresses)\n      var _iterator5 = _createForOfIteratorHelper(this.ETable),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var ref = _step5.value;\n          if (!this.GTable.hasOwnProperty(ref.label)) {\n            this.error(\"\".concat(ref.label, \" is an undefined external reference\"));\n            return;\n          }\n          var Gaddr = this.GTable[ref.label];\n          var offset = this.mca[ref.address] + Gaddr - ref.address - 1 & 0x7ff;\n          this.mca[ref.address] = this.mca[ref.address] & 0xf800 | offset;\n        }\n\n        // Adjust eTable (9-bit addresses)\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      var _iterator6 = _createForOfIteratorHelper(this.eTable),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _ref = _step6.value;\n          if (!this.GTable.hasOwnProperty(_ref.label)) {\n            this.error(\"\".concat(_ref.label, \" is an undefined external reference\"));\n            return;\n          }\n          var _Gaddr = this.GTable[_ref.label];\n          var _offset = this.mca[_ref.address] + _Gaddr - _ref.address - 1 & 0x1ff;\n          this.mca[_ref.address] = this.mca[_ref.address] & 0xfe00 | _offset;\n        }\n\n        // Adjust VTable (full addresses)\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      var _iterator7 = _createForOfIteratorHelper(this.VTable),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _ref2 = _step7.value;\n          if (!this.GTable.hasOwnProperty(_ref2.label)) {\n            this.error(\"\".concat(_ref2.label, \" is an undefined external reference\"));\n            return;\n          }\n          var _Gaddr2 = this.GTable[_ref2.label];\n          this.mca[_ref2.address] += _Gaddr2;\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }, {\n    key: \"adjustLocalReferences\",\n    value: function adjustLocalReferences() {\n      var _iterator8 = _createForOfIteratorHelper(this.ATable),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var ref = _step8.value;\n          this.mca[ref.address] += ref.moduleStart;\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  }, {\n    key: \"createExecutable\",\n    value: function createExecutable() {\n      // Write executable file\n      var outfileName = this.outputFileName;\n\n      // Write executable file\n      var outFile = fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].openSync(outfileName, 'w');\n\n      // Write file signature\n      fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(outFile, 'o');\n\n      // Write 'S' entry if we have a start address\n      if (this.gotStart) {\n        var buffer = Buffer.alloc(3);\n        buffer.write('S', 0, 'ascii');\n        buffer.writeUInt16LE(this.start, 1);\n        fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(outFile, buffer);\n      }\n\n      // Write 'G' entries\n      for (var label in this.GTable) {\n        var address = this.GTable[label];\n        var _buffer = Buffer.alloc(3 + label.length + 1);\n        _buffer.write('G', 0, 'ascii');\n        _buffer.writeUInt16LE(address, 1);\n        _buffer.write(label, 3, 'ascii');\n        _buffer.writeUInt8(0, 3 + label.length); // Null terminator\n        fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(outFile, _buffer);\n      }\n\n      // Write 'A' entries for VTable entries\n      var _iterator9 = _createForOfIteratorHelper(this.VTable),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var ref = _step9.value;\n          var _buffer2 = Buffer.alloc(3);\n          _buffer2.write('A', 0, 'ascii');\n          _buffer2.writeUInt16LE(ref.address, 1);\n          fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(outFile, _buffer2);\n        }\n\n        // Write 'A' entries\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n      var _iterator10 = _createForOfIteratorHelper(this.ATable),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var _ref3 = _step10.value;\n          var _buffer3 = Buffer.alloc(3);\n          _buffer3.write('A', 0, 'ascii');\n          _buffer3.writeUInt16LE(_ref3.address, 1);\n          fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(outFile, _buffer3);\n        }\n\n        // Terminate header\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n      fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(outFile, 'C');\n\n      // Write machine code\n      var codeBuffer = Buffer.alloc(this.mca.length * 2);\n      for (var i = 0; i < this.mca.length; i++) {\n        codeBuffer.writeUInt16LE(this.mca[i], i * 2);\n      }\n      fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(outFile, codeBuffer);\n      fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].closeSync(outFile);\n    }\n  }, {\n    key: \"error\",\n    value: function error(message) {\n      console.error(\"\".concat(message)); // linker error\n      this.errorFlag = true;\n    }\n  }]);\n}();\nif (\"file:///C:/Users/lettu/projects/lccjs/src/core/linker.js\" === \"file://\".concat(process.argv[1])) {\n  var linker = new Linker();\n  linker.main();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Linker);\n\n//# sourceURL=webpack://LCC/./src/core/linker.js?");

/***/ }),

/***/ "./src/polyfills/fsWrapper.js":
/*!************************************!*\
  !*** ./src/polyfills/fsWrapper.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar fsWrapper;\nconsole.warn(\"FS Polyfill is being used in the browser.\");\nvar storageKey = \"fsWrapper\";\nvar storage = JSON.parse(localStorage.getItem(storageKey) || \"{}\");\nvar saveStorage = function saveStorage() {\n  return localStorage.setItem(storageKey, JSON.stringify(storage));\n};\nfsWrapper = {\n  readFile: function readFile(path, encoding, callback) {\n    if (typeof encoding === \"function\") {\n      callback = encoding;\n      encoding = \"utf8\";\n    }\n    setTimeout(function () {\n      if (storage[path]) {\n        callback(null, storage[path]);\n      } else {\n        callback(new Error(\"File not found\"), null);\n      }\n    }, 10);\n  },\n  writeFile: function writeFile(path, data, callback) {\n    setTimeout(function () {\n      storage[path] = data;\n      saveStorage();\n      callback(null);\n    }, 10);\n  },\n  existsSync: function existsSync(path) {\n    return !!storage[path];\n  },\n  readdir: function readdir(path, callback) {\n    setTimeout(function () {\n      return callback(null, Object.keys(storage));\n    }, 10);\n  },\n  unlink: function unlink(path, callback) {\n    setTimeout(function () {\n      delete storage[path];\n      saveStorage();\n      callback(null);\n    }, 10);\n  },\n  mkdir: function mkdir(path, options, callback) {\n    setTimeout(function () {\n      return callback(null);\n    }, 10);\n  },\n  // Synchronous methods for browser\n  readdirSync: function readdirSync() {\n    return Object.keys(storage);\n  },\n  writeFileSync: function writeFileSync(path, data) {\n    storage[path] = data;\n    saveStorage();\n  },\n  readFileSync: function readFileSync(path) {\n    if (storage[path]) {\n      return storage[path];\n    }\n    throw new Error(\"File not found\");\n  },\n  statSync: function statSync(path) {\n    if (storage[path]) {\n      return {\n        size: storage[path].length,\n        isFile: true\n      };\n    }\n    throw new Error(\"File not found\");\n  },\n  mkdirSync: function mkdirSync() {},\n  copyFileSync: function copyFileSync(src, dest) {\n    if (!storage[src]) throw new Error(\"Source file not found\");\n    storage[dest] = storage[src];\n    saveStorage();\n  },\n  unlinkSync: function unlinkSync(path) {\n    delete storage[path];\n    saveStorage();\n  },\n  writeSync: function writeSync(fd, data) {\n    storage[fd] = (storage[fd] || \"\") + data;\n    saveStorage();\n  },\n  openSync: function openSync(path, flags) {\n    if (!storage[path]) storage[path] = \"\";\n    return path;\n  },\n  readSync: function readSync(fd, buffer, offset, length, position) {\n    var data = storage[fd];\n    if (!data) return 0;\n    var bytesRead = Math.min(length, data.length - position);\n    buffer.set(data.slice(position, position + bytesRead), offset);\n    return bytesRead;\n  },\n  closeSync: function closeSync() {}\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (fsWrapper);\n\n//# sourceURL=webpack://LCC/./src/polyfills/fsWrapper.js?");

/***/ }),

/***/ "./src/polyfills/processWrapper.js":
/*!*****************************************!*\
  !*** ./src/polyfills/processWrapper.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconsole.warn(\"Process Polyfill is being used in the browser.\");\nvar process = {\n  cwd: function cwd() {\n    return \"/\";\n  },\n  env: {},\n  exit: function exit(code) {\n    console.warn(\"Process exited with code:\", code);\n  },\n  stdout: {\n    write: function write(data) {\n      return console.log(data);\n    }\n  },\n  platform: \"browser\",\n  argv: [\"browser\", \"polyfill\"]\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (process);\n\n//# sourceURL=webpack://LCC/./src/polyfills/processWrapper.js?");

/***/ }),

/***/ "./src/utils/genStats.js":
/*!*******************************!*\
  !*** ./src/utils/genStats.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   generateBSTLSTContent: () => (/* binding */ generateBSTLSTContent)\n/* harmony export */ });\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n// genStats.js\n\nfunction generateBSTLSTContent(options) {\n  var isBST = options.isBST,\n    interpreter = options.interpreter,\n    assembler = options.assembler,\n    userName = options.userName,\n    inputFileName = options.inputFileName,\n    includeComments = options.includeComments;\n  var content = '';\n\n  // Header\n  content += \"LCC.js Assemble/Link/Interpret/Debug Ver 0.1  \".concat(new Date().toLocaleString('en-US', {\n    weekday: 'short',\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    hour12: false\n  }), \"\\n\");\n  content += \"\".concat(userName, \"\\n\\n\");\n  content += 'Header\\n';\n  content += 'o\\n';\n\n  // Only if headerLines exist\n  if (assembler && assembler.headerLines && assembler.headerLines.length > 0) {\n    for (var i = 0; i < assembler.headerLines.length; i++) {\n      content += \"\".concat(assembler.headerLines[i], \"\\n\");\n    }\n  } else if (interpreter && interpreter.headerLines && interpreter.headerLines.length > 0) {\n    for (var _i = 0; _i < interpreter.headerLines.length; _i++) {\n      content += \"\".concat(interpreter.headerLines[_i], \"\\n\");\n    }\n  }\n  content += 'C\\n\\n';\n\n  // Output code\n  if (assembler && assembler.listing) {\n    if (!options.includeComments) {\n      content += 'Loc   Code           Source Code\\n';\n    } else {\n      content += 'Loc   Code\\n';\n    }\n    assembler.listing.forEach(function (entry) {\n      var codeWords = entry.codeWords;\n      var macWord = entry.macWord;\n      if (codeWords && codeWords.length > 0) {\n        var locCtr = entry.locCtr;\n        codeWords.forEach(function (word, index) {\n          var wordStr = isBST ? word.toString(2).padStart(16, '0').replace(/(.{4})/g, '$1 ').trim() : word.toString(16).padStart(4, '0');\n          var lineStr = \"\".concat(locCtr.toString(16).padStart(4, '0'), \"  \").concat(wordStr.padEnd(10));\n          if (index === 0) {\n            // Include source code\n            lineStr += \" \".concat(entry.sourceLine);\n          }\n          content += \"\".concat(lineStr, \"\\n\");\n          locCtr++;\n        });\n      } else if (codeWords && codeWords.length === 0) {\n        // No code words, do not include the source line\n        var lineStr = \"                    \".concat(entry.sourceLine);\n        content += \"\".concat(lineStr, \"\\n\");\n      } else if (macWord !== '') {\n        // Machine word exists (for .bin files)\n        var wordStr = isBST ? macWord.toString(2).padStart(16, '0').replace(/(.{4})/g, '$1 ').trim() : macWord.toString(16).padStart(4, '0');\n\n        // Build a line with \"Loc\" and the code word in hex (or bin), plus optional \"; comment\"\n        var _lineStr = \"\".concat(entry.locCtr.toString(16).padStart(4, '0'), \"  \").concat(wordStr);\n        if (includeComments && entry.comment) {\n          _lineStr += \" ; \".concat(entry.comment);\n        }\n        content += _lineStr + '\\n';\n      }\n    });\n  } else if (interpreter && interpreter.mem) {\n    content += 'Loc   Code\\n';\n\n    // Output code from interpreter's memory\n    for (var addr = interpreter.loadPoint; addr <= interpreter.memMax; addr++) {\n      var locStr = addr.toString(16).padStart(4, '0');\n      var word = interpreter.initialMem[addr];\n      var wordStr = isBST ? word.toString(2).padStart(16, '0').replace(/(.{4})/g, '$1 ').trim() : word.toString(16).padStart(4, '0');\n      content += \"\".concat(locStr, \"  \").concat(wordStr, \"\\n\");\n    }\n  }\n\n  // Output Output section and Program statistics if interpreter is provided\n  if (interpreter) {\n    content += '====================================================== Output\\n';\n    content += \"\".concat(interpreter.output, \"\\n\");\n    content += '========================================== Program statistics\\n';\n\n    // Prepare the statistics\n    var stats = [{\n      label: 'Input file name',\n      value: inputFileName\n    }, {\n      label: 'Instructions executed',\n      value: \"\".concat(interpreter.instructionsExecuted.toString(16), \" (hex)    \").concat(interpreter.instructionsExecuted, \" (dec)\")\n    }, {\n      label: 'Program size',\n      value: \"\".concat((interpreter.memMax - interpreter.loadPoint + 1).toString(16), \" (hex)    \").concat(interpreter.memMax + 1, \" (dec)\")\n    }, {\n      label: 'Max stack size',\n      value: \"\".concat(interpreter.maxStackSize.toString(16), \" (hex)    \").concat(interpreter.maxStackSize, \" (dec)\")\n    }, {\n      label: 'Load point',\n      value: \"\".concat(interpreter.loadPoint.toString(16), \" (hex)    \").concat(interpreter.loadPoint, \" (dec)\")\n    }];\n    var maxStatLabelLength = Math.max.apply(Math, _toConsumableArray(stats.map(function (s) {\n      return s.label.length;\n    })));\n    stats.forEach(function (stat) {\n      var label = stat.label.padEnd(maxStatLabelLength + 4); // Add 4 spaces for padding\n      content += \"\".concat(label, \"=   \").concat(stat.value, \"\\n\");\n    });\n  }\n  return content;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  generateBSTLSTContent: generateBSTLSTContent\n});\n\n//# sourceURL=webpack://LCC/./src/utils/genStats.js?");

/***/ }),

/***/ "./src/utils/name.js":
/*!***************************!*\
  !*** ./src/utils/name.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"./src/polyfills/fsWrapper.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! ./src/polyfills/processWrapper.js */ \"./src/polyfills/processWrapper.js\")[\"default\"];\n// name.js\n// LCC.js Namer\n\n// This program's purpose is to check for a name.nnn file.\n// If it exists, it reads the name from the file to use.\n// If name.nnn does not exist, this program prompts the \n// user for their name, creates the name.nnn file, and\n// saves the name inside of it.\n// This program asks t he user for their name in the \n// format \"LastName, FirstName MiddleInitial\"\n\n\n\nvar newline = process.platform === 'win32' ? '\\r\\n' : '\\n';\nvar prompt = \"Enter familyname, firstname middleinitial (if any)\".concat(newline);\nfunction readLineFromStdin() {\n  var input = '';\n  var buffer = Buffer.alloc(1);\n  var fd = process.stdin.fd;\n  while (true) {\n    try {\n      var bytesRead = fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].readSync(fd, buffer, 0, 1, null);\n      if (bytesRead === 0) {\n        // EOF\n        break;\n      }\n      var _char = buffer.toString('utf8');\n      if (_char === '\\n' || _char === '\\r') {\n        // Stop reading input on newline or carriage return\n        break;\n      }\n      input += _char;\n    } catch (err) {\n      if (err.code === 'EAGAIN') {\n        // Resource temporarily unavailable, wait a bit and retry\n        continue;\n      } else {\n        throw err;\n      }\n    }\n  }\n  return input;\n}\nfunction createNameFile(inputPath) {\n  // Get the directory of the input file\n  var dir = path__WEBPACK_IMPORTED_MODULE_1__.dirname(inputPath);\n  var nameFile = path__WEBPACK_IMPORTED_MODULE_1__.join(dir, 'name.nnn');\n\n  // Check if name.nnn already exists\n  if (fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].existsSync(nameFile)) {\n    return fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].readFileSync(nameFile, 'utf8').trim();\n  }\n\n  // If not, prompt for name\n  process.stdout.write(prompt);\n  var name = readLineFromStdin();\n\n  // Note: The lcc does not validate that names are properly formatted,\n  // but it should make sure that the name is not empty.\n  if (name.trim() === '') {\n    console.error('Name cannot be empty');\n    process.exit(1);\n  }\n\n  // Write to name.nnn file with \\n if on linux/mac or \\r\\n if on windows\n  fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeFileSync(nameFile, name + newline, {\n    encoding: 'utf8'\n  });\n  return name;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  createNameFile: createNameFile\n});\n\n//# sourceURL=webpack://LCC/./src/utils/name.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/core/lcc.js");
/******/ 	window.LCC = __webpack_exports__;
/******/ 	
/******/ })()
;