/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var LCC;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://LCC/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n\n\n//# sourceURL=webpack://LCC/./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://LCC/./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! ./src/polyfills/processWrapper.js */ \"./src/polyfills/processWrapper.js\")[\"default\"];\n// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n\n\n//# sourceURL=webpack://LCC/./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./src/core/assembler.js":
/*!*******************************!*\
  !*** ./src/core/assembler.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"./src/polyfills/fsWrapper.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n/* harmony import */ var _utils_genStats_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/genStats.js */ \"./src/utils/genStats.js\");\n/* harmony import */ var _utils_name_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/name.js */ \"./src/utils/name.js\");\n/* provided dependency */ var process = __webpack_require__(/*! ./src/polyfills/processWrapper.js */ \"./src/polyfills/processWrapper.js\")[\"default\"];\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n//#!/usr/bin/env node\n\n// assembler.js\n// LCC.js Assembler\n\n/*\r\n * The Assembler class performs a two-pass assembly process:\r\n * Pass 1: Parses the source lines, builds the symbol table, and handles labels.\r\n * Pass 2: Generates machine code based on the symbol table and source lines.\r\n*/\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\nvar isTestMode = typeof {}.it === 'function'; // crude check for Jest\n\nfunction fatalExit(message) {\n  var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  if (isTestMode) {\n    throw new Error(message);\n  } else {\n    process.exit(code);\n  }\n}\n\n// Set to false to match original LCC behavior of reporting only a single error at a time\nvar REPORT_MULTI_ERRORS = false;\nvar Assembler = /*#__PURE__*/function () {\n  function Assembler() {\n    _classCallCheck(this, Assembler);\n    /**\r\n     * Symbol table: symbol to address mapping\r\n     */\n    this.symbolTable = {};\n\n    /**\r\n     * Location counter\r\n     */\n    this.locCtr = 0;\n\n    /**\r\n     * Line number\r\n     */\n    this.lineNum = 0;\n\n    /**\r\n     * Array of source code lines\r\n     */\n    this.sourceLines = [];\n\n    /**\r\n     * Error flag\r\n     */\n    this.errorFlag = false;\n\n    /**\r\n     * Current pass (1 or 2)\r\n     */\n    this.pass = 1;\n\n    /**\r\n     * Set of labels to detect duplicates\r\n     */\n    this.labels = new Set();\n\n    /**\r\n     * Collect errors\r\n     */\n    this.errors = [];\n\n    /**\r\n     * Buffer to hold machine code words\r\n     */\n    this.outputBuffer = [];\n\n    /**\r\n     * Input file name\r\n     */\n    this.inputFileName = '';\n\n    /**\r\n     * Output file name\r\n     */\n    this.outputFileName = '';\n\n    /**\r\n     * Output file handle\r\n     */\n    this.outFile = null;\n\n    /**\r\n     * This will store information about each line, including the location counter (locCtr), machine code words, and the source code line.\r\n     */\n    this.listing = [];\n\n    /**\r\n     * Load point\r\n     */\n    this.loadPoint = 0;\n\n    /**\r\n     * Program size\r\n     */\n    this.programSize = 0;\n\n    /**\r\n     * Label specified in .start directive\r\n     */\n    this.startLabel = null;\n\n    /**\r\n     * Resolved address of the start label\r\n     */\n    this.startAddress = null;\n\n    /**\r\n     * Flag to indicate if the code is to be made into a .o object file\r\n     */\n    this.isObjectModule = false;\n\n    /**\r\n     * Set of global labels to be exported\r\n     */\n    this.globalLabels = new Set();\n\n    /**\r\n     * Set of external labels to be imported\r\n     */\n    this.externLabels = new Set();\n\n    /**\r\n     * Array to store external references\r\n     */\n    this.externalReferences = [];\n\n    /**\r\n     * Array to store adjustment entries\r\n     */\n    this.adjustmentEntries = [];\n  }\n\n  /**\r\n   * Adds the given address to the adjustmentEntries array if it is not already included.\r\n   *\r\n   * @param {number} address - The address to be added to the adjustmentEntries array.\r\n   */\n  return _createClass(Assembler, [{\n    key: \"handleAdjustmentEntry\",\n    value: function handleAdjustmentEntry(address) {\n      if (!this.adjustmentEntries.includes(address)) {\n        this.adjustmentEntries.push(address);\n      }\n    }\n  }, {\n    key: \"main\",\n    value: function main(args) {\n      args = args || process.argv.slice(2);\n\n      //// TODO: change logic here to only give usage message\n      ////       if no input files are provided\n      // Check if inputFileName is already set\n      if (!this.inputFileName) {\n        if (args.length !== 1) {\n          console.error('Usage: assembler.js <input filename>');\n          fatalExit('Usage: assembler.js <input filename>', 1);\n        }\n        this.inputFileName = args[0];\n      }\n\n      // Read the source code from the input file\n      try {\n        var sourceCode = fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].readFileSync(this.inputFileName, 'utf-8');\n        this.sourceLines = sourceCode.split('\\n');\n      } catch (err) {\n        console.error(\"Cannot open input file \".concat(this.inputFileName)); // , err: ${err}\n        fatalExit(\"Cannot open input file \".concat(this.inputFileName), 1); // , err: ${err}\n      }\n      var extension = path__WEBPACK_IMPORTED_MODULE_1__.extname(this.inputFileName).toLowerCase();\n\n      // If the file ends in \".bin\", parse it as raw binary instead of doing normal assembly\n      if (extension === '.bin') {\n        // Note: The original LCC does not print any message for assemnbling a .bin file as\n        // of 12/2024. I say this should be here to provide user feedback & good UX\n        console.log(\"Assembling \".concat(this.inputFileName));\n        this.parseBinFile();\n        // Construct output filename with .e extension\n        this.outputFileName = this.constructOutputFileName(this.inputFileName, '.e');\n        // Now write the output as a .e file\n        this.writeOutputFile();\n      } else if (extension === '.hex') {\n        console.log(\"Assembling \".concat(this.inputFileName));\n        this.parseHexFile();\n        this.outputFileName = this.constructOutputFileName(this.inputFileName, '.e');\n        this.writeOutputFile();\n      } else if (extension === '.a') {\n        // If a .a file, proceed with normal two-pass assembly...\n        // Construct the output file name by replacing extension with '.e'\n        this.outputFileName = this.constructOutputFileName(this.inputFileName, '.e');\n\n        // Perform Pass 1\n        console.log('Starting assembly pass 1');\n        this.pass = 1;\n        this.locCtr = 0;\n        this.loadPoint = 0; // TODO: fix this to not be hardcoded, because flags may dictate where in memory the program starts\n        this.lineNum = 0;\n        this.errorFlag = false;\n        this.symbolTable = {};\n        this.labels.clear();\n        this.errors = [];\n        this.performPass();\n        if (this.locCtr === 0) {\n          console.error('Empty file');\n          fatalExit('Empty file', 0); // No instructions or data found in source file\n        }\n        if (this.errorFlag) {\n          // console.error('Errors encountered during Pass 1.');\n          // this.errors.forEach(error => console.error(error));\n          fatalExit('Errors encountered during Pass 1.', 1);\n        }\n\n        // Rewind source lines for Pass 2\n        console.log('Starting assembly pass 2');\n        this.pass = 2;\n        this.locCtr = 0;\n        this.lineNum = 0;\n        this.performPass();\n\n        // After Pass 2\n        if (this.isObjectModule) {\n          // Change output extension to .o\n          this.outputFileName = this.constructOutputFileName(this.inputFileName, '.o');\n        }\n        if (this.errorFlag) {\n          // console.error('Errors encountered during Pass 2.');\n          // Close the output file only if it's open\n          if (this.outFile !== null) {\n            fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].closeSync(this.outFile);\n          }\n          fatalExit('Errors encountered during Pass 2.', 1);\n        }\n\n        // **Resolve the start label to an address**\n        if (this.startLabel !== null) {\n          if (this.symbolTable.hasOwnProperty(this.startLabel)) {\n            this.startAddress = this.symbolTable[this.startLabel];\n          } else {\n            // Note: as of 12/2024, LCC does not print any message for this case\n            //       and instead ignores undefined .start labels (but it shouldn't)\n            //       so this is a custom LCC.js behavior\n            this.error(\"Undefined label\"); // Undefined start label: ${this.startLabel}\n            fatalExit(\"Undefined label\", 1);\n          }\n        } else {\n          // If no .start directive, default start address is 0\n          this.startAddress = 0;\n        }\n\n        // **Write the output file after Pass 2**\n        this.writeOutputFile();\n\n        // After writing the output file, handle additional outputs\n        if (this.isObjectModule) {\n          // Get the userName using nameHandler\n          try {\n            this.userName = _utils_name_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].createNameFile(this.inputFileName);\n          } catch (error) {\n            console.error('Error handling name file:', error.message);\n            fatalExit('Error handling name file: ' + error.message, 1);\n          }\n          console.log(\"Output file \".concat(this.outputFileName, \" needs linking\"));\n\n          // Generate .lst and .bst files\n          var lstFileName = this.constructOutputFileName(this.inputFileName, '.lst');\n          var bstFileName = this.constructOutputFileName(this.inputFileName, '.bst');\n\n          // Generate content for .lst file\n          var lstContent = (0,_utils_genStats_js__WEBPACK_IMPORTED_MODULE_2__.generateBSTLSTContent)({\n            isBST: false,\n            assembler: this,\n            includeSourceCode: true,\n            userName: this.userName,\n            inputFileName: this.inputFileName,\n            includeComments: false // note: this flag is only for .bin files\n          });\n\n          // Generate content for .bst file\n          var bstContent = (0,_utils_genStats_js__WEBPACK_IMPORTED_MODULE_2__.generateBSTLSTContent)({\n            isBST: true,\n            assembler: this,\n            includeSourceCode: true,\n            userName: this.userName,\n            inputFileName: this.inputFileName,\n            includeComments: false // note: this flag is only for .bin files\n          });\n\n          // Write the .lst file\n          fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeFileSync(lstFileName, lstContent, 'utf-8');\n\n          // Write the .bst file\n          fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeFileSync(bstFileName, bstContent, 'utf-8');\n          console.log(\"lst file = \".concat(lstFileName));\n          console.log(\"bst file = \".concat(bstFileName));\n        }\n      } else {\n        // Note: Treating only .a files as valid assembly files is\n        //       a unique LCC.js behavior as of 12/2024 (the official\n        //       LCC behavior is to treat all non .bin, .hex, .o, and \n        //       .e files as assembly files)\n        if (extension === '.ap') {\n          console.error('Error: .ap files are not supported by assembler.js - Did you mean to use assemblerPlus.js?');\n          fatalExit('Error: .ap files are not supported by assembler.js - Did you mean to use assemblerPlus.js?', 1);\n        }\n        console.error('Unsupported file type');\n        fatalExit('Unsupported file type', 1);\n      }\n    }\n  }, {\n    key: \"writeOutputFile\",\n    value: function writeOutputFile() {\n      var secondIntroHeader = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      // Open the output file for writing\n      try {\n        this.outFile = fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].openSync(this.outputFileName, 'w');\n      } catch (err) {\n        console.error(\"Cannot open output file \".concat(this.outputFileName));\n        fatalExit(\"Cannot open output file \".concat(this.outputFileName), 1);\n      }\n\n      // Write the initial header 'o' to the output file\n      fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(this.outFile, 'o');\n\n      // Custom LCC.js behavior as of 12/2024:\n      // Write the second intro header if it is provided\n      // This enables extensions that need use special header entries\n      if (secondIntroHeader !== '') {\n        fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(this.outFile, secondIntroHeader);\n      }\n\n      // Collect all header entries\n      var headerEntries = [];\n\n      // Add 'S' entry if present\n      if (this.startLabel !== null && this.startAddress !== null) {\n        headerEntries.push({\n          type: 'S',\n          address: this.startAddress\n        });\n      }\n\n      // Collect 'G' entries\n      var _iterator = _createForOfIteratorHelper(this.globalLabels),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var label = _step.value;\n          var address = this.symbolTable[label];\n          headerEntries.push({\n            type: 'G',\n            address: address,\n            label: label\n          });\n        }\n\n        // Collect external references ('E', 'e', 'V')\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var _iterator2 = _createForOfIteratorHelper(this.externalReferences),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var ref = _step2.value;\n          headerEntries.push({\n            type: ref.type,\n            address: ref.address,\n            label: ref.label\n          });\n        }\n\n        // Collect 'A' entries\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var _iterator3 = _createForOfIteratorHelper(this.adjustmentEntries),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _address = _step3.value;\n          headerEntries.push({\n            type: 'A',\n            address: _address\n          });\n        }\n\n        // Now sort the header entries by address\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      headerEntries.sort(function (a, b) {\n        return a.address - b.address;\n      });\n\n      // Write the header entries\n      for (var _i = 0, _headerEntries = headerEntries; _i < _headerEntries.length; _i++) {\n        var entry = _headerEntries[_i];\n        switch (entry.type) {\n          case 'S':\n            {\n              var buffer = Buffer.alloc(3);\n              buffer.write('S', 0, 'ascii');\n              buffer.writeUInt16LE(entry.address, 1);\n              fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(this.outFile, buffer);\n              break;\n            }\n          case 'G':\n            {\n              var _buffer = Buffer.alloc(3 + entry.label.length + 1);\n              _buffer.write('G', 0, 'ascii');\n              _buffer.writeUInt16LE(entry.address, 1);\n              _buffer.write(entry.label, 3, 'ascii');\n              _buffer.writeUInt8(0, 3 + entry.label.length);\n              fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(this.outFile, _buffer);\n              break;\n            }\n          case 'E':\n          case 'e':\n          case 'V':\n            {\n              var _buffer2 = Buffer.alloc(3 + entry.label.length + 1);\n              _buffer2.write(entry.type, 0, 'ascii');\n              _buffer2.writeUInt16LE(entry.address, 1);\n              _buffer2.write(entry.label, 3, 'ascii');\n              _buffer2.writeUInt8(0, 3 + entry.label.length);\n              fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(this.outFile, _buffer2);\n              break;\n            }\n          case 'A':\n            {\n              var _buffer3 = Buffer.alloc(3);\n              _buffer3.write('A', 0, 'ascii');\n              _buffer3.writeUInt16LE(entry.address, 1);\n              fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(this.outFile, _buffer3);\n              break;\n            }\n          default:\n            // Should not reach here\n            this.error(\"invalid header entry error\");\n            break;\n        }\n      }\n\n      // Write the code start marker 'C'\n      fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(this.outFile, 'C');\n\n      // Write machine code words\n      var codeBuffer = Buffer.alloc(this.outputBuffer.length * 2);\n      for (var i = 0; i < this.outputBuffer.length; i++) {\n        codeBuffer.writeUInt16LE(this.outputBuffer[i], i * 2);\n      }\n      fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(this.outFile, codeBuffer);\n\n      // Close the output file\n      fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].closeSync(this.outFile);\n    }\n  }, {\n    key: \"constructOutputFileName\",\n    value: function constructOutputFileName(inputFileName, extension) {\n      var parsedPath = path__WEBPACK_IMPORTED_MODULE_1__.parse(inputFileName);\n      // Remove extension and add the specified extension\n      return path__WEBPACK_IMPORTED_MODULE_1__.format(_objectSpread(_objectSpread({}, parsedPath), {}, {\n        base: undefined,\n        ext: extension\n      }));\n    }\n\n    // validates that a label either starts at the beginning of a line\n    // or is terminated with a colon, or both\n  }, {\n    key: \"isValidLabelDef\",\n    value: function isValidLabelDef(tokens, originalLine) {\n      return tokens[0].endsWith(':') || !this.isWhitespace(originalLine[0]);\n    }\n\n    // validates that a label starts with a letter, _, $, or @, and is \n    // (optionally) followed by letters, digits, _, $, or @\n  }, {\n    key: \"isValidLabel\",\n    value: function isValidLabel(label) {\n      // Example pattern: starts with letter, _, $, @; followed by letters, digits, _, $, @\n      return /^[A-Za-z_$@][A-Za-z0-9_$@]*$/.test(label);\n    }\n\n    /*\r\n    * performPass currently handles multiple responsibilities:\r\n    * - Reading lines from the source file.\r\n    * - Tokenizing each line.\r\n    * - Handling labels, directives, and instructions.\r\n    * - Updating the location counter.\r\n    */\n  }, {\n    key: \"performPass\",\n    value: function performPass() {\n      // At the beginning of Pass 1\n      if (this.pass === 1) {\n        this.loadPoint = this.locCtr;\n      }\n      if (this.pass === 2) {\n        this.outputBuffer = [];\n      }\n      var _iterator4 = _createForOfIteratorHelper(this.sourceLines),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var line = _step4.value;\n          this.lineNum++;\n          var originalLine = line;\n          this.currentLine = originalLine; // Store current line for error reporting\n\n          // Create listing entry\n          var listingEntry = {\n            lineNum: this.lineNum,\n            locCtr: this.locCtr,\n            sourceLine: originalLine,\n            codeWords: [],\n            label: null,\n            mnemonic: null,\n            operands: [],\n            comment: ''\n          };\n          this.currentListingEntry = listingEntry;\n\n          // Extract the comment substring (everything after ';'), if any\n          var comment = '';\n          var semicolonIndex = line.indexOf(';');\n          if (semicolonIndex !== -1) {\n            // everything after ';'\n            comment = line.substring(semicolonIndex + 1).trim();\n          }\n          // Store the comment in the listing entry\n          listingEntry.comment = comment;\n\n          // Remove comments and trim whitespace\n          line = line.split(';')[0].trim();\n          if (line === '') {\n            // Empty line after removing comments\n            if (this.pass === 2) {\n              this.listing.push(listingEntry);\n            }\n            continue;\n          }\n\n          // Tokenize the line\n          var tokens = this.tokenizeLine(line);\n          if (tokens.length === 0) {\n            if (this.pass === 2) {\n              this.listing.push(listingEntry);\n            }\n            continue;\n          }\n          var label = null;\n          var mnemonic = null;\n          var operands = [];\n\n          // console.log(\"Tokens: \", tokens);\n\n          // Check if line starts with a label\n          if (tokens.length > 0 && this.isValidLabelDef(tokens, originalLine)) {\n            // Remove the trailing colon from the label if the colon exists\n            label = tokens.shift();\n            if (label.endsWith(':')) {\n              label = label.slice(0, -1);\n            }\n            if (!this.isValidLabel(label)) {\n              this.error(\"Bad label\"); // `Invalid label format: ${label}`\n            }\n            if (this.pass === 1) {\n              if (this.labels.has(label)) {\n                this.error(\"Duplicate label\"); // `Duplicate label: ${label}`\n              } else {\n                this.symbolTable[label] = this.locCtr;\n                this.labels.add(label);\n              }\n            }\n          }\n          if (tokens.length > 0) {\n            mnemonic = tokens.shift().toLowerCase();\n          } else {\n            if (this.pass === 2) {\n              this.listing.push(listingEntry);\n            }\n            continue; // No mnemonic, skip line\n          }\n          operands = tokens;\n\n          // Update listingEntry\n          listingEntry.label = label;\n          listingEntry.mnemonic = mnemonic;\n          listingEntry.operands = operands;\n\n          // Handle directives and instructions\n          if (mnemonic.startsWith('.')) {\n            // Directive\n            this.handleDirective(mnemonic, operands);\n          } else {\n            // Instruction\n            this.handleInstruction(mnemonic, operands);\n          }\n          if (this.locCtr > 65536) {\n            this.error('Program too big');\n            return;\n          }\n\n          // At the end of processing the line\n          if (this.pass === 2) {\n            this.listing.push(listingEntry);\n          }\n        }\n\n        // At the end of Pass 2\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      if (this.pass === 2) {\n        this.programSize = this.locCtr - this.loadPoint;\n\n        //// possible bug/strange lcc behavior:\n        //// remove a single empty line from the listing\n        //// if it is the last line\n        // console.log(\"last line of file is: '\", this.listing[this.listing.length - 1], \"'\");\n        if (this.listing[this.listing.length - 1].sourceLine.trim() === '') {\n          this.listing.pop();\n        }\n      }\n    }\n  }, {\n    key: \"parseHexFile\",\n    value: function parseHexFile() {\n      this.outputBuffer = [];\n      this.locCtr = 0;\n      this.loadPoint = 0;\n      for (var lineNum = 0; lineNum < this.sourceLines.length; lineNum++) {\n        this.lineNum++;\n        var line = this.sourceLines[lineNum];\n        this.currentLine = line; // For error messages\n\n        var listingEntry = {\n          lineNum: this.lineNum,\n          locCtr: this.locCtr,\n          sourceLine: line,\n          macWord: '',\n          comment: ''\n        };\n\n        // Extract the comment substring (everything after ';'), if any\n        var comment = '';\n        var semicolonIndex = line.indexOf(';');\n        if (semicolonIndex !== -1) {\n          // everything after ';'\n          comment = line.substring(semicolonIndex + 1).trim();\n        }\n        // Store the comment in the listing entry\n        listingEntry.comment = comment;\n\n        // Remove everything after semicolon\n        if (line.indexOf(';') !== -1) {\n          line = line.substring(0, line.indexOf(';'));\n        }\n        // Trim and remove all internal spaces\n        line = line.trim().replace(/\\s+/g, '');\n        if (line.length === 0) {\n          continue; // empty or comment-only line\n        }\n\n        // Now we should have a 16-bit hexadecimal string\n        // For example: \"4B1F\"\n        if (!/^[0-9A-Fa-f]+$/.test(line)) {\n          console.error(\"Error: line \".concat(lineNum + 1, \" in .hex file is not purely hexadecimal: \\\"\").concat(line, \"\\\"\"));\n          fatalExit(\"Error: line \".concat(lineNum + 1, \" in .hex file is not purely hexadecimal: \\\"\").concat(line, \"\\\"\"), 1);\n        }\n        if (line.length !== 4) {\n          console.error(\"Error: line \".concat(lineNum + 1, \" in .hex file does not have exactly 4 nibbles: \\\"\").concat(line, \"\\\"\"));\n          fatalExit(\"Error: line \".concat(lineNum + 1, \" in .hex file does not have exactly 4 nibbles: \\\"\").concat(line, \"\\\"\"), 1);\n        }\n\n        // Convert the binary string to a number\n        var wordValue = parseInt(line, 16);\n\n        // Push the parsed word into outputBuffer\n        this.outputBuffer.push(wordValue & 0xFFFF);\n        this.locCtr++;\n\n        // Store the machine word in the listing entry\n        listingEntry.macWord = wordValue;\n\n        // Store the listing entry\n        this.listing.push(listingEntry);\n      }\n\n      // Note: Reporting an empty hex file is custom LCC.js behavior in 12/2024\n      //       (this does not match current official LCC behavior)\n      if (this.locCtr === 0) {\n        console.error('Empty file');\n        fatalExit('Empty file', 0); // No instructions or data found in source file\n      }\n\n      // If you want a \"startAddress = 0\" by default, do that here\n      this.startAddress = 0; // or your choice\n      this.startLabel = null; // No .start directive in raw hex files\n    }\n  }, {\n    key: \"parseBinFile\",\n    value: function parseBinFile() {\n      this.outputBuffer = []; // Prepare output buffer\n      this.locCtr = 0;\n      this.loadPoint = 0; // TODO: fix this to not be hardcoded, because flags may dictate where in memory the program starts\n      for (var lineNum = 0; lineNum < this.sourceLines.length; lineNum++) {\n        this.lineNum++;\n        var line = this.sourceLines[lineNum];\n        this.currentLine = line; // For error messages\n\n        var listingEntry = {\n          lineNum: this.lineNum,\n          locCtr: this.locCtr,\n          sourceLine: line,\n          macWord: '',\n          comment: ''\n        };\n\n        // Extract the comment substring (everything after ';'), if any\n        var comment = '';\n        var semicolonIndex = line.indexOf(';');\n        if (semicolonIndex !== -1) {\n          // everything after ';'\n          comment = line.substring(semicolonIndex + 1).trim();\n        }\n        // Store the comment in the listing entry\n        listingEntry.comment = comment;\n\n        // Remove everything after semicolon\n        if (line.indexOf(';') !== -1) {\n          line = line.substring(0, line.indexOf(';'));\n        }\n        // Trim and remove all internal spaces\n        line = line.trim().replace(/\\s+/g, '');\n        if (line.length === 0) {\n          continue; // empty or comment-only line\n        }\n\n        // Now we should have a 16-bit binary string\n        // For example: \"0010000000000101\"\n        if (!/^[01]+$/.test(line)) {\n          console.error(\"Error: line \".concat(lineNum + 1, \" in .bin file is not purely binary: \\\"\").concat(line, \"\\\"\"));\n          fatalExit(\"Error: line \".concat(lineNum + 1, \" in .bin file is not purely binary: \\\"\").concat(line, \"\\\"\"), 1);\n        }\n        if (line.length !== 16) {\n          console.error(\"Error: line \".concat(lineNum + 1, \" in .bin file does not have exactly 16 bits: \\\"\").concat(line, \"\\\"\"));\n          fatalExit(\"Error: line \".concat(lineNum + 1, \" in .bin file does not have exactly 16 bits: \\\"\").concat(line, \"\\\"\"), 1);\n        }\n\n        // Convert the binary string to a number\n        var wordValue = parseInt(line, 2);\n\n        // Push the parsed word into outputBuffer\n        this.outputBuffer.push(wordValue & 0xFFFF);\n        this.locCtr++;\n\n        // Store the machine word in the listing entry\n        listingEntry.macWord = wordValue;\n\n        // Store the listing entry\n        this.listing.push(listingEntry);\n      }\n\n      // Note: The reporting of an empty bin file is custom LCC.js behavior in 12/2024\n      //       (it does not currently match official LCC behavior)\n      if (this.locCtr === 0) {\n        console.error('Empty file');\n        fatalExit('Empty file', 0); // No instructions or data found in source file\n      }\n\n      // If you want a \"startAddress = 0\" by default, do that here\n      this.startAddress = 0; // or your choice\n      this.startLabel = null; // No .start directive in raw bin files\n    }\n  }, {\n    key: \"tokenizeLine\",\n    value: function tokenizeLine(line) {\n      var tokens = [];\n      var currentToken = '';\n      var inString = false;\n      var stringDelimiter = '';\n      var escape = false; // Flag to indicate escape character\n\n      for (var i = 0; i < line.length; i++) {\n        var _char = line[i];\n        if (!inString) {\n          if (_char === '\"' || _char === \"'\") {\n            inString = true;\n            stringDelimiter = _char;\n            currentToken += _char;\n          } else if (this.isWhitespace(_char)) {\n            if (currentToken !== '') {\n              tokens.push(currentToken);\n              currentToken = '';\n            }\n          } else if (_char === ',' && !inString) {\n            if (currentToken !== '') {\n              tokens.push(currentToken);\n              currentToken = '';\n            }\n          } else if (_char === ':') {\n            if (currentToken !== '') {\n              currentToken += _char;\n              tokens.push(currentToken);\n              currentToken = '';\n            }\n            // Ignore colon\n          } else {\n            currentToken += _char;\n          }\n        } else {\n          currentToken += _char;\n          if (escape) {\n            escape = false; // Reset escape flag\n            continue;\n          }\n          if (_char === '\\\\') {\n            escape = true; // Next character is escaped\n          } else if (_char === stringDelimiter) {\n            inString = false;\n            tokens.push(currentToken);\n            currentToken = '';\n          }\n        }\n      }\n      if (currentToken !== '') {\n        tokens.push(currentToken);\n      }\n      return tokens;\n    }\n  }, {\n    key: \"isWhitespace\",\n    value: function isWhitespace(_char2) {\n      return /\\s/.test(_char2);\n    }\n  }, {\n    key: \"isStringLiteral\",\n    value: function isStringLiteral(str) {\n      return /^\"(.*)\"$/.test(str) || /^'(.*)'$/.test(str);\n    }\n  }, {\n    key: \"parseString\",\n    value: function parseString(str) {\n      var result = '';\n      for (var i = 0; i < str.length; i++) {\n        if (str[i] === '\\\\') {\n          i++; // Move to the next character to check the escape sequence\n          if (i >= str.length) {\n            this.error(\"Missing terminating quote\");\n            fatalExit(\"Missing terminating quote\", 1);\n          }\n          switch (str[i]) {\n            case 'n':\n              result += '\\n';\n              break;\n            case 't':\n              result += '\\t';\n              break;\n            case '\\\\':\n              result += '\\\\';\n              break;\n            case '\"':\n              result += '\"';\n              break;\n            case 'r':\n              result += '\\r';\n              break;\n            // Add more escape sequences as needed\n            default:\n              this.error(\"Unknown escape sequence: \\\\\".concat(str[i]));\n              return null;\n          }\n        } else {\n          result += str[i];\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"handleDirective\",\n    value: function handleDirective(mnemonic, operands) {\n      mnemonic = mnemonic.toLowerCase();\n      switch (mnemonic) {\n        case '.start':\n          if (operands[0] === null || operands[0] === undefined) {\n            this.error(\"Missing operand\");\n            fatalExit(\"Missing operand\", 1);\n          }\n          if (!this.isValidLabel(operands[0])) {\n            this.error(\"Bad operand--not a valid label\");\n            fatalExit(\"Bad operand--not a valid label\", 1);\n          }\n          this.startLabel = operands[0];\n          // Note: startAddress will be resolved after Pass 2 when all symbols are known\n          break;\n        case '.org':\n          this.error(\"This directive hasn't yet been implemented\");\n          fatalExit(\"This directive hasn't yet been implemented\", 1);\n          break;\n        case '.globl':\n        case '.global':\n          if (operands[0] === null || operands[0] === undefined) {\n            this.error(\"Missing operand\");\n            fatalExit(\"Missing operand\", 1);\n          }\n          if (!this.isValidLabel(operands[0])) {\n            this.error(\"Bad operand--not a valid label\");\n            fatalExit(\"Bad operand--not a valid label\", 1);\n          }\n          this.isObjectModule = true; // Set flag to produce .o file\n          var globalLabel = operands[0];\n          if (this.pass === 1) {\n            // Record the address of the global label\n            if (!this.symbolTable.hasOwnProperty(globalLabel)) {\n              this.symbolTable[globalLabel] = this.locCtr;\n            }\n            this.globalLabels.add(globalLabel);\n          }\n          break;\n        case '.extern':\n          if (operands[0] === null || operands[0] === undefined) {\n            this.error(\"Missing operand\");\n            fatalExit(\"Missing operand\", 1);\n          }\n          if (!this.isValidLabel(operands[0])) {\n            this.error(\"Bad operand--not a valid label\");\n            fatalExit(\"Bad operand--not a valid label\", 1);\n          }\n          this.isObjectModule = true; // Set flag to produce .o file\n          var externLabel = operands[0];\n          this.externLabels.add(externLabel);\n          break;\n        case '.blkw':\n        case '.space':\n        case '.zero':\n          if (operands[0] === null || operands[0] === undefined) {\n            this.error(\"Missing operand\");\n            fatalExit(\"Missing operand\", 1);\n          }\n          var num = parseInt(operands[0], 10);\n          if (isNaN(num)) {\n            this.error(\"Bad number\");\n            fatalExit(\"Bad number\", 1);\n          }\n\n          // Note: in the original LCC (as of 12/2024), the .zero directive arguments\n          // are not checked for negativity, so this currently is a custom LCC.js behavior\n          if (num < 1 || num > 65536 - this.locCtr) {\n            this.error(\"Bad number\");\n            fatalExit(\"Bad number\", 1);\n          }\n          if (this.pass === 2) {\n            for (var i = 0; i < num; i++) {\n              this.writeMachineWord(0);\n            }\n          }\n          this.locCtr += num;\n          break;\n        case '.fill':\n        case '.word':\n          if (operands[0] === null || operands[0] === undefined) {\n            this.error(\"Missing operand\");\n            fatalExit(\"Missing operand\", 1);\n          }\n          if (this.isOperator(operands[0]) && (operands[1] === null || operands[1] === undefined)) {\n            this.error(\"Missing operand\");\n            fatalExit(\"Missing operand\", 1);\n          }\n\n          // if (operands.length !== 1 && operands.length !== 3) {\n          //// TODO: inspect to make sure that .word can handle .word x, .word x+1, and .word x + 1\n          //// TODO: inspect to make sure that .word can handle .word x+ 1 and .word x +1\n          //// TODO: inspect to make sure that .word behaves as expected with .word x + 1 + 1\n          //// TODO: inspect to make sure that .word behaves as expected with .word <NOTHING>\n          //// TODO: inspect to make sure that .word behaves as expected with .word + or .word -\n          // this.error(`Invalid operand count for ${mnemonic}`);\n          // return;\n          // }\n\n          if (this.pass === 2) {\n            var label = operands[0];\n\n            // if not a number castable literal, then operands[0] is a label\n            if (!this.isNumLiteral(operands[0]) && operands[1] && operands[2]) {\n              // if operands[2] is not a literal value, then it isn't a valid offset\n              if (!this.isNumLiteral(operands[2])) {\n                this.error(\"Bad number\"); // : ${operands[2]}\n                fatalExit('Bad number', 1);\n              }\n              label = operands[0] + operands[1] + operands[2];\n            }\n            if (operands[1] && this.isOperator(operands[1]) && (operands[2] === null || operands[2] === undefined)) {\n              this.error('Missing number');\n              fatalExit('Missing number', 1);\n            }\n            var value = this.evaluateOperand(label, 'V'); // Pass 'V' as usageType\n            if (value === null) {\n              this.error(\"Bad number\"); // : ${value}\n              fatalExit('Bad number', 1);\n            }\n            ;\n\n            // see if operand is label +/- offset\n            var parsed = this.parseLabelWithOffset(label);\n            if (parsed && this.symbolTable.hasOwnProperty(parsed.label)) {\n              // It's a local label with offset, so record an A-entry\n              this.handleAdjustmentEntry(this.locCtr);\n            }\n            if (parsed && (parsed.offset > 65535 || parsed.offset < -32768)) {\n              this.error(\"Bad number\"); // 'Data does not fit in 16 bits' // : ${parsed.offset}\n              fatalExit('Bad number', 1); // 'Data does not fit in 16 bits'\n            }\n            this.writeMachineWord(value & 0xFFFF);\n          }\n          this.locCtr += 1;\n          break;\n        case '.stringz':\n        case '.asciz':\n        case '.string':\n          if (operands[0] === null || operands[0] === undefined) {\n            this.error(\"Missing operand\");\n            fatalExit(\"Missing operand\", 1);\n          }\n          var strOperand = operands[0];\n          if (strOperand && strOperand.length > 0) {\n            if (strOperand[0] !== '\"') {\n              this.error(\"String constant missing leading quote\");\n              fatalExit(\"String constant missing leading quote\", 1);\n            }\n          }\n          if (!this.isStringLiteral(strOperand)) {\n            this.error(\"Missing terminating quote\");\n            fatalExit(\"Missing terminating quote\", 1);\n          }\n          // Extract the string without quotes\n          var strContent = strOperand.slice(1, -1);\n          strContent = this.parseString(strContent);\n          if (this.pass === 1) {\n            // Update location counter: length of string + 1 for null terminator\n            this.locCtr += strContent.length + 1;\n          } else if (this.pass === 2) {\n            // Write each character's ASCII code to output\n            for (var _i2 = 0; _i2 < strContent.length; _i2++) {\n              var asciiValue = strContent.charCodeAt(_i2);\n              this.writeMachineWord(asciiValue);\n              this.locCtr += 1; // Increment locCtr after writing each word\n            }\n            // Write null terminator\n            this.writeMachineWord(0);\n            this.locCtr += 1; // Increment locCtr for null terminator\n          }\n          break;\n        default:\n          this.error(\"Invalid operation\"); // Invalid directive: ${mnemonic}\n          fatalExit(\"Invalid operation\", 1);\n          break;\n      }\n    }\n  }, {\n    key: \"handleInstruction\",\n    value: function handleInstruction(mnemonic, operands) {\n      if (this.pass === 1) {\n        this.locCtr += 1;\n        return;\n      }\n      var machineWord = null;\n      mnemonic = mnemonic.toLowerCase();\n      switch (mnemonic) {\n        case 'br':\n        case 'bral':\n        case 'brz':\n        case 'bre':\n        case 'brnz':\n        case 'brne':\n        case 'brn':\n        case 'brp':\n        case 'brlt':\n        case 'brgt':\n        case 'brc':\n          machineWord = this.assembleBR(mnemonic, operands);\n          break;\n        case 'add':\n          machineWord = this.assembleADD(operands);\n          break;\n        case 'sub':\n          machineWord = this.assembleSUB(operands);\n          break;\n        case 'cmp':\n          machineWord = this.assembleCMP(operands);\n          break;\n        case 'mov':\n        case 'mvi':\n        case 'mvr':\n          machineWord = this.assembleMOV(mnemonic, operands);\n          break;\n        case 'push':\n          machineWord = this.assemblePUSH(operands);\n          break;\n        case 'pop':\n          machineWord = this.assemblePOP(operands);\n          break;\n        case 'srl':\n          machineWord = this.assembleSRL(operands);\n          break;\n        case 'sra':\n          machineWord = this.assembleSRA(operands);\n          break;\n        case 'sll':\n          machineWord = this.assembleSLL(operands);\n          break;\n        case 'rol':\n          machineWord = this.assembleROL(operands);\n          break;\n        case 'ror':\n          machineWord = this.assembleROR(operands);\n          break;\n        case 'mul':\n          machineWord = this.assembleMUL(operands);\n          break;\n        case 'div':\n          machineWord = this.assembleDIV(operands);\n          break;\n        case 'rem':\n          machineWord = this.assembleREM(operands);\n          break;\n        case 'or':\n          machineWord = this.assembleOR(operands);\n          break;\n        case 'xor':\n          machineWord = this.assembleXOR(operands);\n          break;\n        // mvr case is handled in the mov function\n        case 'sext':\n          machineWord = this.assembleSEXT(operands);\n          break;\n        case 'ld':\n          machineWord = this.assembleLD(operands);\n          break;\n        case 'st':\n          machineWord = this.assembleST(operands);\n          break;\n        case 'call':\n        case 'jsr':\n        case 'bl':\n          machineWord = this.assembleBL(operands);\n          break;\n        case 'jsrr':\n        case 'blr':\n          machineWord = this.assembleBLR(operands);\n          break;\n        case 'and':\n          machineWord = this.assembleAND(operands);\n          break;\n        case 'ldr':\n          machineWord = this.assembleLDR(operands);\n          break;\n        case 'str':\n          machineWord = this.assembleSTR(operands);\n          break;\n        case 'jmp':\n          machineWord = this.assembleJMP(operands);\n          break;\n        case 'ret':\n          machineWord = this.assembleRET(operands);\n          break;\n        case 'not':\n          machineWord = this.assembleNOT(operands);\n          break;\n        case 'lea':\n          machineWord = this.assembleLea(operands);\n          break;\n        case 'cea':\n          machineWord = this.assembleCEA(operands);\n          break;\n        case 'halt':\n          machineWord = 0xF000;\n          break;\n        case 'nl':\n          machineWord = 0xF001;\n          break;\n        case 'dout':\n          machineWord = this.assembleTrap(operands, 0x0002);\n          break;\n        case 'udout':\n          machineWord = this.assembleTrap(operands, 0x0003);\n          break;\n        case 'hout':\n          machineWord = this.assembleTrap(operands, 0x0004);\n          break;\n        case 'aout':\n          machineWord = this.assembleTrap(operands, 0x0005);\n          break;\n        case 'sout':\n          machineWord = this.assembleTrap(operands, 0x0006); // Trap vector for sout is 6\n          break;\n        case 'din':\n          machineWord = this.assembleTrap(operands, 0x0007); // Trap vector for din is 7\n          break;\n        case 'hin':\n          machineWord = this.assembleTrap(operands, 0x0008); // Trap vector for hin is 8\n          break;\n        case 'ain':\n          machineWord = this.assembleTrap(operands, 0x0009); // Trap vector for ain is 9\n          break;\n        case 'sin':\n          machineWord = this.assembleTrap(operands, 0x000A); // Trap vector for sin is 10\n          break;\n        case 'm':\n          machineWord = this.assembleTrap(operands, 0x000B); // Trap vector for m is 11\n          break;\n        case 'r':\n          machineWord = this.assembleTrap(operands, 0x000C); // Trap vector for r is 12\n          break;\n        case 's':\n          machineWord = this.assembleTrap(operands, 0x000D); // Trap vector for s is 13\n          break;\n        case 'bp':\n          machineWord = this.assembleTrap(operands, 0x000E); // Trap vector for bp is 14\n          break;\n        default:\n          this.error(\"Invalid operation\"); // this.error(`Invalid mnemonic or directive: ${mnemonic}`);\n          return;\n      }\n      if (machineWord !== null) {\n        this.writeMachineWord(machineWord);\n        this.locCtr += 1;\n      }\n    }\n  }, {\n    key: \"writeMachineWord\",\n    value: function writeMachineWord(word) {\n      if (this.pass === 2) {\n        this.outputBuffer.push(word & 0xFFFF); // Ensure 16-bit word\n        if (this.currentListingEntry) {\n          this.currentListingEntry.codeWords.push(word & 0xFFFF);\n        }\n      }\n    }\n  }, {\n    key: \"assembleCMP\",\n    value: function assembleCMP(operands) {\n      var sr1 = this.getRegister(operands[0]);\n      if (sr1 === null) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      ;\n      var sr2orImm5 = operands[1];\n      if (sr2orImm5 === null) return null;\n      var macword = 0x8000;\n      if (!this.isRegister(sr2orImm5)) {\n        // compare with immediate\n        var imm5 = this.evaluateImmediate(sr2orImm5, -16, 15, \"imm5\"); //// TODO: test bounds, see if input is naive or not\n        macword = macword | sr1 << 6 | imm5 & 0x1F | 0x0020;\n      } else {\n        // compare with register\n        var sr2 = this.getRegister(sr2orImm5);\n        if (sr2 === null) return null;\n        macword = macword | sr1 << 6 | sr2 & 0x3;\n      }\n      return macword;\n    }\n  }, {\n    key: \"assembleBR\",\n    value: function assembleBR(mnemonic, operands) {\n      var codes = {\n        'brz': 0,\n        'bre': 0,\n        'brnz': 1,\n        'brne': 1,\n        'brn': 2,\n        'brp': 3,\n        'brlt': 4,\n        'brgt': 5,\n        'brc': 6,\n        'brb': 6,\n        'br': 7,\n        'bral': 7\n      };\n      var macword = codes[mnemonic.toLowerCase()] << 9 & 0xffff;\n      var label = operands[0];\n      if (label === null || label === undefined) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      if (!this.isNumLiteral(operands[0]) && operands[1] && operands[2]) {\n        // if operands[2] is not a literal value, then it isn't a valid offset\n        if (!this.isNumLiteral(operands[2])) {\n          this.error('Bad number');\n          fatalExit('Bad number', 1);\n        }\n        label = operands[0] + operands[1] + operands[2];\n      }\n      if (operands[1] && this.isOperator(operands[1]) && (operands[2] === null || operands[2] === undefined)) {\n        this.error('Missing number');\n        fatalExit('Missing number', 1);\n      }\n      var address = this.evaluateOperand(label, 'e');\n      if (address === null) {\n        this.error('Bad label'); // TODO: verify this is correct via cross testing w/ LCC\n        fatalExit('Bad label', 1);\n      }\n      ;\n      var pcoffset9 = address - this.locCtr - 1;\n      if (pcoffset9 < -256 || pcoffset9 > 255) {\n        this.error('pcoffset9 out of range'); // for branch instruction\n        return null;\n      }\n      macword |= pcoffset9 & 0x01FF;\n      return macword;\n    }\n  }, {\n    key: \"assembleADD\",\n    value: function assembleADD(operands) {\n      var dr = this.getRegister(operands[0]);\n      var sr1 = this.getRegister(operands[1]);\n      if (dr === null || sr1 === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var sr2orImm5 = operands[2];\n      if (sr2orImm5 === null || sr2orImm5 === undefined) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      var macword = 0x1000 | dr << 9 | sr1 << 6;\n      if (this.isRegister(sr2orImm5)) {\n        var sr2 = this.getRegister(sr2orImm5);\n        macword |= sr2;\n      } else {\n        var imm5 = this.evaluateImmediate(sr2orImm5, -16, 15, \"imm5\");\n        if (imm5 === null) {\n          this.error('Bad number');\n          fatalExit('Bad number', 1);\n        }\n        ;\n        macword |= 0x0020 | imm5 & 0x1F;\n      }\n      return macword;\n    }\n  }, {\n    key: \"assembleCEA\",\n    value: function assembleCEA(operands) {\n      var dr = operands[0];\n      var imm5op = operands[1];\n      return this.assembleADD([dr, 'fp', imm5op]);\n    }\n  }, {\n    key: \"assembleSUB\",\n    value: function assembleSUB(operands) {\n      var dr = this.getRegister(operands[0]);\n      var sr1 = this.getRegister(operands[1]);\n      if (dr === null || sr1 === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      var sr2orImm5 = operands[2];\n      var macword = 0xB000 | dr << 9 | sr1 << 6;\n      if (this.isRegister(sr2orImm5)) {\n        var sr2 = this.getRegister(sr2orImm5);\n        macword |= sr2;\n      } else {\n        var imm5 = this.evaluateImmediate(sr2orImm5, -16, 15, 'imm5');\n        if (imm5 === null) {\n          this.error('Bad number');\n          fatalExit('Bad number', 1);\n        }\n        ;\n        macword |= 0x0020 | imm5 & 0x1F;\n      }\n      return macword;\n    }\n  }, {\n    key: \"assemblePUSH\",\n    value: function assemblePUSH(operands) {\n      var sr = this.getRegister(operands[0]);\n      if (sr === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var macword = 0xA000 | sr << 9;\n      return macword;\n    }\n  }, {\n    key: \"assemblePOP\",\n    value: function assemblePOP(operands) {\n      var dr = this.getRegister(operands[0]);\n      if (dr === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var macword = 0xA000 | dr << 9 | 0x0001;\n      return macword;\n    }\n  }, {\n    key: \"assembleDIV\",\n    value: function assembleDIV(operands) {\n      var dr = this.getRegister(operands[0]);\n      var sr1 = this.getRegister(operands[1]);\n      if (dr === null || sr1 === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var macword = 0xa008 | dr << 9 | sr1 << 6;\n      return macword;\n    }\n  }, {\n    key: \"assembleROL\",\n    value: function assembleROL(operands) {\n      var sr = this.getRegister(operands[0]);\n      if (sr === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var ct = null;\n      if (operands[1]) ct = this.evaluateImmediateNaive(operands[1]);\n      if (ct === null) ct = 1;\n      var macword = 0xA000 | sr << 9 | ct << 5 | 0x0005;\n      return macword;\n    }\n  }, {\n    key: \"assembleMUL\",\n    value: function assembleMUL(operands) {\n      var dr = this.getRegister(operands[0]);\n      var sr1 = this.getRegister(operands[1]);\n      if (dr === null || sr1 === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var macword = 0xA000 | dr << 9 | sr1 << 6 | 0x0007;\n      return macword;\n    }\n  }, {\n    key: \"assembleREM\",\n    value: function assembleREM(operands) {\n      var dr = this.getRegister(operands[0]);\n      var sr1 = this.getRegister(operands[1]);\n      if (dr === null || sr1 === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      var macword = 0xA000 | dr << 9 | sr1 << 6 | 0x0009;\n      return macword;\n    }\n  }, {\n    key: \"assembleOR\",\n    value: function assembleOR(operands) {\n      var dr = this.getRegister(operands[0]);\n      var sr1 = this.getRegister(operands[1]);\n      if (dr === null || sr1 === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      var macword = 0xA000 | dr << 9 | sr1 << 6 | 0x000A;\n      return macword;\n    }\n  }, {\n    key: \"assembleXOR\",\n    value: function assembleXOR(operands) {\n      var dr = this.getRegister(operands[0]);\n      var sr1 = this.getRegister(operands[1]);\n      if (dr === null || sr1 === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      var macword = 0xA000 | dr << 9 | sr1 << 6 | 0x000B;\n      return macword;\n    }\n  }, {\n    key: \"assembleSEXT\",\n    value: function assembleSEXT(operands) {\n      var dr = this.getRegister(operands[0]);\n      var sr1 = this.getRegister(operands[1]);\n      if (dr === null || sr1 === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var macword = 0xA000 | dr << 9 | sr1 << 6 | 0x000D;\n      return macword;\n    }\n  }, {\n    key: \"assembleROR\",\n    value: function assembleROR(operands) {\n      var sr = this.getRegister(operands[0]);\n      if (sr === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var ct = null;\n      if (operands[1]) ct = this.evaluateImmediateNaive(operands[1]);\n      if (ct === null) ct = 1;\n      var macword = 0xA000 | sr << 9 | ct << 5 | 0x0006;\n      return macword;\n    }\n  }, {\n    key: \"assembleSRL\",\n    value: function assembleSRL(operands) {\n      var sr = this.getRegister(operands[0]);\n      if (sr === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var ct = null;\n      if (operands[1]) ct = this.evaluateImmediateNaive(operands[1]);\n      if (ct === null) ct = 1;\n      var macword = 0xA000 | sr << 9 | ct << 5 | 0x0002;\n      return macword;\n    }\n  }, {\n    key: \"assembleSRA\",\n    value: function assembleSRA(operands) {\n      var sr = this.getRegister(operands[0]);\n      if (sr === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var ct = null;\n      if (operands[1]) ct = this.evaluateImmediate(operands[1], 0, 15); //// TODO: test bounds, see if input is naive or not\n      if (ct === null) ct = 1;\n      var macword = 0xA000 | sr << 9 | ct << 5 | 0x0003;\n      return macword;\n    }\n  }, {\n    key: \"assembleSLL\",\n    value: function assembleSLL(operands) {\n      var sr = this.getRegister(operands[0]);\n      if (sr === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var ct = null;\n      if (operands[1]) ct = this.evaluateImmediateNaive(operands[1]);\n      if (ct === null) ct = 1;\n      var macword = 0xA000 | sr << 9 | ct << 5 | 0x0004;\n      return macword;\n    }\n  }, {\n    key: \"assembleAND\",\n    value: function assembleAND(operands) {\n      var dr = this.getRegister(operands[0]);\n      var sr1 = this.getRegister(operands[1]);\n      if (dr === null || sr1 === null) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      ;\n      var sr2orImm5 = operands[2];\n      var macword = 0x5000 | dr << 9 | sr1 << 6;\n      if (this.isRegister(sr2orImm5)) {\n        var sr2 = this.getRegister(sr2orImm5);\n        macword |= sr2;\n      } else {\n        var imm5 = this.evaluateImmediate(sr2orImm5, -16, 15, 'imm5'); //// TODO: test bounds, see if input is naive or not\n        if (imm5 === null || imm5 === undefined) {\n          this.error('Bad number');\n          fatalExit('Bad number', 1);\n        }\n        ;\n        macword |= 0x0020 | imm5 & 0x1F;\n      }\n      return macword;\n    }\n  }, {\n    key: \"assembleLD\",\n    value: function assembleLD(operands) {\n      var dr = this.getRegister(operands[0]);\n      if (dr === null) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      ;\n      var label = operands[1];\n      if (label === null || label === undefined) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      if (!this.isNumLiteral(operands[1]) && operands[2] && operands[3]) {\n        // if operands[2] is not a literal value, then it isn't a valid offset\n        if (!this.isNumLiteral(operands[3])) {\n          this.error('Bad number');\n          fatalExit('Bad number', 1);\n        }\n        label = operands[1] + operands[2] + operands[3];\n      }\n      if (operands[2] && this.isOperator(operands[2]) && (operands[3] === null || operands[3] === undefined)) {\n        this.error('Missing number');\n        fatalExit('Missing number', 1);\n      }\n      var address = this.evaluateOperand(label, 'e'); // Pass 'e' as usageType\n      if (address === null) {\n        this.error('Bad label');\n        fatalExit('Bad label', 1);\n      }\n      ;\n      var isExternal = this.externLabels.has(label);\n      var pcoffset9;\n      if (isExternal) {\n        pcoffset9 = 0; // Placeholder offset\n        // Do NOT add an 'A' entry here\n      } else {\n        pcoffset9 = address - this.locCtr - 1;\n        if (pcoffset9 < -256 || pcoffset9 > 255) {\n          this.error('pcoffset9 out of range for ld');\n          return null;\n        }\n      }\n      var macword = 0x2000 | dr << 9 | pcoffset9 & 0x1FF;\n      return macword;\n    }\n  }, {\n    key: \"assembleST\",\n    value: function assembleST(operands) {\n      var sr = this.getRegister(operands[0]);\n      if (sr === null) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      ;\n      var label = operands[1];\n      if (label === null || label === undefined) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      if (!this.isNumLiteral(operands[1]) && operands[2] && operands[3]) {\n        // if operands[2] is not a literal value, then it isn't a valid offset\n        if (!this.isNumLiteral(operands[3])) {\n          this.error('Bad number');\n          fatalExit('Bad number', 1);\n        }\n        label = operands[1] + operands[2] + operands[3];\n      }\n      if (operands[2] && this.isOperator(operands[2]) && (operands[3] === null || operands[3] === undefined)) {\n        this.error('Missing number');\n        fatalExit('Missing number', 1);\n      }\n      var address = this.evaluateOperand(label, 'e'); // Pass 'e' as usageType\n      if (address === null) {\n        this.error('Bad label');\n        fatalExit('Bad label', 1);\n      }\n      ;\n      var pcoffset9 = address - this.locCtr - 1;\n      if (pcoffset9 < -256 || pcoffset9 > 255) {\n        this.error('pcoffset9 out of range for st');\n        return null;\n      }\n      var macword = 0x3000 | sr << 9 | pcoffset9 & 0x1FF;\n      return macword;\n    }\n  }, {\n    key: \"assembleLea\",\n    value: function assembleLea(operands) {\n      var dr = this.getRegister(operands[0]);\n      if (dr === null) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      ;\n      var label = operands[1];\n      if (label === null || label === undefined) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      if (!this.isNumLiteral(operands[1]) && operands[2] && operands[3]) {\n        // if operands[2] is not a literal value, then it isn't a valid offset\n        if (!this.isNumLiteral(operands[3])) {\n          this.error('Bad number');\n          fatalExit('Bad number', 1);\n        }\n        label = operands[1] + operands[2] + operands[3];\n      }\n      if (operands[2] && this.isOperator(operands[2]) && (operands[3] === null || operands[3] === undefined)) {\n        this.error('Missing number');\n        fatalExit('Missing number', 1);\n      }\n      var address = this.evaluateOperand(label, 'e');\n      if (address === null) {\n        this.error('Bad label');\n        fatalExit('Bad label', 1);\n      }\n      ;\n      var pcoffset9 = address - this.locCtr - 1;\n      if (pcoffset9 < -256 || pcoffset9 > 255) {\n        this.error('pcoffset9 out of range');\n        fatalExit('pcoffset9 out of range', 1);\n      }\n      var macword = 0xE000 | dr << 9 | pcoffset9 & 0x1FF;\n      return macword;\n    }\n  }, {\n    key: \"assembleBL\",\n    value: function assembleBL(operands) {\n      var label = operands[0];\n      if (!this.isValidLabel(label)) {\n        this.error(\"Bad label\"); // : ${label}\n        fatalExit(\"Bad label\", 1); // : ${label}\n      }\n      var address = this.evaluateOperand(label, 'E'); // Pass 'E' as usageType\n      if (address === null) {\n        this.error('Bad label');\n        fatalExit('Bad label', 1);\n      }\n      var isExternal = this.externLabels.has(label);\n      var pcoffset11;\n      if (isExternal) {\n        pcoffset11 = 0; // Placeholder offset\n        // Do NOT add an 'A' entry here\n      } else {\n        pcoffset11 = address - this.locCtr - 1;\n        if (pcoffset11 < -1024 || pcoffset11 > 1023) {\n          this.error('pcoffset11 out of range'); // TODO: test this in integration tests\n          return null;\n        }\n      }\n      var macword = 0x4800 | pcoffset11 & 0x07FF;\n      return macword;\n    }\n  }, {\n    key: \"assembleBLR\",\n    value: function assembleBLR(operands) {\n      var baser = this.getRegister(operands[0]);\n      if (baser === null) {\n        this.error('Missing operand');\n        fatalExit('Missing operand', 1);\n      }\n      ;\n      var offset6 = 0;\n      if (operands[1]) {\n        offset6 = this.evaluateImmediate(operands[1], -32, 31, \"offset6\"); //// TODO: test bounds, see if input is naive or not\n      }\n      var macword = 0x4000 | baser << 6 | offset6 & 0x3F;\n      return macword;\n    }\n  }, {\n    key: \"assembleLDR\",\n    value: function assembleLDR(operands) {\n      var dr = this.getRegister(operands[0]);\n      var baser = this.getRegister(operands[1]);\n      if (dr === null || baser === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var offset6 = this.evaluateImmediate(operands[2], -32, 31, 'offset6'); //// TODO: test bounds, see if input is naive or not\n      if (offset6 === null) return null;\n      var macword = 0x6000 | dr << 9 | baser << 6 | offset6 & 0x3F;\n      return macword;\n    }\n  }, {\n    key: \"assembleSTR\",\n    value: function assembleSTR(operands) {\n      var sr = this.getRegister(operands[0]);\n      var baser = this.getRegister(operands[1]);\n      if (sr === null || baser === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var offset6 = this.evaluateImmediate(operands[2], -32, 31, 'offset6'); //// TODO: test bounds, see if input is naive or not\n      if (offset6 === null) return null;\n      var macword = 0x7000 | sr << 9 | baser << 6 | offset6 & 0x3F;\n      return macword;\n    }\n  }, {\n    key: \"assembleJMP\",\n    value: function assembleJMP(operands) {\n      var baser = this.getRegister(operands[0]);\n      if (baser === null) {\n        // Note: as of 12/2024, the official LCC behavior here is to segfault\n        // so, this is currently \"custom\" LCC.js behavior\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var offset6 = 0;\n      if (operands[1]) {\n        offset6 = this.evaluateImmediate(operands[1], -32, 31, \"offset6\"); //// TODO: test bounds, see if input is naive or not\n      }\n      var macword = 0xC000 | baser << 6 | offset6 & 0x3F;\n      return macword;\n    }\n  }, {\n    key: \"assembleRET\",\n    value: function assembleRET(operands) {\n      //// TODO: make sure that ret+3 is valid\n      //// TODO: make sure that ret+ 3 is valid\n      //// TODO; make sure that ret +3 is valid\n      //// TODO: make sure that ret + 3 is valid\n      var baser = 7; // LR register\n      var offset6 = 0;\n      if (operands[0]) {\n        offset6 = this.evaluateImmediate(operands[0], -32, 31, \"offset6\"); //// TODO: test bounds, see if input is naive or not\n      }\n      var macword = 0xC000 | baser << 6 | offset6 & 0x3F;\n      return macword;\n    }\n  }, {\n    key: \"assembleNOT\",\n    value: function assembleNOT(operands) {\n      var dr = this.getRegister(operands[0]);\n      var sr1 = this.getRegister(operands[1]);\n      if (dr === null || sr1 === null) {\n        this.error('Missing register');\n        fatalExit('Missing register', 1);\n      }\n      ;\n      var macword = 0x9000 | dr << 9 | sr1 << 6;\n      return macword;\n    }\n  }, {\n    key: \"assembleMOV\",\n    value: function assembleMOV(mnemonic, operands) {\n      var dr = this.getRegister(operands[0]);\n      if (dr === null) {\n        this.error('Missing register');\n        fatalExit(\"Missing register\", 1);\n      }\n      ;\n      if (mnemonic === 'mov') {\n        // Determine if operands[1] is a register or immediate\n        if (this.isRegister(operands[1])) {\n          // Translate to 'mvr dr, sr'\n          var sr = this.getRegister(operands[1]);\n          // mvr: opcode 0xA000, eopcode 12\n          var macword = 0xA000 | dr << 9 | sr << 6 | 0x000C;\n          return macword;\n        } else {\n          //// TODO: test bounds, see if input is naive or not\n          // Translate to 'mvi dr, imm9'\n          var imm9 = this.evaluateImmediateNaive(operands[1]); // this.evaluateImmediate(operands[1], -256, 255);\n          if (imm9 === null) {\n            this.error('Missing number');\n            fatalExit(\"Missing number\", 1);\n          }\n          ;\n          // mvi: opcode 0xD000\n          var _macword = 0xD000 | dr << 9 | imm9 & 0x1FF;\n          return _macword;\n        }\n      } else if (mnemonic === 'mvi') {\n        //// TODO: test bounds, see if input is naive or not\n        // mvi dr, imm9\n        var _imm = this.evaluateImmediate(operands[1], -256, 255, \"mvi immediate\"); // this.evaluateImmediate(operands[1], -256, 255);\n        if (_imm === null) {\n          this.error('Missing number');\n          fatalExit(\"Missing number\", 1);\n        }\n        ;\n        var _macword2 = 0xD000 | dr << 9 | _imm & 0x1FF;\n        return _macword2;\n      } else if (mnemonic === 'mvr') {\n        // mvr dr, sr1\n        var sr1 = this.getRegister(operands[1]);\n        if (sr1 === null) {\n          this.error('Missing register');\n          fatalExit(\"Missing register\", 1);\n        }\n        ;\n        // Ensure eopcode 12 is set\n        var _macword3 = 0xA000 | dr << 9 | sr1 << 6 | 0x000C;\n        return _macword3;\n      } else {\n        this.error(\"Invalid mnemonic: \".concat(mnemonic));\n        return null;\n      }\n    }\n  }, {\n    key: \"assembleTrap\",\n    value: function assembleTrap(operands, trapVector) {\n      var sr = 0; // Default to r0\n      if (operands[0]) {\n        sr = this.getRegister(operands[0]);\n        if (sr === null) {\n          this.error('Bad register');\n          fatalExit(\"Bad register\", 1);\n        }\n        ;\n      }\n      var macword = 0xF000 | sr << 9 | trapVector & 0xFF;\n      return macword;\n    }\n  }, {\n    key: \"getRegister\",\n    value: function getRegister(regStr) {\n      if (regStr === null || regStr === undefined) {\n        return null;\n      }\n      if (!this.isRegister(regStr)) {\n        this.error('Bad register'); // this.error(`Invalid register: ${regStr}`);\n        fatalExit(\"Bad register\", 1);\n      }\n      if (regStr === \"fp\") {\n        regStr = \"r5\";\n      } else if (regStr === \"sp\") {\n        regStr = \"r6\";\n      } else if (regStr === \"lr\") {\n        regStr = \"r7\";\n      }\n      return parseInt(regStr.substr(1), 10);\n    }\n  }, {\n    key: \"isCharLiteral\",\n    value: function isCharLiteral(str) {\n      var match = /^'(?:\\\\.|[^\\\\])'$/.test(str);\n      return match;\n    }\n  }, {\n    key: \"parseCharLiteral\",\n    value: function parseCharLiteral(str) {\n      // Remove the single quotes\n      var charContent = str.slice(1, -1);\n      if (charContent.length === 1) {\n        // Simple character\n        return charContent.charCodeAt(0);\n      } else if (charContent.startsWith('\\\\')) {\n        // Escape sequence\n        switch (charContent) {\n          case '\\\\n':\n            return '\\n'.charCodeAt(0);\n          case '\\\\t':\n            return '\\t'.charCodeAt(0);\n          case '\\\\r':\n            return '\\r'.charCodeAt(0);\n          case '\\\\\\\\':\n            return '\\\\'.charCodeAt(0);\n          case \"\\\\'\":\n            return \"'\".charCodeAt(0);\n          case '\\\\\"':\n            return '\"'.charCodeAt(0);\n          default:\n            this.error(\"Invalid escape sequence: \".concat(charContent));\n            return null;\n        }\n      } else {\n        this.error(\"Invalid character literal: '\".concat(charContent, \"'\"));\n        return null;\n      }\n    }\n  }, {\n    key: \"isRegister\",\n    value: function isRegister(regStr) {\n      return /^(r[0-7]|fp|sp|lr)$/i.test(regStr);\n    }\n  }, {\n    key: \"isOperator\",\n    value: function isOperator(op) {\n      return op === '+' || op === '-';\n    }\n  }, {\n    key: \"parseLabelWithOffset\",\n    value: function parseLabelWithOffset(operand) {\n      // This regex matches:\n      //   1) A label: starting with letter, '_', '$', '@', followed by letters, digits, '_', '$', '@'\n      //   2) An optional offset: a plus or minus sign, optional spaces, then digits\n      //\n      // Examples matched:\n      //   \"myVar\"          -> label = \"myVar\", offset = null\n      //   \"myVar+2\"        -> label = \"myVar\", offset = 2\n      //   \"myVar - 3\"      -> label = \"myVar\", offset = -3\n      //   \"x+10\"           -> label = \"x\", offset = 10\n      //   \"label- 5\"       -> label = \"label\", offset = -5\n      var labelOffsetPattern = /^([A-Za-z_$@][A-Za-z0-9_$@]*)\\s*([+\\-]\\s*\\d+)?$/;\n      var match = operand.match(labelOffsetPattern);\n      if (!match) {\n        return null; // Not a label with optional offset\n      }\n      var label = match[1];\n      var offsetStr = match[2]; // something like \"+2\" or \"- 3\"\n\n      var offset = 0;\n      if (offsetStr) {\n        // Remove spaces and parse the number\n        offsetStr = offsetStr.replace(/\\s+/g, '');\n        offset = parseInt(offsetStr, 10); // parse \"+2\" or \"-3\"\n        if (isNaN(offset)) {\n          // Should never happen if regex matched, but just in case:\n          return null;\n        }\n      }\n      return {\n        label: label,\n        offset: offset\n      };\n    }\n  }, {\n    key: \"parseNumber\",\n    value: function parseNumber(valueStr) {\n      var value;\n      if (valueStr === null || valueStr === undefined) {\n        return null;\n      }\n\n      // Handle character literals\n      if (this.isCharLiteral(valueStr)) {\n        value = this.parseCharLiteral(valueStr);\n        if (value === null) {\n          return NaN; // Signal an error\n        }\n      } else if (valueStr.startsWith('0x') || valueStr.startsWith('0X')) {\n        value = parseInt(valueStr, 16);\n        // note: the LCC doesn't currently support negative hex numbers\n        // } else if (valueStr.startsWith('-0x') || valueStr.startsWith('-0X')) {\n        //   value = -parseInt(valueStr.substr(3), 16);\n      } else {\n        value = parseInt(valueStr, 10);\n      }\n      return value;\n    }\n\n    // TODO: investigate here for detection of undefined labels\n  }, {\n    key: \"handleExternalReference\",\n    value: function handleExternalReference(label, usageType) {\n      // Check if we've already created an entry for this label and usage type\n      if (!this.externalReferences.some(function (ref) {\n        return ref.label === label && ref.type === usageType;\n      })) {\n        this.externalReferences.push({\n          label: label,\n          type: usageType,\n          address: this.locCtr // Store the current location counter\n        });\n      }\n    }\n\n    // TODO: implement operand type checking {valid: [\"num\", \"char\", \"label\"]}\n    /**\r\n     * Evaluates an operand and returns its corresponding value.\r\n     * The operand can be a pure number, a label with an optional offset, or a plain label.\r\n     * Additionally, the operand can be a location marker indicated with the '*' character.\r\n     * \r\n     * @param {string} operand - The operand to evaluate.\r\n     * @param {string} usageType - The context in which the operand is used (e.g., for external references).\r\n     * @returns {number|null} - The evaluated value of the operand, or null if the operand is undefined.\r\n     */\n  }, {\n    key: \"evaluateOperand\",\n    value: function evaluateOperand(operand, usageType) {\n      // First, try to parse as a pure number\n      var value = this.parseNumber(operand);\n      if (!isNaN(value)) {\n        return value;\n      }\n\n      // If not a pure number, check if it's a label with optional offset\n      var parsed = this.parseLabelWithOffset(operand);\n      if (parsed !== null) {\n        // It's a label and possibly an offset\n        var label = parsed.label,\n          offset = parsed.offset;\n        if (this.symbolTable.hasOwnProperty(label)) {\n          // Local label known\n          return this.symbolTable[label] + offset;\n        } else if (this.externLabels.has(label)) {\n          // External label: create external reference if needed and return placeholder (0 + offset)\n          this.handleExternalReference(label, usageType);\n          return 0 + offset;\n        } else {\n          this.error(\"Undefined label\"); // this.error(`Undefined label: ${label}`);\n          return null;\n        }\n      } else {\n        // If we get here, it's neither a pure number nor a label-with-offset.\n        // Maybe it's just a plain label that we haven't seen? Check that scenario:\n        if (this.symbolTable.hasOwnProperty(operand)) {\n          return this.symbolTable[operand];\n        } else if (this.externLabels.has(operand)) {\n          // External symbol, return 0 placeholder\n          this.handleExternalReference(operand, usageType);\n          return 0;\n        } else {\n          // check for * (current location counter)\n          if (operand[0] === '*') {\n            if (operand[1] === '+' || operand[1] === '-') {\n              var _offset = this.parseNumber(operand.slice(1));\n              if (isNaN(_offset)) {\n                this.error(\"Bad number\");\n                return null;\n              }\n              return this.locCtr + _offset;\n            } else {\n              return this.locCtr;\n            }\n          } else {\n            // inspect to see if it was an invalid number\n            // inspect to see if it was an invalid label\n            if (operand[0] === '0' && operand[1] === 'x' && !this.isValidHexNumber(operand)) {\n              this.error(\"Bad number\");\n              fatalExit(\"Bad number\", 1);\n            } else if (!this.isValidLabel(operand)) {\n              this.error(\"Bad label\");\n              fatalExit(\"Bad label\", 1);\n            } else {\n              this.error(\"Unspecified label error for: \".concat(operand)); // this.error(`Undefined label: ${operand}`);\n              fatalExit(\"Unspecified label error for: \".concat(operand), 1);\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"isValidHexNumber\",\n    value: function isValidHexNumber(str) {\n      return /^0x[0-9A-Fa-f]+$/.test(str);\n    }\n\n    // returns true if operand is either a char (which has an ascii value) \n    // or a number (i.e. neither a string nor a label)\n  }, {\n    key: \"isNumLiteral\",\n    value: function isNumLiteral(operand) {\n      return this.isCharLiteral(operand) || !isNaN(operand) || this.isValidHexNumber(operand);\n    }\n  }, {\n    key: \"evaluateImmediate\",\n    value: function evaluateImmediate(valueStr, min, max) {\n      var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n      var value = this.parseNumber(valueStr);\n      if (isNaN(value)) {\n        this.error(\"Bad number\");\n        fatalExit(\"Bad number\", 1);\n      }\n      if (value < min || value > max) {\n        // this.error(`Immediate value out of range: ${valueStr}`);\n        this.error(\"\".concat(type, \" out of range\"));\n        return null;\n      }\n      return value;\n    }\n\n    // function which simply returns the value if it is a number.\n    // capped at 16 bits. Some instructions do not check for out of bounds numbers.\n  }, {\n    key: \"evaluateImmediateNaive\",\n    value: function evaluateImmediateNaive(valueStr) {\n      if (valueStr === null || valueStr === undefined) {\n        return null;\n      }\n      var value = this.parseNumber(valueStr);\n      if (isNaN(value)) {\n        this.error(\"Bad number\"); // `Not a valid number: ${valueStr}`\n        fatalExit(\"Bad number\", 1);\n      }\n      return value & 0xFFFF;\n    }\n  }, {\n    key: \"error\",\n    value: function error(message) {\n      var errorMsg = \"Error on line \".concat(this.lineNum, \" of \").concat(this.inputFileName, \":\\n    \").concat(this.currentLine, \"\\n\").concat(message);\n      console.error(errorMsg);\n      this.errors.push(errorMsg);\n      this.errorFlag = true;\n\n      // If we're not reporting multiple errors, exit immediately\n      // Note: This matches the behavior in the original LCC of reporting only 1 error at a time\n      if (!REPORT_MULTI_ERRORS) {\n        fatalExit(message, 1);\n      }\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Assembler);\n\n// Instantiate and run the assembler if this script is run directly\nconsole.log(process.argv[1]);\nif (\"file:///C:/Users/lettu/projects/lccjs/src/core/assembler.js\" === \"file://\".concat(process.argv[1])) {\n  var assembler = new Assembler();\n  assembler.main();\n}\n\n//# sourceURL=webpack://LCC/./src/core/assembler.js?");

/***/ }),

/***/ "./src/core/interpreter.js":
/*!*********************************!*\
  !*** ./src/core/interpreter.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"./src/polyfills/fsWrapper.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n/* harmony import */ var _utils_genStats_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/genStats.js */ \"./src/utils/genStats.js\");\n/* harmony import */ var _utils_name_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/name.js */ \"./src/utils/name.js\");\n/* provided dependency */ var process = __webpack_require__(/*! ./src/polyfills/processWrapper.js */ \"./src/polyfills/processWrapper.js\")[\"default\"];\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n//#!/usr/bin/env node\n\n// interpreter.js\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\nvar newline = process.platform === 'win32' ? '\\r\\n' : '\\n';\nvar MAX_MEMORY = 65536; // 2^16\n\nvar isTestMode = typeof {}.it === 'function'; // crude check for Jest\n\nfunction fatalExit(message) {\n  var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  if (isTestMode) {\n    throw new Error(message);\n  } else {\n    process.exit(code);\n  }\n}\nvar Interpreter = /*#__PURE__*/function () {\n  function Interpreter() {\n    _classCallCheck(this, Interpreter);\n    this.mem = new Uint16Array(65536); // Memory (16-bit unsigned integers)\n    this.r = new Uint16Array(8); // Registers r0 to r7 (16-bit signed integers)\n    this.pc = 0; // Program Counter\n    this.ir = 0; // Instruction Register\n    this.n = 0; // Negative flag\n    this.z = 0; // Zero flag\n    this.c = 0; // Carry flag\n    this.v = 0; // Overflow flag\n    this.running = true;\n    this.output = ''; // Output string\n    this.inputBuffer = ''; // Input buffer for SIN (if needed)\n    this.options = {}; // Options from lcc.js\n    this.instructionsExecuted = 0; // For program statistics\n    this.maxStackSize = 0; // For program statistics\n    this.loadPoint = 0; // Default load point is 0\n    this.spInitial = 0; // For tracking stack size\n    this.memMax = 0; // Keep track of the highest memory address used\n    this.inputFileName = ''; // Name of the input file\n    this.generateStats = false; // Whether to generate .lst and .bst files\n    this.headerLines = [];\n    this.instructionsCap = 500000; // Limit the number of instructions to prevent infinite loops\n  }\n  return _createClass(Interpreter, [{\n    key: \"main\",\n    value: function main(args) {\n      args = args || process.argv.slice(2);\n      if (args.length < 1) {\n        console.error('Usage: node interpreter.js <input filename> [options]');\n        // process.exit(1);\n        fatalExit('Usage: node interpreter.js <input filename> [options]', 1);\n      }\n\n      // Parse arguments\n      var i = 0;\n      while (i < args.length) {\n        var arg = args[i];\n        if (arg.startsWith('-')) {\n          // Option\n          if (arg === '-nostats') {\n            this.generateStats = false;\n          } else if (arg.startsWith('-L')) {\n            // Load point option\n            var loadPointStr = arg.substring(2);\n            if (loadPointStr === '') {\n              // Load point value is in the next argument\n              i++;\n              if (i >= args.length) {\n                console.error('Error: -L option requires a value');\n                // process.exit(1);\n                fatalExit('Error: -L option requires a value', 1);\n              }\n              loadPointStr = args[i];\n            }\n            // Parse load point value (hexadecimal)\n            this.loadPoint = parseInt(loadPointStr, 16);\n            if (isNaN(this.loadPoint)) {\n              console.error(\"Invalid load point value: \".concat(loadPointStr));\n              // process.exit(1);\n              fatalExit(\"Invalid load point value: \".concat(loadPointStr), 1);\n            }\n          } else {\n            console.error(\"Bad command line switch: \".concat(arg)); // `Unknown option: ${arg}`\n            // process.exit(1);\n            fatalExit(\"Bad command line switch: \".concat(arg), 1);\n          }\n        } else {\n          // Assume it's the input file name\n          if (!this.inputFileName) {\n            this.inputFileName = arg;\n            var extension = path__WEBPACK_IMPORTED_MODULE_1__.extname(this.inputFileName).toLowerCase();\n            // Note: This is custom behavior in interpreter.js (not the official LCC)\n            //       to check specifically for .e files, since the LCC interpreter is\n            //       accessed by default when running .e files, or when assembling and\n            //       running .a files all at once.\n            if (extension !== '.e') {\n              console.error('Unsupported file type for interpreter.js (expected .e)');\n              fatalExit('Unsupported file type for interpreter.js (expected .e)', 1);\n            }\n          } else {\n            console.error(\"Unexpected argument: \".concat(arg));\n            // process.exit(1);\n            fatalExit(\"Unexpected argument: \".concat(arg), 1);\n          }\n        }\n        i++;\n      }\n      if (!this.inputFileName) {\n        console.error('No input file specified.');\n        // process.exit(1);\n        fatalExit('No input file specified.', 1);\n      }\n\n      // Get the userName using nameHandler\n      try {\n        //// console.log(`inputFileName = ${this.inputFileName}`);\n        this.userName = _utils_name_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].createNameFile(this.inputFileName);\n        //// console.log(\"userName = \" + this.userName);\n      } catch (error) {\n        console.error('Error handling name file:', error.message);\n        // process.exit(1);\n        fatalExit('Error handling name file: ' + error.message, 1);\n      }\n\n      // this prints out when called by interpreter.js\n      console.log(\"Starting interpretation of \".concat(this.inputFileName));\n\n      // Open and read the executable file\n      var buffer;\n      try {\n        buffer = fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].readFileSync(this.inputFileName);\n      } catch (err) {\n        console.error(\"Cannot open input file \".concat(this.inputFileName)); // , err: ${err}\n        // process.exit(1);\n        fatalExit(\"Cannot open input file \".concat(this.inputFileName), 1); // , err: ${err}\n      }\n\n      // Check file signature\n      if (buffer[0] !== 'o'.charCodeAt(0)) {\n        // `${this.inputFileName} is not a valid LCC executable file: missing 'o' signature`\n        console.error(\"\".concat(this.inputFileName, \" is not in lcc format\"));\n        // process.exit(1);\n        fatalExit(\"\".concat(this.inputFileName, \" is not in lcc format\"), 1);\n      }\n\n      // Load the executable into memory\n      this.loadExecutableBuffer(buffer);\n\n      // Capture the initial memory state\n      this.initialMem = this.mem.slice(); // Makes a copy of the memory array\n\n      // Prepare .lst and .bst file names\n      var lstFileName = this.inputFileName.replace(/\\.e$/, '.lst');\n      var bstFileName = this.inputFileName.replace(/\\.e$/, '.bst');\n      console.log(\"lst file = \".concat(lstFileName));\n      console.log(\"bst file = \".concat(bstFileName));\n      console.log('====================================================== Output');\n\n      // Run the interpreter\n      try {\n        this.run();\n        if (this.generateStats) {\n          console.log(); // Ensure cursor moves to the next line\n        }\n      } catch (error) {\n        console.error(\"Runtime Error: \".concat(error.message));\n        // process.exit(1);\n        fatalExit(\"Runtime Error: \".concat(error.message), 1);\n      }\n\n      // Generate .lst and .bst files if required\n      if (this.generateStats) {\n        var lstContent = (0,_utils_genStats_js__WEBPACK_IMPORTED_MODULE_2__.generateBSTLSTContent)({\n          isBST: false,\n          interpreter: this,\n          assembler: null,\n          userName: this.userName,\n          inputFileName: this.inputFileName\n        });\n        var bstContent = (0,_utils_genStats_js__WEBPACK_IMPORTED_MODULE_2__.generateBSTLSTContent)({\n          isBST: true,\n          interpreter: this,\n          assembler: null,\n          userName: this.userName,\n          inputFileName: this.inputFileName\n        });\n\n        // Write the .lst and .bst files\n        fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeFileSync(lstFileName, lstContent);\n        fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeFileSync(bstFileName, bstContent);\n      }\n    }\n  }, {\n    key: \"constructBSTLSTFileName\",\n    value: function constructBSTLSTFileName(inputFileName, isBST) {\n      var parsedPath = path__WEBPACK_IMPORTED_MODULE_1__.parse(inputFileName);\n      // Remove extension and add '.bst'\n      return path__WEBPACK_IMPORTED_MODULE_1__.format(_objectSpread(_objectSpread({}, parsedPath), {}, {\n        base: undefined,\n        ext: isBST ? '.bst' : '.lst'\n      }));\n    }\n\n    // for use in lcc.js\n    // makes sure that the file is a valid executable file by checking \n    // for the \"o\" file signature and \"C\" header termination character\n  }, {\n    key: \"loadExecutableFile\",\n    value: function loadExecutableFile(fileName) {\n      var buffer;\n      try {\n        buffer = fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].readFileSync(fileName);\n      } catch (err) {\n        console.error(\"Cannot open input file \".concat(fileName));\n        // process.exit(1);\n        fatalExit(\"Cannot open input file \".concat(fileName), 1);\n      }\n\n      // Check file signature: look for \"o\" followed by \"C\" anywhere in the buffer\n      var foundO = false;\n      var foundC = false;\n      for (var offset = 0; offset < buffer.length; offset++) {\n        var _char = String.fromCharCode(buffer[offset]);\n\n        // Look for the starting \"o\"\n        if (!foundO && _char === 'o') {\n          foundO = true;\n        }\n        // Once \"o\" is found, look for the \"C\" as the end of the header\n        else if (foundO && _char === 'C') {\n          foundC = true;\n          break;\n        }\n      }\n\n      // If either \"o\" or \"C\" was not found in the expected order, throw an error\n      if (!foundO || !foundC) {\n        console.error(\"\".concat(fileName, \" is not a valid LCC executable file\"));\n        // process.exit(1);\n        fatalExit(\"\".concat(fileName, \" is not a valid LCC executable file\"), 1);\n      }\n\n      // this prints out when called by lcc.js\n      console.log(\"Starting interpretation of \".concat(fileName));\n\n      // Load the executable into memory\n      this.loadExecutableBuffer(buffer);\n      this.initialMem = this.mem.slice(); // Makes a copy of the memory array\n    }\n\n    // extracts header entries and loads machine code into memory\n  }, {\n    key: \"loadExecutableBuffer\",\n    value: function loadExecutableBuffer(buffer) {\n      var offset = 0;\n\n      // Read file signature\n      if (buffer[offset++] !== 'o'.charCodeAt(0)) {\n        this.error('Invalid file signature: missing \"o\"');\n        return;\n      }\n\n      // Do not store the 'o' signature in headerLines\n\n      var startAddress = 0; // Default start address\n\n      // Read header entries until 'C' is encountered\n      while (offset < buffer.length) {\n        var entryChar = String.fromCharCode(buffer[offset++]);\n        if (entryChar === 'C') {\n          // Start of code\n          // Do not store 'C' in headerLines\n          break;\n        } else if (entryChar === 'S') {\n          // Start address entry: read two bytes as little endian\n          if (offset + 1 >= buffer.length) {\n            this.error('Incomplete start address in header');\n            return;\n          }\n          startAddress = buffer.readUInt16LE(offset);\n          offset += 2;\n          this.headerLines.push(\"S \".concat(startAddress.toString(16).padStart(4, '0')));\n        } else if (entryChar === 'G') {\n          // Skip 'G' entry: Read address and label\n          if (offset + 1 >= buffer.length) {\n            this.error('Incomplete G entry in header');\n            return;\n          }\n          var address = buffer.readUInt16LE(offset);\n          offset += 2;\n          var label = '';\n          while (offset < buffer.length) {\n            var charCode = buffer[offset++];\n            if (charCode === 0) break;\n            label += String.fromCharCode(charCode);\n          }\n          this.headerLines.push(\"G \".concat(address.toString(16).padStart(4, '0'), \" \").concat(label));\n        } else if (entryChar === 'A') {\n          // Skip 'A' entry: Read address\n          if (offset + 1 >= buffer.length) {\n            this.error('Incomplete A entry in header');\n            return;\n          }\n          var _address = buffer.readUInt16LE(offset);\n          offset += 2;\n          this.headerLines.push(\"A \".concat(_address.toString(16).padStart(4, '0')));\n        } else {\n          // Skip unknown entries or handle as needed\n          this.error(\"Unknown header entry: '\".concat(entryChar, \"'\"));\n          return;\n        }\n      }\n\n      // Read machine code into memory starting at this.loadPoint\n      var memIndex = this.loadPoint; // Start loading at loadPoint\n      while (offset + 1 < buffer.length) {\n        var instruction = buffer.readUInt16LE(offset);\n        offset += 2;\n        this.mem[memIndex++] = instruction;\n      }\n      this.memMax = memIndex - 1; // Last memory address used\n\n      // Set PC to loadPoint + startAddress\n      this.pc = this.loadPoint + startAddress & 0xFFFF;\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      this.spInitial = this.r[6]; // Assuming r6 is the stack pointer\n\n      while (this.running) {\n        this.step();\n      }\n    }\n  }, {\n    key: \"step\",\n    value: function step() {\n      // Fetch instruction\n      this.ir = this.mem[this.pc++];\n      // Decode instruction\n      this.opcode = this.ir >> 12 & 0xF; // Opcode (bits 15-12)\n      this.code = this.dr = this.sr = this.ir >> 9 & 0x7; // dr/sr (bits 11-9)\n      this.sr1 = this.baser = this.ir >> 6 & 0x7; // sr1/baser (bits 8-6)\n      this.sr2 = this.ir & 0x7; // sr2 (bits 2-0)\n      this.bit5 = this.ir >> 5 & 0x1; // bit 5\n      this.bit11 = this.ir >> 11 & 0x1; // bit 11\n      this.imm5 = this.signExtend(this.ir & 0x1F, 5); // imm5 (bits 4-0)\n      this.pcoffset9 = this.signExtend(this.ir & 0x1FF, 9); // pcoffset9 (bits 8-0)\n      this.imm9 = this.pcoffset9;\n      this.pcoffset11 = this.signExtend(this.ir & 0x7FF, 11); // pcoffset11 (bits 10-0)\n      this.offset6 = this.signExtend(this.ir & 0x3F, 6); // offset6 (bits 5-0)\n      this.eopcode = this.ir & 0x1F; // eopcode (bits 4-0)\n      this.trapvec = this.ir & 0xFF; // trap vector (bits 7-0)\n\n      // Execute instruction\n      switch (this.opcode) {\n        case 0:\n          // BR\n          this.executeBR();\n          break;\n        case 1:\n          // ADD\n          this.executeADD();\n          break;\n        case 2:\n          // LD\n          this.executeLD();\n          break;\n        case 3:\n          // ST\n          this.executeST();\n          break;\n        case 4:\n          // BL or BLR\n          this.executeBLorBLR();\n          break;\n        case 5:\n          // AND\n          this.executeAND();\n          break;\n        case 6:\n          // LDR\n          this.executeLDR();\n          break;\n        case 7:\n          // STR\n          this.executeSTR();\n          break;\n        case 8:\n          // CMP\n          this.executeCMP();\n          break;\n        case 9:\n          // NOT\n          this.executeNOT();\n          break;\n        case 10:\n          // PUSH, POP, SRL, SRA, SLL, ROL, ROR, MUL, DIV, REM, OR, XOR, MVR, SEXT\n          this.executeCase10();\n          break;\n        case 11:\n          // SUB\n          this.executeSUB();\n          break;\n        case 12:\n          // JMP/RET\n          this.executeJMP();\n          break;\n        case 13:\n          // MVI\n          this.executeMVI();\n          break;\n        case 14:\n          // LEA\n          this.executeLEA();\n          break;\n        case 15:\n          // TRAP\n          this.executeTRAP();\n          break;\n        default:\n          this.error(\"Unknown opcode: \".concat(this.opcode));\n          this.running = false;\n      }\n      this.instructionsExecuted++;\n\n      // Check if the instruction limit has been reached\n      // Note: This is a safety feature to prevent infinite loops\n      // 2nd Note: This matches exactly the # of instructions \n      // permitted to run by from the lcc before entering the debugger\n      if (this.instructionsExecuted >= this.instructionsCap) {\n        console.error(\"Possible infinite loop\");\n        this.running = false;\n        // return; // Exit the step method early\n        fatalExit(\"Possible infinite loop\", 1);\n        //// TODO: after implementing symbolic debugger, this should not exit the program\n        ////       and should instead initiate symbolic debugger execution\n        //// TODO: implement a custom LCC.js behavior to set flags to toggle (1) potential\n        ////       infinite loop detection, and (2) automatic initiation of symbolic debugger\n      }\n\n      // Track max stack size\n      var sp = this.r[6];\n      var stackSize = sp === 0 ? 0 : MAX_MEMORY - sp;\n      if (stackSize > this.maxStackSize) {\n        this.maxStackSize = stackSize;\n      }\n    }\n\n    // cmp    1000  000  sr1 000 sr2   nzcv sr1 - sr2 (set flags) \n    // cmp    1000  000  sr1 1  imm5   nzcv sr1 - imm5 (set flags) \n  }, {\n    key: \"executeCMP\",\n    value: function executeCMP() {\n      if (this.bit5 === 0) {\n        // Register mode\n        var x = this.toSigned16(this.r[this.sr1]);\n        var y = this.toSigned16(this.r[this.sr2]);\n        var negY = -y;\n        var sum = x + negY;\n        var result = sum & 0xFFFF;\n        this.setNZ(result);\n        this.setCV(sum, x, negY);\n      } else {\n        // Immediate mode\n        var _x = this.toSigned16(this.r[this.sr1]);\n        var _y = this.toSigned16(this.imm5);\n        var _negY = -_y;\n        var _sum = _x + _negY;\n        var _result = _sum & 0xFFFF;\n        this.setNZ(_result);\n        this.setCV(_sum, _x, _negY);\n      }\n    }\n  }, {\n    key: \"executeBR\",\n    value: function executeBR() {\n      var conditionMet = false;\n      switch (this.code) {\n        case 0:\n          // brz/bre\n          conditionMet = this.z === 1;\n          break;\n        case 1:\n          // brnz/brne\n          conditionMet = this.z === 0;\n          break;\n        case 2:\n          // brn\n          conditionMet = this.n === 1;\n          break;\n        case 3:\n          // brp\n          conditionMet = this.n === this.z;\n          break;\n        case 4:\n          // brlt\n          conditionMet = this.n !== this.v;\n          break;\n        case 5:\n          // brgt\n          conditionMet = this.n === this.v && this.z === 0;\n          break;\n        case 6:\n          // brc/brb\n          conditionMet = this.c === 1;\n          break;\n        case 7:\n          // br/bral\n          conditionMet = true;\n          break;\n      }\n      if (conditionMet) {\n        this.pc = this.pc + this.pcoffset9 & 0xFFFF;\n      }\n    }\n  }, {\n    key: \"executeCase10\",\n    value: function executeCase10() {\n      // ct is a 4-bit shift count field (if omitted at the assembly level, it defaults to 1). \n      var ct = this.ir >> 5 & 0xF;\n      switch (this.eopcode) {\n        case 0:\n          // PUSH // mem[--sp] = sr \n          // decrement stack pointer and store value\n          this.r[6] = this.r[6] - 1 & 0xFFFF;\n          // save source register to memory at address pointed at by stack pointer\n          this.mem[this.r[6]] = this.r[this.sr];\n          break;\n        case 1:\n          // POP // dr = mem[sp++];\n          // load value from memory at address pointed at by stack pointer to destination\n          this.r[this.dr] = this.mem[this.r[6]];\n          // increment stack pointer (to deallocate stack memory)\n          this.r[6] = this.r[6] + 1 & 0xFFFF;\n          break;\n        /*\r\n        The shift instructions move the contents of the source register either left or right, depending on the specific instruction. The first operand in a shift assembly language instruction specifies the register to be shifted, while the second operand indicates the shift count, which is the number of positions to shift. The shift count must be a value between 0 and 15, and if it is not provided, it defaults to 1.\r\n          The SRL (shift right logical) instruction shifts bits to the right, inserting a 0 on the left to ensure the sign bit becomes 0, regardless of its previous state. The SRA (shift right arithmetic) instruction also shifts bits to the right but preserves the sign bit by copying it into the leftmost position. The SLL (shift left logical) instruction shifts bits to the left, inserting a 0 on the right. For all shift instructions, the c flag is set to the last bit shifted out of the register, and the n and z flags are updated to reflect the state of the register after the shift. For instance, the instruction srl r1, 1 shifts the contents of r1 one position to the right, inserting a 0 on the left.\r\n        */\n        case 2:\n          // SRL\n          this.c = this.r[this.sr] >> ct - 1 & 1; // Store the last bit shifted out\n          this.r[this.sr] = this.r[this.sr] >>> ct; // Unsigned right shift (injects 0's from the left)\n          this.setNZ(this.r[this.sr]); // Update flags\n          break;\n        case 3:\n          // SRA\n          this.c = this.r[this.sr] >> ct - 1 & 1; // Store the last bit shifted out\n          var signBit = this.r[this.sr] & 0x8000 ? 0xFFFF << 16 - ct : 0; // Extend sign bit\n          this.r[this.sr] = this.r[this.sr] >> ct | signBit; // Shift right with sign extension\n          this.setNZ(this.r[this.sr]); // Update flags\n          break;\n        case 4:\n          // SLL\n          this.c = this.r[this.sr] >> 16 - ct & 1; // Store the last bit shifted out\n          this.r[this.sr] = this.r[this.sr] << ct & 0xFFFF; // Logical shift left (mask to 16 bits)\n          this.setNZ(this.r[this.sr]); // Update flags\n          break;\n        case 5:\n          // ROL\n          this.c = this.r[this.sr] >> 16 - ct & 1;\n          this.r[this.sr] = this.r[this.sr] << ct | this.r[this.sr] >> 16 - ct;\n          this.setNZ(this.r[this.sr]);\n          break;\n        case 6:\n          // ROR\n          this.c = this.r[this.sr] >> ct - 1 & 1;\n          this.r[this.sr] = this.r[this.sr] >> ct | this.r[this.sr] << 16 - ct;\n          this.setNZ(this.r[this.sr]);\n          break;\n        case 7:\n          // MUL\n          this.r[this.dr] = this.r[this.dr] * this.r[this.sr1] & 0xFFFF;\n          this.setNZ(this.r[this.dr]);\n          break;\n        case 8:\n          // DIV\n          if (this.r[this.sr1] === 0) {\n            this.error('Floating point exception');\n            fatalExit('Floating point exception', 1);\n          }\n          this.r[this.dr] = this.r[this.dr] / this.r[this.sr1] & 0xFFFF;\n          this.setNZ(this.r[this.dr]);\n          break;\n        case 9:\n          // REM\n          if (this.r[this.sr1] === 0) {\n            this.error('Floating point exception');\n            fatalExit('Floating point exception', 1);\n          }\n          this.r[this.dr] = this.r[this.dr] % this.r[this.sr1] & 0xFFFF;\n          this.setNZ(this.r[this.dr]);\n          break;\n        case 10:\n          // OR\n          this.r[this.dr] = this.r[this.dr] | this.r[this.sr1];\n          this.setNZ(this.r[this.dr]);\n          break;\n        case 11:\n          // XOR\n          this.r[this.dr] = this.r[this.dr] ^ this.r[this.sr1];\n          this.setNZ(this.r[this.dr]);\n          break;\n        case 12:\n          // MVR\n          this.r[this.dr] = this.r[this.sr1];\n          break;\n        case 13:\n          // SEXT\n          this.r[this.dr] = this.signExtend(this.r[this.dr], this.r[this.sr1]);\n          this.setNZ(this.r[this.dr]);\n          break;\n        default:\n          //// TODO: compare implementation with the official LCC interpreter\n          this.error(\"Unknown extended opcode: \".concat(this.eopcode));\n          this.running = false;\n          fatalExit(\"Unknown extended opcode: \".concat(this.eopcode), 1);\n      }\n    }\n  }, {\n    key: \"executeADD\",\n    value: function executeADD() {\n      if (this.bit5 === 0) {\n        // Register mode\n        var result = this.r[this.sr1] + this.r[this.sr2] & 0xFFFF;\n        this.setNZ(result);\n        this.setCV(result, this.r[this.sr1], this.r[this.sr2]);\n        this.r[this.dr] = result;\n      } else {\n        // Immediate mode\n        var _result2 = this.r[this.sr1] + this.imm5 & 0xFFFF;\n        this.setNZ(_result2);\n        this.setCV(_result2, this.r[this.sr1], this.imm5);\n        this.r[this.dr] = _result2;\n      }\n    }\n  }, {\n    key: \"executeSUB\",\n    value: function executeSUB() {\n      if (this.bit5 === 0) {\n        // Register mode\n        var x = this.toSigned16(this.r[this.sr1]);\n        var y = this.toSigned16(this.r[this.sr2]);\n        var negY = -y;\n        var sum = x + negY;\n        var result = sum & 0xFFFF;\n        this.setNZ(result);\n        this.setCV(sum, x, negY);\n        this.r[this.dr] = result;\n      } else {\n        // Immediate mode\n        var _x2 = this.toSigned16(this.r[this.sr1]);\n        var _y2 = this.toSigned16(this.imm5);\n        var _negY2 = -_y2;\n        var _sum2 = _x2 + _negY2;\n        var _result3 = _sum2 & 0xFFFF;\n        this.setNZ(_result3);\n        this.setCV(_sum2, _x2, _negY2);\n        this.r[this.dr] = _result3;\n      }\n    }\n  }, {\n    key: \"executeAND\",\n    value: function executeAND() {\n      if (this.bit5 !== 0) {\n        this.r[this.dr] = this.r[this.sr1] & this.imm5;\n      } else {\n        this.r[this.dr] = this.r[this.sr1] & this.r[this.sr2];\n      }\n      this.setNZ(this.r[this.dr]);\n    }\n  }, {\n    key: \"executeNOT\",\n    value: function executeNOT() {\n      this.r[this.dr] = ~this.r[this.sr1] & 0xFFFF;\n      this.setNZ(this.r[this.dr]);\n    }\n  }, {\n    key: \"executeLD\",\n    value: function executeLD() {\n      var address = this.pc + this.pcoffset9 & 0xFFFF;\n      this.r[this.dr] = this.mem[address];\n      this.setNZ(this.r[this.dr]);\n    }\n  }, {\n    key: \"executeST\",\n    value: function executeST() {\n      var address = this.pc + this.pcoffset9 & 0xFFFF;\n      this.mem[address] = this.r[this.sr];\n      if (address > this.memMax) this.memMax = address;\n    }\n  }, {\n    key: \"executeMVI\",\n    value: function executeMVI() {\n      this.r[this.dr] = this.imm9;\n      this.setNZ(this.r[this.dr]);\n    }\n  }, {\n    key: \"executeLEA\",\n    value: function executeLEA() {\n      this.r[this.dr] = this.pc + this.pcoffset9 & 0xFFFF;\n    }\n\n    ////\n  }, {\n    key: \"executeLDR\",\n    value: function executeLDR() {\n      var address = this.r[this.baser] + this.offset6 & 0xFFFF;\n      this.r[this.dr] = this.mem[address];\n      this.setNZ(this.r[this.dr]);\n    }\n\n    ////\n  }, {\n    key: \"executeSTR\",\n    value: function executeSTR() {\n      var address = this.r[this.baser] + this.offset6 & 0xFFFF;\n      this.mem[address] = this.r[this.sr];\n    }\n\n    ////\n  }, {\n    key: \"executeJMP\",\n    value: function executeJMP() {\n      this.pc = this.r[this.baser] + this.offset6 & 0xFFFF;\n    }\n  }, {\n    key: \"executeBLorBLR\",\n    value: function executeBLorBLR() {\n      if (this.bit11 !== 0) {\n        // BL (Branch and Link)\n        this.r[7] = this.pc;\n        this.pc = this.pc + this.pcoffset11 & 0xFFFF;\n      } else {\n        // BLR (Branch and Link Register)\n        this.r[7] = this.pc;\n        this.pc = this.r[this.baser] + this.offset6 & 0xFFFF;\n      }\n    }\n  }, {\n    key: \"executeSOUT\",\n    value: function executeSOUT() {\n      var address = this.r[this.sr];\n      var charCode = this.mem[address];\n      while (charCode !== 0) {\n        var _char2 = String.fromCharCode(charCode);\n        this.writeOutput(_char2);\n        address = address + 1 & 0xFFFF;\n        charCode = this.mem[address];\n      }\n    }\n  }, {\n    key: \"readLineFromStdin\",\n    value: function readLineFromStdin() {\n      if (this.inputBuffer && this.inputBuffer.length > 0) {\n        // Use the inputBuffer to simulate user input\n        this.inputBuffer = this.inputBuffer.replace(/\\r\\n/g, '\\n');\n        // TODO: check to make sure this behaves as expected on both Linux and Windows\n        var newlineIndex = this.inputBuffer.indexOf('\\n');\n        var inputLine = '';\n        if (newlineIndex !== -1) {\n          inputLine = this.inputBuffer.slice(0, newlineIndex);\n          this.inputBuffer = this.inputBuffer.slice(newlineIndex + 1);\n        } else {\n          inputLine = this.inputBuffer;\n          this.inputBuffer = '';\n        }\n        // Echo the simulated input back to output and stdout\n        ///// this.writeOutput(inputLine + '\\n');\n        this.writeOutput(inputLine);\n        return {\n          inputLine: inputLine,\n          isSimulated: true\n        };\n      } else {\n        // Original code for reading from stdin\n        var input = '';\n        var buffer = Buffer.alloc(1);\n        var fd = process.stdin.fd;\n        while (true) {\n          try {\n            var bytesRead = fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].readSync(fd, buffer, 0, 1, null);\n            if (bytesRead === 0) {\n              // EOF\n              break;\n            }\n            var _char3 = buffer.toString('utf8');\n\n            // If it's a UNIX newline, we're done.\n            if (_char3 === '\\n') {\n              break;\n            }\n\n            // If it's '\\r', check whether the next char is '\\n'.\n            if (_char3 === '\\r') {\n              var nextBytes = fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].readSync(fd, buffer, 0, 1, null);\n              if (nextBytes > 0) {\n                var nextChar = buffer.toString('utf8', 0, nextBytes);\n                // If nextChar is not '\\n', we treat this '\\r' as a line terminator\n                // and the nextChar is actually the start of the next line.\n                if (nextChar !== '\\n') {\n                  input += nextChar; // Or handle it differently if you prefer\n                }\n              }\n              break;\n            }\n            input += _char3;\n          } catch (err) {\n            if (err.code === 'EAGAIN') {\n              // Resource temporarily unavailable, wait a bit and retry\n              continue;\n            } else {\n              throw err;\n            }\n          }\n        }\n        input = input.replace(/\\r$/, '');\n        return {\n          inputLine: input,\n          isSimulated: false\n        };\n      }\n    }\n  }, {\n    key: \"readCharFromStdin\",\n    value: function readCharFromStdin() {\n      if (this.inputBuffer && this.inputBuffer.length > 0) {\n        var ainChar = this.inputBuffer.charAt(0);\n        this.inputBuffer = this.inputBuffer.slice(1);\n        // Echo the simulated input back to output and stdout\n        this.writeOutput(ainChar + newline);\n        return {\n          \"char\": ainChar,\n          isSimulated: true\n        };\n      } else {\n        // Read one character from stdin\n        var ainBuffer = Buffer.alloc(1);\n        var fd = process.stdin.fd;\n        var ainBytesRead = 0;\n\n        // Keep trying to read until we get a character\n        while (ainBytesRead === 0) {\n          try {\n            ainBytesRead = fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].readSync(fd, ainBuffer, 0, 1, null);\n          } catch (err) {\n            if (err.code === 'EAGAIN') {\n              continue;\n            } else {\n              throw err;\n            }\n          }\n        }\n\n        // If we got here, we successfully read a character\n        var _ainChar = ainBuffer.toString('utf8');\n        return {\n          \"char\": _ainChar,\n          isSimulated: false\n        };\n      }\n    }\n  }, {\n    key: \"executeSIN\",\n    value: function executeSIN() {\n      var address = this.r[this.sr];\n      var _this$readLineFromStd = this.readLineFromStdin(),\n        input = _this$readLineFromStd.inputLine,\n        isSimulated = _this$readLineFromStd.isSimulated;\n      for (var i = 0; i < input.length; i++) {\n        this.mem[address] = input.charCodeAt(i);\n        address = address + 1 & 0xFFFF;\n      }\n      // Null-terminate the string\n      this.mem[address] = 0;\n\n      // add newline here if input is simulated\n      if (isSimulated) {\n        this.writeOutput(newline);\n      } else\n        //// else, add input to the output buffer w/ newline delimeter\n        {\n          this.output += input + newline;\n        }\n    }\n  }, {\n    key: \"executeM\",\n    value: function executeM() {\n      for (var addr = 0; addr <= this.memMax; addr++) {\n        var content = this.mem[addr];\n        var line = \"\".concat(addr.toString(16).padStart(4, '0'), \": \").concat(content.toString(16).padStart(4, '0'));\n        this.writeOutput(line + newline);\n      }\n    }\n  }, {\n    key: \"executeR\",\n    value: function executeR() {\n      var pcStr = this.pc.toString(16).padStart(4, '0');\n      var irValue = this.mem[this.pc & 0xFFFF];\n      var irStr = irValue.toString(16).padStart(4, '0');\n      var nzcvStr = \"\".concat(this.n).concat(this.z).concat(this.c).concat(this.v).padStart(4, '0');\n      var output = \"pc = \".concat(pcStr, \"  ir = \").concat(irStr, \"  NZCV = \").concat(nzcvStr).concat(newline);\n      // First line: r0 to r3\n      for (var i = 0; i <= 3; i++) {\n        var regStr = this.r[i].toString(16).padStart(4, '0');\n        output += \"r\".concat(i, \" = \").concat(regStr, \"  \");\n      }\n      output += newline;\n      // Second line: r4, fp, sp, lr\n      var r4Str = this.r[4].toString(16).padStart(4, '0');\n      var fpStr = this.r[5].toString(16).padStart(4, '0');\n      var spStr = this.r[6].toString(16).padStart(4, '0');\n      var lrStr = this.r[7].toString(16).padStart(4, '0');\n      output += \"r4 = \".concat(r4Str, \"  fp = \").concat(fpStr, \"  sp = \").concat(spStr, \"  lr = \").concat(lrStr, \"  \").concat(newline);\n      this.writeOutput(output);\n    }\n  }, {\n    key: \"executeS\",\n    value: function executeS() {\n      var sp = this.r[6];\n      var fp = this.r[5];\n      if (sp === this.spInitial) {\n        this.writeOutput(\"Stack empty\".concat(newline));\n        return;\n      } else {\n        this.writeOutput(\"Stack:\".concat(newline));\n        for (var addr = sp; addr < MAX_MEMORY; addr++) {\n          var value = this.mem[addr];\n          var addrStr = addr.toString(16).padStart(4, '0');\n          var valueStr = value.toString(16).padStart(4, '0');\n          var line = \"\".concat(addrStr, \": \").concat(valueStr);\n          if (addr === fp) {\n            line += ' <--- fp';\n          }\n          this.writeOutput(line + newline);\n        }\n      }\n    }\n  }, {\n    key: \"writeOutput\",\n    value: function writeOutput(message) {\n      process.stdout.write(message);\n      this.output += message;\n    }\n  }, {\n    key: \"executeTRAP\",\n    value: function executeTRAP() {\n      switch (this.trapvec) {\n        case 0:\n          // HALT\n          this.running = false;\n          break;\n        case 1:\n          // NL\n          this.writeOutput(newline);\n          break;\n        case 2:\n          // DOUT\n          var value = this.r[this.sr];\n          // Convert unsigned 16-bit to signed 16-bit\n          if (value & 0x8000) {\n            value -= 0x10000;\n          }\n          var doutStr = \"\".concat(value);\n          this.writeOutput(doutStr);\n          break;\n        case 3:\n          // UDOUT\n          // print as unsigned decimal\n          var udoutStr = \"\".concat(this.r[this.sr] & 0xFFFF);\n          this.writeOutput(udoutStr);\n          break;\n        case 4:\n          // HOUT\n          // print as hexadecimal\n          var houtStr = this.r[this.sr].toString(16).toLowerCase();\n          this.writeOutput(houtStr);\n          break;\n        case 5:\n          // AOUT\n          // print as ASCII character\n          var aoutChar = String.fromCharCode(this.r[this.sr] & 0xFF);\n          this.writeOutput(aoutChar);\n          break;\n        case 6:\n          // SOUT\n          // print string at address\n          this.executeSOUT();\n          break;\n        case 7:\n          // DIN\n          while (true) {\n            var _this$readLineFromStd2 = this.readLineFromStdin(),\n              dinInput = _this$readLineFromStd2.inputLine,\n              _isSimulated = _this$readLineFromStd2.isSimulated;\n            if (dinInput.trim() === '') {\n              continue;\n            }\n            var dinValue = parseInt(dinInput, 10);\n            if (isNaN(dinValue)) {\n              var errorMsg = \"Invalid dec constant. Re-enter:\".concat(newline);\n              this.writeOutput(errorMsg);\n              continue;\n            } else {\n              this.r[this.dr] = dinValue & 0xFFFF;\n              // No need to echo input here; already handled in readLineFromStdin()\n              //// unless input is simulated\n              if (_isSimulated) {\n                this.writeOutput(newline);\n              } else {\n                // add input to the output buffer w/ newline delimeter\n                this.output += dinInput + newline;\n              }\n              break;\n            }\n          }\n          break;\n        case 8:\n          // HIN\n          while (true) {\n            var _this$readLineFromStd3 = this.readLineFromStdin(),\n              hinInput = _this$readLineFromStd3.inputLine,\n              _isSimulated2 = _this$readLineFromStd3.isSimulated;\n            if (hinInput.trim() === '') {\n              continue;\n            }\n            var hinValue = parseInt(hinInput, 16);\n            if (isNaN(hinValue)) {\n              var _errorMsg = \"Invalid hex constant. Re-enter:\".concat(newline);\n              this.writeOutput(_errorMsg);\n              continue;\n            } else {\n              this.r[this.dr] = hinValue & 0xFFFF;\n              // No need to echo input here; already handled in readLineFromStdin()\n              //// unless input is simulated\n              if (_isSimulated2) {\n                this.writeOutput(newline);\n              } else {\n                this.output += hinInput + newline;\n              }\n              break;\n            }\n          }\n          break;\n        case 9:\n          // AIN\n          var _this$readCharFromStd = this.readCharFromStdin(),\n            ainChar = _this$readCharFromStd[\"char\"],\n            isSimulated = _this$readCharFromStd.isSimulated;\n          this.r[this.dr] = ainChar.charCodeAt(0);\n          // No need to echo input here; already handled in readCharFromStdin()\n          break;\n        case 10:\n          // SIN\n          // read a line of input from the user\n          this.executeSIN();\n          break;\n        case 11:\n          // m\n          this.executeM();\n          break;\n        case 12:\n          // r\n          this.executeR();\n          break;\n        case 13:\n          // s\n          this.executeS();\n          break;\n        case 14:\n          // bp\n          this.error('Breakpoint trap not yet implemented');\n          break;\n        default:\n          // `Unknown TRAP vector: ${this.trapvec}`\n          console.error(\"Error on line 0 of \".concat(this.inputFileName));\n          console.error();\n          this.error(\"Trap vector out of range\"); // : ${this.trapvec}\n          this.running = false;\n      }\n    }\n  }, {\n    key: \"toSigned16\",\n    value: function toSigned16(value) {\n      value &= 0xFFFF; // Ensure 16-bit value\n      if (value & 0x8000) {\n        return value - 0x10000; // Convert to negative value\n      } else {\n        return value;\n      }\n    }\n  }, {\n    key: \"setNZ\",\n    value: function setNZ(value) {\n      value = this.toSigned16(value);\n      if (value < 0) {\n        this.n = 1;\n        this.z = 0;\n      } else if (value === 0) {\n        this.n = 0;\n        this.z = 1;\n      } else {\n        this.n = 0;\n        this.z = 0;\n      }\n    }\n  }, {\n    key: \"setCV\",\n    value: function setCV(sum, x, y) {\n      // Convert values to signed 16-bit integers\n      sum = this.toSigned16(sum);\n      x = this.toSigned16(x);\n      y = this.toSigned16(y);\n\n      // Initialize flags\n      this.c = 0;\n      this.v = 0;\n\n      // Carry flag logic\n      if (x >= 0 && y >= 0) {\n        this.c = 0;\n      } else if (x < 0 && y < 0) {\n        this.c = 1;\n      } else if (sum >= 0) {\n        this.c = 1;\n      } else {\n        this.c = 0;\n      }\n\n      // Overflow flag logic\n      if (x < 0 && y >= 0 || x >= 0 && y < 0) {\n        this.v = 0;\n      } else if (sum < 0 && x >= 0 || sum >= 0 && x < 0) {\n        this.v = 1;\n      } else {\n        this.v = 0;\n      }\n    }\n  }, {\n    key: \"signExtend\",\n    value: function signExtend(value, bitWidth) {\n      var signBit = 1 << bitWidth - 1;\n      var mask = (1 << bitWidth) - 1;\n      value = value & mask; // Mask the value to the specified bit width\n      if (value & signBit) {\n        // Negative number, extend the sign bits\n        value |= ~mask;\n      }\n      return value;\n    }\n  }, {\n    key: \"error\",\n    value: function error(message) {\n      // console.error(`Interpreter Error: ${message}`);\n      console.error(\"\".concat(message));\n      this.running = false;\n    }\n  }]);\n}(); // Instantiate and run the interpreter if this script is run directly\nif (\"file:///C:/Users/lettu/projects/lccjs/src/core/interpreter.js\" === \"file://\".concat(process.argv[1])) {\n  var interpreter = new Interpreter();\n  interpreter.generateStats = true; // Set to generate .lst and .bst files\n  interpreter.main();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Interpreter);\n\n//# sourceURL=webpack://LCC/./src/core/interpreter.js?");

/***/ }),

/***/ "./src/core/lcc.js":
/*!*************************!*\
  !*** ./src/core/lcc.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"./src/polyfills/fsWrapper.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n/* harmony import */ var _assembler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./assembler.js */ \"./src/core/assembler.js\");\n/* harmony import */ var _interpreter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpreter.js */ \"./src/core/interpreter.js\");\n/* harmony import */ var _linker_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./linker.js */ \"./src/core/linker.js\");\n/* harmony import */ var _utils_name_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/name.js */ \"./src/utils/name.js\");\n/* harmony import */ var _utils_genStats_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/genStats.js */ \"./src/utils/genStats.js\");\n/* provided dependency */ var process = __webpack_require__(/*! ./src/polyfills/processWrapper.js */ \"./src/polyfills/processWrapper.js\")[\"default\"];\n//#!/usr/bin/env node\n\n// lcc.js\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n\n\n\nvar newline = process.platform === 'win32' ? '\\r\\n' : '\\n';\nvar isTestMode = typeof {}.it === 'function'; // crude check for Jest\n\nfunction fatalExit(message) {\n  var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  if (isTestMode) {\n    throw new Error(message);\n  } else {\n    process.exit(code);\n  }\n}\nvar LCC = /*#__PURE__*/function () {\n  function LCC() {\n    _classCallCheck(this, LCC);\n    this.inputFileName = '';\n    this.outputFileName = '';\n    this.options = {};\n    this.args = [];\n    this.assembler = null;\n    this.interpreter = null;\n    this.inputBuffer = '';\n    this.generateStats = true;\n  }\n  return _createClass(LCC, [{\n    key: \"main\",\n    value: function main(args) {\n      args = args || process.argv.slice(2);\n      if (args.length === 0) {\n        this.printHelp();\n        fatalExit('No input file specified. Printing help message.', 0);\n      }\n      this.parseArguments(args);\n      if (this.args.length === 0) {\n        console.error('No input file specified.');\n        fatalExit('No input file specified.', 1);\n      }\n\n      // If multiple inputs were supplied, the \"main input file\" is the first one\n      this.inputFileName = this.args[0];\n      try {\n        this.userName = _utils_name_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].createNameFile(this.inputFileName);\n      } catch (error) {\n        console.error('Error handling name file:', error.message);\n        fatalExit('Error handling name file: ' + error.message, 1);\n      }\n\n      // TODO: (extra feature) check similarly to see if multiple .a files were \n      // supplied for multi-file assembly.\n      // Note: The original LCC does not check to confirm that all supplied files of .o extension\n      // const allAreObjectFiles = this.args.every(file => path.extname(file).toLowerCase() === '.o');\n\n      // Simply check to see whether the first argument is a .o file\n      var firstArgIsObjectFile = path__WEBPACK_IMPORTED_MODULE_1__.extname(this.args[0]).toLowerCase() === '.o';\n      if (firstArgIsObjectFile) {\n        // We have a linking scenario: one or more files (assumed to be .o files)\n        this.linkObjectFiles(this.args);\n      } else {\n        // The default code path: assemble or execute depending on extension\n        this.handleSingleFile(this.inputFileName);\n      }\n    }\n\n    /**\r\n     * Link multiple .o files into a single executable\r\n     */\n  }, {\n    key: \"linkObjectFiles\",\n    value: function linkObjectFiles(objectFiles) {\n      // If user provided `-o <outfile>` on the command line, we'll have it in this.outputFileName\n      // Otherwise default to `link.e` just like original LCC\n      var outputFile = this.outputFileName || 'link.e';\n\n      // Create the Linker\n      var linker = new _linker_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]();\n\n      // Perform actual linking\n      linker.link(objectFiles, outputFile);\n      // The Linker class will print \"Creating executable file link.e\" or whatever name is specified\n    }\n\n    /**\r\n     * If the input file is not .o, handle it as .hex, .bin, .e, or .a\r\n     */\n  }, {\n    key: \"handleSingleFile\",\n    value: function handleSingleFile(infile) {\n      var ext = path__WEBPACK_IMPORTED_MODULE_1__.extname(infile).toLowerCase();\n      switch (ext) {\n        case '.hex':\n        case '.bin':\n          this.assembleFile();\n          this.executeFile(false, true);\n          break;\n        case '.e':\n          this.outputFileName = infile;\n          this.executeFile(false);\n          break;\n        case '.o':\n          // to match feature parity with original LCC, we attempt to link the single .o file\n          this.assembleFile();\n          break;\n        default:\n          // Likely an assembly source (e.g. .a or anything else)\n          this.assembleFile();\n          if (!this.assembler.isObjectModule) {\n            this.executeFile(true);\n          }\n          break;\n      }\n    }\n  }, {\n    key: \"constructOutputFileName\",\n    value: function constructOutputFileName(inputFileName) {\n      var parsedPath = path__WEBPACK_IMPORTED_MODULE_1__.parse(inputFileName);\n      // Remove extension and add '.e'\n      return path__WEBPACK_IMPORTED_MODULE_1__.format(_objectSpread(_objectSpread({}, parsedPath), {}, {\n        base: undefined,\n        ext: '.e'\n      }));\n    }\n  }, {\n    key: \"printHelp\",\n    value: function printHelp() {\n      console.log('Usage: lcc.js <infile>');\n      console.log('Optional args: -d -m -r -t -f -x -l<hex loadpt> -o <outfile> -h');\n      console.log('   -d:   debug, -m mem display at end, -r: reg display at end');\n      console.log('   -f:   full line display, -x: 4 digit hout, -h: help');\n      console.log('What lcc.js does depends on the extension in the input file name:');\n      console.log('   .hex: execute and output .lst, .bst files');\n      console.log('   .bin: execute and output .lst, .bst files');\n      console.log('   .e:   execute and output .lst, .bst files');\n      console.log('   .o:   link files and output executable file');\n      console.log('   .a or other: assemble and output .e or .o, .lst, .bst files');\n      console.log('         if a .e file is created, it will also be executed');\n      console.log('File types:');\n      console.log('   .hex: machine code in ascii hex');\n      console.log('   .bin: machine code in ascii binary');\n      console.log('   .e:   executable');\n      console.log('   .o    linkable object module');\n      console.log('   .lst: time-stamped listing in hex and output from run');\n      console.log('   .bst: time-stamped listing in binary and output from run');\n      console.log('   .a or other: assembler code');\n      console.log(\"lcc.js Ver 0.1\".concat(newline));\n    }\n  }, {\n    key: \"parseArguments\",\n    value: function parseArguments(args) {\n      var i = 0;\n      while (i < args.length) {\n        var arg = args[i];\n        if (arg.startsWith('-')) {\n          // Option\n          switch (arg) {\n            case '-d':\n              this.options.debug = true;\n              break;\n            case '-m':\n              this.options.memDisplay = true;\n              break;\n            case '-r':\n              this.options.regDisplay = true;\n              break;\n            case '-f':\n              this.options.fullLineDisplay = true;\n              break;\n            case '-x':\n              this.options.hexOutput = true;\n              break;\n            case '-t':\n              this.options.trace = true;\n              break;\n            case '-nostats':\n              this.options.noStats = true;\n              break;\n            case '-h':\n              this.printHelp();\n              fatalExit('Printing help message after -h flag used.', 0);\n            default:\n              if (arg.startsWith('-l')) {\n                // Load point\n                this.options.loadPoint = parseInt(arg.substr(2), 16);\n              } else if (arg === '-o') {\n                // Output file name\n                i++;\n                if (i < args.length) {\n                  this.outputFileName = args[i];\n                } else {\n                  // individual linking output should occur, but the final\n                  // link.e file should not be created in this scenario\n                  console.error('Missing output file name'); // No output file specified after -o\n                  fatalExit('Missing output file name after -o flag', 1);\n                }\n              } else {\n                console.error(\"Unknown option: \".concat(arg));\n                fatalExit(\"Unknown option: \".concat(arg), 1);\n              }\n              break;\n          }\n        } else {\n          // Non-option argument\n          this.args.push(arg);\n        }\n        i++;\n      }\n    }\n  }, {\n    key: \"assembleFile\",\n    value: function assembleFile() {\n      var assembler = new _assembler_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n\n      // Set input and output file names\n      assembler.inputFileName = this.inputFileName;\n      assembler.outputFileName = this.outputFileName || this.constructOutputFileName(this.inputFileName);\n\n      // Update this.outputFileName to match assembler's output\n      this.outputFileName = assembler.outputFileName;\n\n      // Store the assembler instance\n      this.assembler = assembler;\n      try {\n        // Run the assembler's main function\n        assembler.main([this.inputFileName]);\n      } catch (error) {\n        console.error(\"Error assembling \".concat(this.inputFileName, \": \").concat(error.message));\n        fatalExit(\"Error assembling \".concat(this.inputFileName, \": \").concat(error.message), 1);\n      }\n    }\n\n    // Executes the output file\n    // includeSourceCode: boolean, includeComments: boolean\n    // includeSourceCode: whether to include source code in the .lst and .bst files (true when assembling and interpretting .a files)\n    // includeComments: whether to include comments in the .lst and .bst files (this option is set to true just for .bin files currently)\n  }, {\n    key: \"executeFile\",\n    value: function executeFile(includeSourceCode, includeComments) {\n      var interpreter = new _interpreter_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\n\n      // Set options in the interpreter\n      interpreter.options = this.options;\n\n      // Pass inputBuffer to interpreter\n      if (this.inputBuffer) {\n        interpreter.inputBuffer = this.inputBuffer;\n      }\n\n      // Store the interpreter instance\n      this.interpreter = interpreter;\n\n      // Load the executable file\n      interpreter.loadExecutableFile(this.outputFileName);\n      var lstFileName;\n      var bstFileName;\n      if (this.generateStats) {\n        // After execution, generate .lst and .bst files\n        lstFileName = this.outputFileName.replace(/\\.e$/, '.lst');\n        bstFileName = this.outputFileName.replace(/\\.e$/, '.bst');\n        console.log(\"lst file = \".concat(lstFileName));\n        console.log(\"bst file = \".concat(bstFileName));\n        console.log('====================================================== Output');\n      }\n\n      // Run the interpreter\n      try {\n        interpreter.run();\n        if (this.generateStats) {\n          console.log(); // Ensure cursor moves to the next line\n        }\n      } catch (error) {\n        console.error(\"Error running \".concat(this.outputFileName, \": \").concat(error.message));\n        fatalExit(\"Error running \".concat(this.outputFileName, \": \").concat(error.message), 1);\n      }\n      if (this.generateStats) {\n        // Generate .lst and .bst files using genStats.js\n        var lstContent = (0,_utils_genStats_js__WEBPACK_IMPORTED_MODULE_6__.generateBSTLSTContent)({\n          isBST: false,\n          interpreter: interpreter,\n          assembler: includeSourceCode || includeComments ? this.assembler : null,\n          userName: this.userName,\n          inputFileName: this.inputFileName,\n          includeComments: includeComments\n        });\n        var bstContent = (0,_utils_genStats_js__WEBPACK_IMPORTED_MODULE_6__.generateBSTLSTContent)({\n          isBST: true,\n          interpreter: interpreter,\n          assembler: includeSourceCode || includeComments ? this.assembler : null,\n          userName: this.userName,\n          inputFileName: this.inputFileName,\n          includeComments: includeComments\n        });\n\n        // Write the .lst and .bst files\n        fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeFileSync(lstFileName, lstContent);\n        fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeFileSync(bstFileName, bstContent);\n      } else {\n        // console.clear();\n      }\n    }\n  }]);\n}(); // Convert import.meta.url to a file path\nvar metaURL = \"file:///C:/Users/lettu/projects/lccjs/src/core/lcc.js\";\nvar scriptPath = path__WEBPACK_IMPORTED_MODULE_1__.resolve(\"file:///C:/Users/lettu/projects/lccjs/src/core/lcc.js\".replace(\"file:///\", \"\"));\nif (scriptPath === process.argv[1]) {\n  var lcc = new LCC();\n  lcc.main();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LCC);\n\n//# sourceURL=webpack://LCC/./src/core/lcc.js?");

/***/ }),

/***/ "./src/core/linker.js":
/*!****************************!*\
  !*** ./src/core/linker.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"./src/polyfills/fsWrapper.js\");\n/* provided dependency */ var process = __webpack_require__(/*! ./src/polyfills/processWrapper.js */ \"./src/polyfills/processWrapper.js\")[\"default\"];\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n//#!/usr/bin/env node\n// linker.js\n// LCC.js Linker\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar isTestMode = typeof {}.it === 'function'; // crude check for Jest\n\nfunction fatalExit(message) {\n  var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  if (isTestMode) {\n    throw new Error(message);\n  } else {\n    process.exit(code);\n  }\n}\nvar Linker = /*#__PURE__*/function () {\n  function Linker() {\n    _classCallCheck(this, Linker);\n    this.mca = []; // Machine Code Array\n    this.mcaIndex = 0;\n    this.GTable = {}; // Global symbols: label -> address\n    this.ETable = []; // External references with 11-bit addresses\n    this.eTable = []; // External references with 9-bit addresses\n    this.VTable = []; // External references with full addresses\n    this.ATable = []; // Local references\n    this.start = null;\n    this.gotStart = false;\n    this.errorFlag = false;\n    this.objectModules = []; // List of object modules to process\n    this.inputFiles = []; // List of input files\n    this.outputFileName = null; // Output file name\n  }\n  return _createClass(Linker, [{\n    key: \"main\",\n    value: function main(args) {\n      args = args || process.argv.slice(2);\n      if (args.length < 1) {\n        console.error('Usage: node linker.js [-o outputfile.e] <object module 1> <object module 2> ...');\n        fatalExit('Usage: node linker.js [-o outputfile.e] <object module 1> <object module 2> ...', 1);\n      }\n      var i = 0;\n      while (i < args.length) {\n        if (args[i] === '-o') {\n          if (i + 1 >= args.length) {\n            console.error('Missing output file name after -o');\n            fatalExit('Missing output file name after -o', 1);\n          }\n          this.outputFileName = args[i + 1];\n          i += 2;\n        } else {\n          this.inputFiles.push(args[i]);\n          i++;\n        }\n      }\n      if (this.inputFiles.length === 0) {\n        console.error('Error: No input object modules specified');\n        fatalExit('Error: No input object modules specified', 1);\n      }\n      this.link(this.inputFiles, this.outputFileName);\n    }\n\n    // Method to read object modules from files\n  }, {\n    key: \"readObjectModule\",\n    value: function readObjectModule(filename) {\n      var buffer = fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].readFileSync(filename);\n      var offset = 0;\n      if (buffer[offset++] !== 'o'.charCodeAt(0)) {\n        this.error(\"\".concat(filename, \" not a linkable file\"));\n        return;\n      }\n      var module = {\n        headers: [],\n        code: []\n      };\n\n      // Process headers\n      while (offset < buffer.length) {\n        var entryType = String.fromCharCode(buffer[offset++]);\n        if (entryType === 'C') {\n          // End of header, start of code\n          break;\n        }\n        switch (entryType) {\n          case 'S':\n            {\n              if (offset + 1 >= buffer.length) {\n                this.error('Invalid S entry');\n                return;\n              }\n              var address = buffer.readUInt16LE(offset);\n              offset += 2;\n              module.headers.push({\n                type: 'S',\n                address: address\n              });\n              break;\n            }\n          case 'G':\n          case 'E':\n          case 'e':\n          case 'V':\n            {\n              if (offset + 1 >= buffer.length) {\n                // Incomplete entry\n                this.error(\"Invalid \".concat(entryType, \" entry\"));\n                return;\n              }\n              var _address = buffer.readUInt16LE(offset);\n              offset += 2;\n              var label = '';\n              while (offset < buffer.length) {\n                var charCode = buffer[offset++];\n                if (charCode === 0) break; // Null terminator\n                label += String.fromCharCode(charCode);\n              }\n              module.headers.push({\n                type: entryType,\n                address: _address,\n                label: label\n              });\n              break;\n            }\n          case 'A':\n            {\n              if (offset + 1 >= buffer.length) {\n                this.error('Invalid A entry');\n                return;\n              }\n              var _address2 = buffer.readUInt16LE(offset);\n              offset += 2;\n              module.headers.push({\n                type: 'A',\n                address: _address2\n              });\n              break;\n            }\n          default:\n            this.error(\"Unknown header entry \".concat(entryType, \" in file \").concat(filename));\n            return;\n        }\n      }\n\n      // Read code\n      while (offset + 1 < buffer.length) {\n        var word = buffer.readUInt16LE(offset);\n        offset += 2;\n        module.code.push(word);\n      }\n\n      // Store the module for processing\n      this.objectModules.push(module);\n    }\n  }, {\n    key: \"link\",\n    value: function link(filenames, outputFileName) {\n      this.inputFiles = filenames; // Save input files\n      this.outputFileName = outputFileName || 'link.e'; // Save output filename\n\n      // Read all object modules\n      var _iterator = _createForOfIteratorHelper(filenames),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var filename = _step.value;\n          this.readObjectModule(filename);\n          if (this.errorFlag) {\n            // If invalid file or read error encountered, stop immediately\n            return null;\n          }\n          console.log(\"Linking \".concat(filename));\n        }\n\n        // Process each module\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var _iterator2 = _createForOfIteratorHelper(this.objectModules),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var module = _step2.value;\n          this.processModule(module);\n          if (this.errorFlag) {\n            return null;\n          }\n        }\n\n        // Adjust external references\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      this.adjustExternalReferences();\n      if (this.errorFlag) return;\n\n      // Adjust local references\n      this.adjustLocalReferences();\n      if (this.errorFlag) return;\n\n      // Create executable\n      console.log(\"Creating executable file \".concat(this.outputFileName));\n      this.createExecutable();\n    }\n  }, {\n    key: \"processModule\",\n    value: function processModule(module) {\n      // Process headers\n      var headers = module.headers;\n      var code = module.code;\n      var _iterator3 = _createForOfIteratorHelper(headers),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var header = _step3.value;\n          switch (header.type) {\n            case 'S':\n              if (this.gotStart) {\n                this.error('Multiple entry points');\n                return;\n              }\n              this.start = header.address + this.mcaIndex;\n              this.gotStart = true;\n              break;\n            case 'G':\n              if (this.GTable.hasOwnProperty(header.label)) {\n                this.error(\"Multiple definitions of global symbol \".concat(header.label));\n                return;\n              }\n              this.GTable[header.label] = header.address + this.mcaIndex;\n              break;\n            case 'E':\n              this.ETable.push({\n                address: header.address + this.mcaIndex,\n                label: header.label\n              });\n              break;\n            case 'e':\n              this.eTable.push({\n                address: header.address + this.mcaIndex,\n                label: header.label\n              });\n              break;\n            case 'V':\n              this.VTable.push({\n                address: header.address + this.mcaIndex,\n                label: header.label\n              });\n              break;\n            case 'A':\n              this.ATable.push({\n                address: header.address + this.mcaIndex,\n                moduleStart: this.mcaIndex\n              });\n              break;\n            default:\n              this.error(\"Invalid header entry: \".concat(header.type));\n              return;\n          }\n        }\n\n        // Append code to mca\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      var _iterator4 = _createForOfIteratorHelper(code),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var word = _step4.value;\n          this.mca[this.mcaIndex++] = word;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"adjustExternalReferences\",\n    value: function adjustExternalReferences() {\n      // Adjust ETable (11-bit addresses)\n      var _iterator5 = _createForOfIteratorHelper(this.ETable),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var ref = _step5.value;\n          if (!this.GTable.hasOwnProperty(ref.label)) {\n            this.error(\"\".concat(ref.label, \" is an undefined external reference\"));\n            return;\n          }\n          var Gaddr = this.GTable[ref.label];\n          var offset = this.mca[ref.address] + Gaddr - ref.address - 1 & 0x7ff;\n          this.mca[ref.address] = this.mca[ref.address] & 0xf800 | offset;\n        }\n\n        // Adjust eTable (9-bit addresses)\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      var _iterator6 = _createForOfIteratorHelper(this.eTable),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _ref = _step6.value;\n          if (!this.GTable.hasOwnProperty(_ref.label)) {\n            this.error(\"\".concat(_ref.label, \" is an undefined external reference\"));\n            return;\n          }\n          var _Gaddr = this.GTable[_ref.label];\n          var _offset = this.mca[_ref.address] + _Gaddr - _ref.address - 1 & 0x1ff;\n          this.mca[_ref.address] = this.mca[_ref.address] & 0xfe00 | _offset;\n        }\n\n        // Adjust VTable (full addresses)\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      var _iterator7 = _createForOfIteratorHelper(this.VTable),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _ref2 = _step7.value;\n          if (!this.GTable.hasOwnProperty(_ref2.label)) {\n            this.error(\"\".concat(_ref2.label, \" is an undefined external reference\"));\n            return;\n          }\n          var _Gaddr2 = this.GTable[_ref2.label];\n          this.mca[_ref2.address] += _Gaddr2;\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }, {\n    key: \"adjustLocalReferences\",\n    value: function adjustLocalReferences() {\n      var _iterator8 = _createForOfIteratorHelper(this.ATable),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var ref = _step8.value;\n          this.mca[ref.address] += ref.moduleStart;\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  }, {\n    key: \"createExecutable\",\n    value: function createExecutable() {\n      // Write executable file\n      var outfileName = this.outputFileName;\n\n      // Write executable file\n      var outFile = fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].openSync(outfileName, 'w');\n\n      // Write file signature\n      fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(outFile, 'o');\n\n      // Write 'S' entry if we have a start address\n      if (this.gotStart) {\n        var buffer = Buffer.alloc(3);\n        buffer.write('S', 0, 'ascii');\n        buffer.writeUInt16LE(this.start, 1);\n        fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(outFile, buffer);\n      }\n\n      // Write 'G' entries\n      for (var label in this.GTable) {\n        var address = this.GTable[label];\n        var _buffer = Buffer.alloc(3 + label.length + 1);\n        _buffer.write('G', 0, 'ascii');\n        _buffer.writeUInt16LE(address, 1);\n        _buffer.write(label, 3, 'ascii');\n        _buffer.writeUInt8(0, 3 + label.length); // Null terminator\n        fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(outFile, _buffer);\n      }\n\n      // Write 'A' entries for VTable entries\n      var _iterator9 = _createForOfIteratorHelper(this.VTable),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var ref = _step9.value;\n          var _buffer2 = Buffer.alloc(3);\n          _buffer2.write('A', 0, 'ascii');\n          _buffer2.writeUInt16LE(ref.address, 1);\n          fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(outFile, _buffer2);\n        }\n\n        // Write 'A' entries\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n      var _iterator10 = _createForOfIteratorHelper(this.ATable),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var _ref3 = _step10.value;\n          var _buffer3 = Buffer.alloc(3);\n          _buffer3.write('A', 0, 'ascii');\n          _buffer3.writeUInt16LE(_ref3.address, 1);\n          fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(outFile, _buffer3);\n        }\n\n        // Terminate header\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n      fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(outFile, 'C');\n\n      // Write machine code\n      var codeBuffer = Buffer.alloc(this.mca.length * 2);\n      for (var i = 0; i < this.mca.length; i++) {\n        codeBuffer.writeUInt16LE(this.mca[i], i * 2);\n      }\n      fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeSync(outFile, codeBuffer);\n      fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].closeSync(outFile);\n    }\n  }, {\n    key: \"error\",\n    value: function error(message) {\n      console.error(\"\".concat(message)); // linker error\n      this.errorFlag = true;\n    }\n  }]);\n}();\nif (\"file:///C:/Users/lettu/projects/lccjs/src/core/linker.js\" === \"file://\".concat(process.argv[1])) {\n  var linker = new Linker();\n  linker.main();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Linker);\n\n//# sourceURL=webpack://LCC/./src/core/linker.js?");

/***/ }),

/***/ "./src/polyfills/fsWrapper.js":
/*!************************************!*\
  !*** ./src/polyfills/fsWrapper.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\nconsole.warn(\"FS Polyfill is being used in the browser.\");\nvar storageKey = \"fsWrapper\";\n\n// Load storage from localStorage\nvar storage = {}; //JSON.parse(localStorage.getItem(storageKey) || \"{}\");\n\n// Function to save to localStorage\nvar saveStorage = function saveStorage() {\n  //localStorage.setItem(storageKey, JSON.stringify(storageProxy));\n};\n\n// Create a proxy that automatically updates `window.fsWrapperStorage` and `localStorage`\nvar handler = {\n  subscribers: [],\n  get: function get(target, key) {\n    handler.subscribers.forEach(function (callback) {\n      return callback('get', key, target[key]);\n    });\n    return target[key];\n  },\n  set: function set(target, key, value) {\n    target[key] = value;\n    saveStorage();\n    self.fsWrapperStorage = target; // Ensure it stays in sync\n    handler.subscribers.forEach(function (callback) {\n      return callback('set', key, value);\n    });\n    return true;\n  },\n  deleteProperty: function deleteProperty(target, key) {\n    if (key in target) {\n      delete target[key];\n      saveStorage();\n      self.fsWrapperStorage = target;\n      handler.subscribers.forEach(function (callback) {\n        return callback('delete', key);\n      });\n      return true;\n    }\n    return false;\n  },\n  subscribe: function subscribe(callback) {\n    handler.subscribers.push(callback);\n  }\n};\nvar storageProxy = new Proxy(storage, handler);\n\n// Update global reference\nself.fsWrapperStorage = storageProxy;\nself.fsWrapperStorage.subscribe = handler.subscribe;\nvar inputBuffer = [];\nvar inputBufferHandler = {\n  subscribers: [],\n  get: function get(target, key) {\n    if (typeof target[key] === \"function\") {\n      return target[key].bind(target);\n    }\n    inputBufferHandler.subscribers.forEach(function (callback) {\n      return callback('get', key, target[key]);\n    });\n    return target[key];\n  },\n  set: function set(target, key, value) {\n    target[key] = value;\n    inputBufferHandler.subscribers.forEach(function (callback) {\n      return callback('set', key, value);\n    });\n    return true;\n  },\n  apply: function apply(target, thisArg, args) {\n    if (typeof target === \"function\") {\n      var result = target.apply(thisArg, args);\n      inputBufferHandler.subscribers.forEach(function (callback) {\n        return callback('apply', target.name, args, result);\n      });\n      return result;\n    }\n  },\n  push: function push(target) {\n    for (var _len = arguments.length, items = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      items[_key - 1] = arguments[_key];\n    }\n    var result = target.push.apply(target, items);\n    inputBufferHandler.subscribers.forEach(function (callback) {\n      return callback('push', items);\n    });\n    return result;\n  },\n  shift: function shift(target) {\n    var result = target.shift();\n    inputBufferHandler.subscribers.forEach(function (callback) {\n      return callback('shift', result);\n    });\n    return result;\n  },\n  subscribe: function subscribe(callback) {\n    inputBufferHandler.subscribers.push(callback);\n  }\n};\nself.inputBuffer = inputBufferProxy;\n\n// Proxy for input buffer\nvar inputBufferProxy = new Proxy(inputBuffer, {\n  get: function get(target, key) {\n    if (key === \"subscribe\") return inputBufferHandler.subscribe;\n    if (key === \"push\") return inputBufferHandler.push.bind(null, target);\n    if (key === \"shift\") return inputBufferHandler.shift.bind(null, target);\n    return target[key];\n  },\n  set: function set(target, key, value) {\n    target[key] = value;\n    inputBufferHandler.subscribers.forEach(function (callback) {\n      return callback('set', key, value);\n    });\n    return true;\n  }\n});\n\n// File System Wrapper\nvar fsWrapper = {\n  readFile: function readFile(path, encoding, callback) {\n    if (typeof encoding === \"function\") {\n      callback = encoding;\n      encoding = \"utf8\";\n    }\n    setTimeout(function () {\n      if (storageProxy[path]) {\n        callback(null, storageProxy[path]);\n      } else {\n        callback(new Error(\"File not found\"), null);\n      }\n    }, 10);\n  },\n  writeFile: function writeFile(path, data, callback) {\n    setTimeout(function () {\n      storageProxy[path] = data;\n      callback(null);\n    }, 10);\n  },\n  existsSync: function existsSync(path) {\n    return !!storageProxy[path];\n  },\n  readdir: function readdir(path, callback) {\n    setTimeout(function () {\n      return callback(null, Object.keys(storageProxy));\n    }, 10);\n  },\n  unlink: function unlink(path, callback) {\n    setTimeout(function () {\n      delete storageProxy[path];\n      callback(null);\n    }, 10);\n  },\n  mkdir: function mkdir(path, options, callback) {\n    setTimeout(function () {\n      return callback(null);\n    }, 10);\n  },\n  // Synchronous methods\n  readdirSync: function readdirSync() {\n    return Object.keys(storageProxy);\n  },\n  writeFileSync: function writeFileSync(path, data) {\n    storageProxy[path] = data;\n  },\n  readFileSync: function readFileSync(path, encoding) {\n    if (storageProxy[path]) {\n      if (encoding === \"utf-8\" || encoding === \"utf8\") {\n        return storageProxy[path];\n      }\n      return Buffer.from(storageProxy[path].split('').map(function (_char) {\n        return _char.codePointAt(0);\n      }));\n    }\n    throw new Error(\"File not found\");\n  },\n  statSync: function statSync(path) {\n    if (storageProxy[path]) {\n      return {\n        size: storageProxy[path].length,\n        isFile: true\n      };\n    }\n    throw new Error(\"File not found\");\n  },\n  mkdirSync: function mkdirSync() {},\n  copyFileSync: function copyFileSync(src, dest) {\n    if (!storageProxy[src]) throw new Error(\"Source file not found\");\n    storageProxy[dest] = storageProxy[src];\n  },\n  unlinkSync: function unlinkSync(path) {\n    delete storageProxy[path];\n  },\n  writeSync: function writeSync(fd, data) {\n    console.log(fd, data);\n    if (fd === 0) {\n      // If it's stdin, write it to the input buffer\n      inputBufferProxy.push(data);\n    } else {\n      if (data instanceof Buffer) {\n        data = Array.from(data, function (_byte) {\n          return String.fromCodePoint(_byte);\n        }).join('');\n      }\n      storageProxy[fd] = (storageProxy[fd] || \"\") + data;\n    }\n  },\n  openSync: function openSync(path, flags) {\n    if (!storageProxy[path]) storageProxy[path] = \"\";\n    return path;\n  },\n  readSync: function readSync(fd, buffer, offset, length, position) {\n    if (fd === 0) {\n      // If it's stdin, read from the buffer\n      if (inputBufferProxy.length == 0) self.waitForInput();\n      if (inputBufferProxy.length > 0) {\n        var inputData = inputBufferProxy.shift();\n        var _bytesRead = Math.min(length, inputData.length);\n        buffer.set(Buffer.from(inputData.slice(0, _bytesRead)), offset);\n        return _bytesRead;\n      } else {\n        // Call the sleep callback.\n        console.error(\"No input data available even after waiting.\");\n      }\n      return 0;\n    }\n    var data = storageProxy[fd];\n    if (!data) return 0;\n    var bytesRead = Math.min(length, data.length - position);\n    buffer.set(Buffer.from(data.slice(position, position + bytesRead)), offset);\n    return bytesRead;\n  },\n  closeSync: function closeSync() {}\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (fsWrapper);\n\n//# sourceURL=webpack://LCC/./src/polyfills/fsWrapper.js?");

/***/ }),

/***/ "./src/polyfills/processWrapper.js":
/*!*****************************************!*\
  !*** ./src/polyfills/processWrapper.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconsole.warn(\"Process Polyfill is being used in the browser.\");\nvar inputBuffer = [];\nvar inputCallback = null;\n\n// Create a hidden input element to simulate stdin\n// const stdinInput = document.createElement(\"input\");\n// stdinInput.type = \"text\";\n// stdinInput.style.position = \"absolute\";\n// stdinInput.style.left = \"-9999px\"; // Hide it offscreen\n// document.body.appendChild(stdinInput);\n\n// // Capture user input into the buffer\n// stdinInput.addEventListener(\"keydown\", (event) => {\n//     if (event.key === \"Enter\") {\n//         event.preventDefault();\n//         inputBuffer.push(stdinInput.value + \"\\n\");\n//         stdinInput.value = \"\";\n//         if (inputCallback) {\n//             inputCallback();\n//         }\n//     }\n// });\n\nvar process = {\n  cwd: function cwd() {\n    return \"/\";\n  },\n  env: {},\n  exit: function exit(code) {\n    process.subscribers.forEach(function (callback) {\n      return callback(\"exit\", code);\n    });\n    console.warn(\"Process exited with code:\", code);\n  },\n  stdout: {\n    write: function write(data) {\n      process.subscribers.forEach(function (callback) {\n        return callback(\"stdout.write\", data);\n      });\n      console.log(data);\n    }\n  },\n  platform: \"browser\",\n  argv: [\"browser\", \"polyfill\"],\n  stdin: {\n    fd: 0,\n    // Fake file descriptor\n    read: function read(callback) {\n      console.log(\"read\");\n      process.subscribers.forEach(function (callback) {\n        return callback(\"stdin\");\n      });\n      inputCallback = callback;\n    },\n    readSync: function readSync() {\n      console.log(\"readSync\");\n      process.subscribers.forEach(function (callback) {\n        return callback(\"stdin\");\n      });\n      return inputBuffer.length > 0 ? inputBuffer.shift() : null;\n    }\n  },\n  // Subscribe to events\n  subscribers: [],\n  subscribe: function subscribe(callback) {\n    process.subscribers.push(callback);\n  }\n};\nself.process = process;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (process);\n\n//# sourceURL=webpack://LCC/./src/polyfills/processWrapper.js?");

/***/ }),

/***/ "./src/utils/genStats.js":
/*!*******************************!*\
  !*** ./src/utils/genStats.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   generateBSTLSTContent: () => (/* binding */ generateBSTLSTContent)\n/* harmony export */ });\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n// genStats.js\n\nfunction generateBSTLSTContent(options) {\n  var isBST = options.isBST,\n    interpreter = options.interpreter,\n    assembler = options.assembler,\n    userName = options.userName,\n    inputFileName = options.inputFileName,\n    includeComments = options.includeComments;\n  var content = '';\n\n  // Header\n  content += \"LCC.js Assemble/Link/Interpret/Debug Ver 0.1  \".concat(new Date().toLocaleString('en-US', {\n    weekday: 'short',\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    hour12: false\n  }), \"\\n\");\n  content += \"\".concat(userName, \"\\n\\n\");\n  content += 'Header\\n';\n  content += 'o\\n';\n\n  // Only if headerLines exist\n  if (assembler && assembler.headerLines && assembler.headerLines.length > 0) {\n    for (var i = 0; i < assembler.headerLines.length; i++) {\n      content += \"\".concat(assembler.headerLines[i], \"\\n\");\n    }\n  } else if (interpreter && interpreter.headerLines && interpreter.headerLines.length > 0) {\n    for (var _i = 0; _i < interpreter.headerLines.length; _i++) {\n      content += \"\".concat(interpreter.headerLines[_i], \"\\n\");\n    }\n  }\n  content += 'C\\n\\n';\n\n  // Output code\n  if (assembler && assembler.listing) {\n    if (!options.includeComments) {\n      content += 'Loc   Code           Source Code\\n';\n    } else {\n      content += 'Loc   Code\\n';\n    }\n    assembler.listing.forEach(function (entry) {\n      var codeWords = entry.codeWords;\n      var macWord = entry.macWord;\n      if (codeWords && codeWords.length > 0) {\n        var locCtr = entry.locCtr;\n        codeWords.forEach(function (word, index) {\n          var wordStr = isBST ? word.toString(2).padStart(16, '0').replace(/(.{4})/g, '$1 ').trim() : word.toString(16).padStart(4, '0');\n          var lineStr = \"\".concat(locCtr.toString(16).padStart(4, '0'), \"  \").concat(wordStr.padEnd(10));\n          if (index === 0) {\n            // Include source code\n            lineStr += \" \".concat(entry.sourceLine);\n          }\n          content += \"\".concat(lineStr, \"\\n\");\n          locCtr++;\n        });\n      } else if (codeWords && codeWords.length === 0) {\n        // No code words, do not include the source line\n        var lineStr = \"                    \".concat(entry.sourceLine);\n        content += \"\".concat(lineStr, \"\\n\");\n      } else if (macWord !== '') {\n        // Machine word exists (for .bin files)\n        var wordStr = isBST ? macWord.toString(2).padStart(16, '0').replace(/(.{4})/g, '$1 ').trim() : macWord.toString(16).padStart(4, '0');\n\n        // Build a line with \"Loc\" and the code word in hex (or bin), plus optional \"; comment\"\n        var _lineStr = \"\".concat(entry.locCtr.toString(16).padStart(4, '0'), \"  \").concat(wordStr);\n        if (includeComments && entry.comment) {\n          _lineStr += \" ; \".concat(entry.comment);\n        }\n        content += _lineStr + '\\n';\n      }\n    });\n  } else if (interpreter && interpreter.mem) {\n    content += 'Loc   Code\\n';\n\n    // Output code from interpreter's memory\n    for (var addr = interpreter.loadPoint; addr <= interpreter.memMax; addr++) {\n      var locStr = addr.toString(16).padStart(4, '0');\n      var word = interpreter.initialMem[addr];\n      var wordStr = isBST ? word.toString(2).padStart(16, '0').replace(/(.{4})/g, '$1 ').trim() : word.toString(16).padStart(4, '0');\n      content += \"\".concat(locStr, \"  \").concat(wordStr, \"\\n\");\n    }\n  }\n\n  // Output Output section and Program statistics if interpreter is provided\n  if (interpreter) {\n    content += '====================================================== Output\\n';\n    content += \"\".concat(interpreter.output, \"\\n\");\n    content += '========================================== Program statistics\\n';\n\n    // Prepare the statistics\n    var stats = [{\n      label: 'Input file name',\n      value: inputFileName\n    }, {\n      label: 'Instructions executed',\n      value: \"\".concat(interpreter.instructionsExecuted.toString(16), \" (hex)    \").concat(interpreter.instructionsExecuted, \" (dec)\")\n    }, {\n      label: 'Program size',\n      value: \"\".concat((interpreter.memMax - interpreter.loadPoint + 1).toString(16), \" (hex)    \").concat(interpreter.memMax + 1, \" (dec)\")\n    }, {\n      label: 'Max stack size',\n      value: \"\".concat(interpreter.maxStackSize.toString(16), \" (hex)    \").concat(interpreter.maxStackSize, \" (dec)\")\n    }, {\n      label: 'Load point',\n      value: \"\".concat(interpreter.loadPoint.toString(16), \" (hex)    \").concat(interpreter.loadPoint, \" (dec)\")\n    }];\n    var maxStatLabelLength = Math.max.apply(Math, _toConsumableArray(stats.map(function (s) {\n      return s.label.length;\n    })));\n    stats.forEach(function (stat) {\n      var label = stat.label.padEnd(maxStatLabelLength + 4); // Add 4 spaces for padding\n      content += \"\".concat(label, \"=   \").concat(stat.value, \"\\n\");\n    });\n  }\n  return content;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  generateBSTLSTContent: generateBSTLSTContent\n});\n\n//# sourceURL=webpack://LCC/./src/utils/genStats.js?");

/***/ }),

/***/ "./src/utils/name.js":
/*!***************************!*\
  !*** ./src/utils/name.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"./src/polyfills/fsWrapper.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! ./src/polyfills/processWrapper.js */ \"./src/polyfills/processWrapper.js\")[\"default\"];\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n// name.js\n// LCC.js Namer\n\n// This program's purpose is to check for a name.nnn file.\n// If it exists, it reads the name from the file to use.\n// If name.nnn does not exist, this program prompts the \n// user for their name, creates the name.nnn file, and\n// saves the name inside of it.\n// This program asks t he user for their name in the \n// format \"LastName, FirstName MiddleInitial\"\n\n\n\nvar newline = process.platform === 'win32' ? '\\r\\n' : '\\n';\nvar prompt = \"Enter familyname, firstname middleinitial (if any)\".concat(newline);\nfunction readLineFromStdin() {\n  var input = '';\n  var buffer = Buffer.alloc(1);\n  var fd = process.stdin.fd;\n  while (true) {\n    try {\n      var bytesRead = fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].readSync(fd, buffer, 0, 1, null);\n      if (bytesRead === 0) {\n        // EOF\n        break;\n      }\n      var _char = buffer.toString('utf8');\n      if (_char === '\\n' || _char === '\\r') {\n        // Stop reading input on newline or carriage return\n        break;\n      }\n      input += _char;\n    } catch (err) {\n      if (err.code === 'EAGAIN') {\n        // Resource temporarily unavailable, wait a bit and retry\n        continue;\n      } else {\n        throw err;\n      }\n    }\n  }\n  return input;\n}\nfunction createNameFile(inputPath) {\n  // Get the directory of the input file\n  var dir = path__WEBPACK_IMPORTED_MODULE_1__.dirname(inputPath);\n  var nameFile = path__WEBPACK_IMPORTED_MODULE_1__.join(dir, 'name.nnn');\n\n  // Check if name.nnn already exists\n  if (fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].existsSync(nameFile)) {\n    return fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].readFileSync(nameFile, 'utf8').trim();\n  }\n\n  // If not, prompt for name\n  process.stdout.write(prompt);\n  var name = readLineFromStdin();\n\n  // Note: The lcc does not validate that names are properly formatted,\n  // but it should make sure that the name is not empty.\n  if (name.trim() === '') {\n    console.error('Name cannot be empty');\n    process.exit(1);\n  }\n\n  // Write to name.nnn file with \\n if on linux/mac or \\r\\n if on windows\n  fs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].writeFileSync(nameFile, name + newline, {\n    encoding: 'utf8'\n  });\n  return name;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  createNameFile: createNameFile\n});\n\n//# sourceURL=webpack://LCC/./src/utils/name.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/core/lcc.js");
/******/ 	LCC = __webpack_exports__;
/******/ 	
/******/ })()
;